{"head":{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","id":32159,"description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i++) {…"},"body":"<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n<p>Trong bài học này, chúng ta sẽ cùng nhau tìm hiểu một khái niệm nâng cao của con trỏ: \"Con trỏ trỏ đến con trỏ\".</p>\n<h3>Pointer to pointer</h3>\n<p><strong>Pointer to pointer</strong> là một loại con trỏ dùng để lưu trữ địa chỉ của biến con trỏ. </p>\n<p>Mình lấy ví dụ về việc sử dụng con trỏ thông thường:</p>\n<p></p><pre><code class=\"lang-auto\">int value;\nint *ptr = &amp;value;</code></pre>\n<p>Chúng ta gán được địa chỉ của biến value cho con trỏ <strong>ptr</strong> vì biến <strong>value</strong> là biến kiểu <strong>int</strong>, và sử dụng toán tử <strong>address-of</strong> cho biến value sẽ trả về giá trị kiểu (int *) giống với kiểu dữ liệu của con trỏ ptr.</p>\n<p>Như vậy, nếu chúng ta muốn <strong>Pointer to pointer</strong> trỏ đến được một <strong>pointer</strong> khác, trước hết chúng ta cần xem kiểu dữ liệu khi sử dụng toán tử <strong>address-of</strong> cho con trỏ sẽ trả về giá trị kiểu gì.</p>\n<p></p><pre><code class=\"lang-auto\">int *ptr = NULL;\ncout &lt;&lt;\ttypeid(&amp;ptr).name() &lt;&lt; endl;</code></pre>\n<p>Kết quả:</p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-7-con-tro-tro-den-con-tro/0.png?raw=true\" width=\"579\" height=\"384\"></p>\n<p>Như chúng ta thấy, chúng ta cần khai báo biến có kiểu dữ liệu (int **) để có thể gán địa chỉ của con trỏ kiểu (int *) cho nó. Let's try:</p>\n<p></p><pre><code class=\"lang-auto\">int *ptr = NULL;\nint **p_to_p = &amp;ptr;</code></pre>\n<p>Con trỏ <code>p_to_p</code> được gọi là một <strong>Pointer to pointer.</strong></p>\n<p>Cũng tương tự như khi sử dụng con trỏ thông thường, chúng ta có thể sử dụng toán tử <strong>dereference</strong> cho một <strong>Pointer to pointer.</strong></p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>int value = 100;\nint *ptr = &#x26;amp;value;\nint **p_to_p = &#x26;amp;ptr;\n\ncout &#x26;lt;&#x26;lt; p_to_p &#x26;lt;&#x26;lt; endl; //print address of ptr\ncout &#x26;lt;&#x26;lt; *p_to_p &#x26;lt;&#x26;lt; endl; //print address which hold by ptr\ncout &#x26;lt;&#x26;lt; **p_to_p &#x26;lt;&#x26;lt; endl; //print value at address which hold by ptr\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Bản chất của <strong>Pointer to pointer</strong> vẫn là một <strong>pointer</strong>, nên khi truy xuất giá trị của <code>p_to_p</code> chúng ta lấy được địa chỉ mà nó trỏ đến (địa chỉ của biến ptr).</p>\n<p></p><pre><code class=\"lang-auto\">p_to_p; //là &amp;ptr</code></pre>\n<p>Khi chúng ta sử dụng 1 toán tử <strong>dereference</strong> cho 1 <strong>pointer to pointer</strong>, cũng đồng nghĩa chúng ta đang truy xuất đến giá trị tại địa chỉ mà con trỏ ptr nắm giữ (địa chỉ đang được lưu trữ trong biến ptr).</p>\n<p></p><pre><code class=\"lang-auto\">*p_to_p; //là ptr</code></pre>\n<p>Và khi sử dụng 2 toán tử <strong>dereference</strong> cho 1 <strong>pointer to pointer,</strong> có thể viết lại như sau:</p>\n<p></p><pre><code class=\"lang-auto\">*(*p_to_p); //là *ptr</code></pre>\n<p>Chúng ta có thể thấy việc sử dụng <strong>pointer to pointer</strong> cũng tương tự như việc đi hỏi tìm một người bạn mà không biết nhà nó ở đâu, chỉ biết nhà của những người biết về nó. Vậy là chúng ta đi hỏi từng người một.</p>\n<p>Ví dụ chúng ta là A, đang cần gặp C nhưng không biết nó ở đâu, chúng ta hỏi (sử dụng toán tử dereference) chú B thì chú B bảo đến địa chỉ mà C đang ở, chúng ta đến địa chỉ mà chú B nắm giữ và truy xuất vào đó là sẽ tìm được thằng C.</p>\n<p>Tóm tắt lại ví dụ trên, chúng ta có thể viết:</p>\n<p>A giữ địa chỉ nhà chú \t\t B =&gt; A = &amp;B;<br>Chú B biết địa chỉ nhà thằng C =&gt; B = &amp;C;</p>\n<p>Như vậy:</p>\n<p>(<em>A) tương đương (</em>(&amp;B)) tương đương &amp;C;<br><em>(</em>A) tương đương <em>(</em>(&amp;B)) tương đương C;</p>\n<p>Áp dụng lại cho ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>int value = 100;\nint *ptr = &#x26;amp;value;\nint **p_to_p = &#x26;amp;ptr;\n\ncout &#x26;lt;&#x26;lt; p_to_p &#x26;lt;&#x26;lt; endl; //print address of ptr\ncout &#x26;lt;&#x26;lt; *p_to_p &#x26;lt;&#x26;lt; endl; //print address which hold by ptr\ncout &#x26;lt;&#x26;lt; **p_to_p &#x26;lt;&#x26;lt; endl; //print value at address which hold by ptr\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Chúng ta có thể viết:</p>\n<p>p_to_p giữ địa chỉ của ptr =&gt; p_to_p = &amp;ptr;<br>ptr giữ địa chỉ của value  =&gt; ptr = &amp;value;</p>\n<p>Như vậy:</p>\n<p>(*p_to_p) tương đương ptr tương đương &amp;value;<br>**p_to_p tương đương *ptr tương đương value;</p>\n<p><div class=\"lightbox-wrapper\"><a href=\"https://raw.githubusercontent.com/nguyenchiemminhvu/CPP-Tutorial/master/8-con-tro/8-7-con-tro-tro-den-con-tro/1.png\" class=\"lightbox\" title=\"1.png\" rel=\"nofollow\"><img src=\"https://raw.githubusercontent.com/nguyenchiemminhvu/CPP-Tutorial/master/8-con-tro/8-7-con-tro-tro-den-con-tro/1.png\" width=\"690\" height=\"290\"><div class=\"meta\">\n<span class=\"filename\">1.png</span><span class=\"informations\">910x383</span><span class=\"expand\"></span>\n</div></a></div></p>\n<p>Chúng ta không thể gán trực tiếp như sau:</p>\n<p></p><pre><code class=\"lang-auto\">int **p_to_p = &amp;&amp;value; //not valid</code></pre>\n<p>Vì p_to_p là lvalue, &amp;&amp;value là rvalue. <a href=\"https://msdn.microsoft.com/en-us/library/f90831hc.aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/f90831hc.aspx</a></p>\n<p>Và cũng tương tự như những con trỏ khác, Pointer to pointer có thể gán giá trị NULL:</p>\n<p></p><pre><code class=\"lang-auto\">int **p_to_p = NULL;</code></pre>\n<h3>Array of pointers</h3>\n<p><strong>Pointer to pointer</strong> có thể được dùng để quản lý mảng một chiều kiểu con trỏ (int *[]). Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>int *p1 = NULL;\nint *p2 = NULL;\nint *p3 = NULL;\n\nint *p[] = { p1, p2, p3 };\n\nint **p_to_p = p;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Trong trường hợp này, p_to_p[0] tương đương với p[0].</p>\n<p>Thông thường, chúng ta sẽ sử dụng <strong>pointer to pointer</strong> để quản lý vùng nhớ được cấp phát trên <strong>Heap</strong> cho mảng một chiều chứa các con trỏ.</p>\n<p></p><pre><code class=\"lang-auto\">int *p1 = NULL;\nint *p2 = NULL;\nint *p3 = NULL;\n<p>int *<em>p_to_p = new int</em>[3];\np_to_p[0] = p1;\np_to_p[1] = p2;\np_to_p[2] = p3;</p>\n<p>delete[] p_to_p;</code></pre></p>\n<p>Tương tự như con trỏ kiểu (int *) dùng để trỏ đến mảng các phần tử kiểu int, con trỏ kiểu (int **) dùng để trỏ đến mảng các phần tử kiểu (int *).</p>\n<h3>2D dynamically allocated array</h3>\n<p>Một cách sử dụng khác của <strong>Pointer to pointer</strong> là dùng để quản lý mảng hai chiều được cấp phát trên Heap.</p>\n<p>Với mảng hai chiều cấp phát trên <strong>Stack</strong>, chúng ta chỉ cần khai báo như sau:</p>\n<p></p><pre><code class=\"lang-auto\">int arr2D[5][10];</code></pre>\n<p>Nhưng với mảng hai chiều cấp phát trên <strong>Heap</strong> sẽ rắc rối hơn.</p>\n<p>Chúng ta biết rằng, mảng hai chiều là một tập hợp của các mảng một chiều có cùng kích thước. Chúng ta cũng đã biết cách cấp phát vùng nhớ cho mảng một chiều trên <strong>Heap</strong> bằng cách dùng toán tử <strong>new</strong> đi kèm với toán tử [ ]. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">int *arr1 = new int[10];\nint *arr2 = new int[10];\n//........</code></pre>\n<p>Như vậy, một mảng các con trỏ được dùng để quản lý tập hợp các mảng một chiều này sẽ tạo thành mảng 2 chiều. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">int *pToArrPtr[3];\n<p>for(int i = 0; i &#x3C; 3; i++)\n{\npToArrPtr[i] = new int[5];\n}</code></pre></p>\n<p>Kết quả của đoạn chương trình này cho chúng ta một vùng nhớ có kích thước (3 x 5) phần tử kiểu int. Và chúng ta có thể truy xuất từng giá trị thông qua con trỏ <strong>pToArrPtr</strong>:</p>\n<p></p><pre><code class=\"lang-auto\">for(int i = 0; i &lt; 3; i++)\n{\n\tfor(int j = 0; j &lt; 5; j++)\n\t{\n\t\tcin &gt;&gt; pToArrPtr[i][j];\n\t}\n}\n<p>cout &#x3C;&#x3C; \"--------------------------------\" &#x3C;&#x3C; endl;</p>\n<p>for(int i = 0; i &#x3C; 3; i++)\n{\nfor(int j = 0; j &#x3C; 5; j++)\n{\ncout &#x3C;&#x3C; pToArrPtr<a href=\"\">i</a> &#x3C;&#x3C; \" \";\n}\ncout &#x3C;&#x3C; endl;\n}</code></pre></p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-7-con-tro-tro-den-con-tro/2.png?raw=true\" width=\"579\" height=\"384\"></p>\n<p>Kết quả hoàn toàn giống với mảng hai chiều thông thường. Nhưng lúc này, 3 con trỏ pToArrPtr[0] và pToArrPtr[1] và pToArrPtr[2] vẫn là biến được cấp phát trên <strong>Stack</strong>. Để chuyển những con trỏ quản lý các mảng một chiều con này sang <strong>Heap</strong>, chúng ta cần sử dụng <strong>Pointer to pointer</strong>. Dưới đây là toàn bộ chương trình mẫu cho việc cấp phát và giải phóng vùng nhớ 2 chiều hoạt động tương tự như mảng hai chiều thông thường:</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\nusing namespace std;\n<p>int main()\t{</p>\n<pre><code>int **pToArrPtr;\n\n//Cấp phát vùng nhớ cho 3 con trỏ kiểu (int *)\npToArrPtr = new int*[3];\n\n//Mỗi con trỏ kiểu (int *) sẽ quản lý 5 phần tử kiểu int\nfor (int i = 0; i &#x26;lt; 3; i++)\n{\n    pToArrPtr[i] = new int[5];\n}\n\nfor (int i = 0; i &#x26;lt; 3; i++)\n{\n    for (int j = 0; j &#x26;lt; 5; j++)\n    {\n        cin &#x26;gt;&#x26;gt; pToArrPtr[i][j];\n    }\n}\n\ncout &#x26;lt;&#x26;lt; \"--------------------------------\" &#x26;lt;&#x26;lt; endl;\n\nfor (int i = 0; i &#x26;lt; 3; i++)\n{\n    for (int j = 0; j &#x26;lt; 5; j++)\n    {\n        cout &#x26;lt;&#x26;lt; pToArrPtr[i][j] &#x26;lt;&#x26;lt; \" \";\n    }\n    cout &#x26;lt;&#x26;lt; endl;\n}\n\n//Giải phóng vùng nhớ cho từng dãy vùng nhớ mà 3 con trỏ đang quản lý\nfor (int i = 0; i &#x26;lt; 3; i++)\n{\n    delete[] pToArrPtr[i];\n}\n\n//Giải phóng cho 3 biến con trỏ chịu sự quản lý của pToArrPtr\ndelete[] pToArrPtr;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<h3>Pointer to pointer to pointer to ...</h3>\n<p>Chúng ta có thể khai báo những con trỏ có dạng như sau:</p>\n<p></p><pre><code class=\"lang-auto\">int ***ptrX3;\nint ******ptrX6;</code></pre>\n<p>Tuy nhiên, việc thao tác với những con trỏ như thế này khá phức tạp và rất ít gặp trong thực tế nên mình không đề cập trong bài học này.</p>\n<hr>\n<h3>Tổng kết</h3>\n<p><strong>Pointer to pointer</strong> là một phần nâng cao của con trỏ. Việc thao tác cấp phát và giải phóng vùng nhớ khá phức tạp. Do đó, các bạn mới học có thể hoàn toàn bỏ qua bài học này. Mình cũng khuyên các bạn nên tránh sử dụng <strong>Pointer to pointer</strong> trừ khi không còn giải pháp nào thay thế.</p>\n<hr>\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>\n<p><strong><a href=\"http://www.daynhauhoc.com\">www.daynhauhoc.com</a></strong></p>\n","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/data/9e711.json"}