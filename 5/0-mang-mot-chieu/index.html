<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/phenomic.browser.89bd9961942b8ff9392f.css" /><meta data-react-helmet="true" property="og:site_name" content="dnh-cpp"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="5.0 Mảng một chiều"/><meta data-react-helmet="true" property="og:url" content="/5/0-mang-mot-chieu/"/><meta data-react-helmet="true" property="og:description" content="//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &amp;lt;&amp;lt; &quot;Number of elements = &quot; &amp;lt;&amp;lt; num_of_elements &amp;lt…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="5.0 Mảng một chiều"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &amp;lt;&amp;lt; &quot;Number of elements = &quot; &amp;lt;&amp;lt; num_of_elements &amp;lt…"/><meta data-react-helmet="true" name="description" content="//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &amp;lt;&amp;lt; &quot;Number of elements = &quot; &amp;lt;&amp;lt; num_of_elements &amp;lt…"/><title data-react-helmet="true">5.0 Mảng một chiều</title></head><body><div id="phenomic"><div class="_2lE56" data-reactroot="" data-reactid="1" data-react-checksum="654616589"><!-- react-empty: 2 --><div class="_1Ih7a _1GU64" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><div class="_1G2C6 _3fTO1" data-reactid="7"><div class="aCd9j" data-reactid="8"><a href="https://github.com/daynhauhoc/cppcoban" target="_blank" data-hint="Fork on Github" class="hint--bottom-left _2dICi" data-reactid="9"><span class="SVGInline" data-reactid="10"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span></a><a href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank" data-hint="Share on Facebook" class="hint--bottom-left _2dICi" data-reactid="11"><span class="SVGInline" data-reactid="12"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="430.113px" height="430.114px" viewBox="0 0 430.113 430.114" style="enable-background:new 0 0 430.113 430.114;"
	 xml:space="preserve">
<g>
	<path id="Facebook" d="M158.081,83.3c0,10.839,0,59.218,0,59.218h-43.385v72.412h43.385v215.183h89.122V214.936h59.805
		c0,0,5.601-34.721,8.316-72.685c-7.784,0-67.784,0-67.784,0s0-42.127,0-49.511c0-7.4,9.717-17.354,19.321-17.354
		c9.586,0,29.818,0,48.557,0c0-9.859,0-43.924,0-75.385c-25.016,0-53.476,0-66.021,0C155.878-0.004,158.081,72.48,158.081,83.3z"/>
</g>
</svg></span></a></div></div><article class="markdown-body" data-reactid="13"><h1 data-reactid="14">5.0 Mảng một chiều</h1><div data-reactid="15"><div class="phenomic-BodyContainer" data-reactid="16">
<h4>Chào tất cả các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>

<p>Tiếp tục với bài học ngày hôm nay, chúng ta sẽ cùng tìm hiểu về một cách tổ chức dữ liệu cơ bản trong thiết bị lưu trữ tạm thời của máy tính giúp khắc phục một số nhược điểm của việc sử dụng các biến thông thường.</p>

<h5>Đặt vấn đề</h5>

<p>Giảng viên cần tìm ra điểm số cao nhất của bài kiểm tra môn lập trình cơ sở. Giả sử lớp học có 30 sinh viên có số thứ tự 1 đến 30. </p>

<p>Công việc của những lập trình viên chúng ta là giúp giảng viên này chỉ ra số thứ tự của sinh viên có điểm kiểm tra cao nhất, và điểm cao nhất đó là bao nhiêu bằng cách viết chương trình ngôn ngữ C++ trên máy tính để tiết kiệm thời gian suy nghĩ.</p>

<h5>Tìm hướng giải quyết</h5>

<p>Với yêu cầu như trên, chúng ta cần 30 biến để lưu lại điểm của 30 sinh viên.</p>

<pre><code>int32_t score_of_student1;
int32_t score_of_student2;
//....
int32_t score_of_student30;</code></pre>

<p>Vậy là chúng ta cần tới 30 dòng lệnh khai báo 30 biến, chưa kể mất thời gian viết thêm 30 dòng lệnh nhập dữ liệu vào là điểm của từng sinh viên, sau đó chúng ta còn phải tìm điểm cao nhất. </p>

<p>Một vấn đề khác nãy sinh: Sau khi tìm ra điểm số cao nhất từ 30 biến trên, làm thế nào chúng ta biết điểm số đó là của sinh viên có số thứ tự nào trong khi 30 biến này được cấp phát hoàn toàn tách biệt nhau (không theo 1 thứ tự nhất định)?</p>

<p>Rất may mắn cho chúng ta khi ngôn ngữ C/C++ đưa ra cho chúng ta một khái niệm về tổ chức dữ liệu liên tiếp nhau trên thiết bị cung cấp bộ nhớ. Chúng ta có thể gọi là <strong>Mảng một chiều (Array)</strong>.</p>

<h2></h2>

<h3>Mảng một chiều (Array)</h3>

<p>Mảng một chiều (<strong>array</strong>) là một dãy các phần tử có cùng kiểu dữ liệu được đặt liên tiếp nhau trong một vùng nhớ, chúng ta có thể ngay lập tức truy xuất đến một phần tử của dãy đó thông qua chỉ số của mỗi phần tử.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true" class="lightbox" title="0.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true" width="690" height="287"><div class="meta">
<span class="filename">0.png?raw=true</span><span class="informations">915x381</span><span class="expand"></span>
</div></a></div></p>

<p>Như hình trên, giả sử mình khai báo mảng một chiều có 3 phần tử kiểu <strong>int32_t</strong>, mỗi phần tử sẽ có kích thước <strong>4 bytes</strong>. </p>

<p>Mình lấy ví dụ hệ điều hành tìm thấy vùng nhớ trống đủ chổ chứa 3 phần tử của mảng tại địa chỉ <strong>108</strong>, thì phần tử đầu tiên a1 sẽ có địa chỉ là địa chỉ ô nhớ đầu tiên mà hệ điều hành cấp phát (là <strong>108</strong>). Khi đó, phần tử thứ 2 sẽ có địa chỉ là địa chỉ của phần tử thứ nhất cộng thêm 4 (4 là kích thước kiểu dữ liệu <strong>int32_t</strong>), tương tự cho phần tử thứ 3.</p>

<p>Với kiểu tổ chức dữ liệu này, chúng ta chỉ cần quan tâm đến 2 điều:</p>

<ul>
<li>Địa chỉ ô nhớ đầu tiên trong mảng.</li>
<li>Số phần tử của mảng.</li>
</ul>

<p>Từ đó, chúng ta có thể truy xuất đến toàn bộ phần tử trong mảng.</p>

<h3>Khai báo mảng một chiều</h3>

<p>Chúng ta có nhiều cách để khai báo mảng một chiều khác nhau:</p>

<ul><li>Khai báo nhưng không khởi tạo các phần tử:</li></ul>

<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[&lt;number_of_elements&gt;];</code></p>

<p>Với cách khai báo này, chúng ta cần ghi rõ cho <strong>compiler</strong> biết số lượng phần tử mà bạn cần sử dụng đặt trong cặp dấu ngoặc vuông. Ví dụ:</p>

<pre><code>int32_t age_of_students[30];</code></pre>

<p>Mình vừa tạo ra một mảng dữ liệu kiểu <strong>int32_t</strong> để lưu trữ số tuổi của 30 sinh viên trong 1 lớp học.</p>

<p>Vì mình chưa khởi tạo giá trị cụ thể cho 30 phần tử trong mảng, nên khi truy xuất đến giá trị của từng phần tử, chúng ta có thể nhận được giá trị khởi tạo mặc định của kiểu int32_t là 0 hoặc giá trị rác (tùy vào <strong>compiler</strong>).</p>

<ul><li>Khai báo và khởi tạo giá trị cho mỗi phần tử:</li></ul>

<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[] = { &lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; };</code></p>

<p>Với cách khai báo này, chúng ta không cần thiết xác định trước số phần tử của mảng. Compiler sẽ xác định số phần tử thông qua số lượng giá trị mà bạn khởi tạo.</p>

<pre><code>char my_string[] = { 'H', 'e', 'l', 'l', 'o', '\0' };</code></pre>

<p>Mình vừa khai báo một mảng phần tử với kiểu kí tự (Chúng ta sẽ đi sâu hơn về chuỗi kí tự trong những bài học sau), <strong>compiler</strong> nhìn vào số lượng kí tự mình khởi tạo và cấp phát 6 ô nhớ liên tục nhau trên vùng nhớ còn trống.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true" class="lightbox" title="1.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true" width="690" height="223"><div class="meta">
<span class="filename">1.png?raw=true</span><span class="informations">912x296</span><span class="expand"></span>
</div></a></div></p>

<p><em>Với kiểu kí tự, mỗi phần tử chỉ chiếm 1 byte, nên chúng ta có 6 bytes liên tiếp nhau để chứa được chuỗi kí tự trên.</em></p>

<h3>Truy xuất đến các phần tử trong mảng một chiều</h3>

<p>Sau khi biết cách khai báo mảng một chiều (<strong>array</strong>), điều tiếp theo chúng ta cần quan tâm là làm thế nào để truy xuất đến một phần tử trong mảng.</p>

<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng. Phần tử đầu tiên của mảng mang chỉ số <strong>0</strong>, phần tử cuối cùng của mảng có <strong>N</strong> phần tử sẽ có chỉ số <strong>(N - 1)</strong>.</p></blockquote>

<p>Cú pháp truy xuất phần tử trong mảng một chiều:</p>

<p><code>&lt;name_of_array&gt;[index];</code></p>

<p>Trong đó, <strong>index</strong> là một số nguyên đại diện cho chỉ số của phần tử trong mảng một chiều.</p>

<p>Ví dụ với một mảng một chiều kiểu int32_t có 5 phần tử được khai báo như sau:</p>

<pre><code>int32_t values[] = { 2, 4, 6, 8, 10 };</code></pre>

<p>Khi đó, các phần tử trong mảng lần lượt là:</p>

<pre><code>values[0]; //2
values[1]; //4
values[2]; //6
values[3]; //8
values[4]; //10</code></pre>

<h5>Giải thích cho việc tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0:</h5>

<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng.</p></blockquote>

<p>Sau khi khai báo mảng một chiều, địa chỉ của mảng ứng với địa chỉ của phần tử đầu tiên trong mảng. Vị trí của các phần tử sẽ được tính dựa trên công thức:</p>

<p><code>index = (address_of_current_element - address_of_the_first_element) / sizeof(data_type);</code></p>

<p>Lấy lại ví dụ mảng có 3 phần tử kiểu int32_t như trong mục <strong>Mảng một chiều (Array)</strong></p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true" class="lightbox" title="0.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true" width="690" height="287"><div class="meta">
<span class="filename">0.png?raw=true</span><span class="informations">915x381</span><span class="expand"></span>
</div></a></div></p>

<p>Cho rằng địa chỉ của mảng <strong>a</strong> (cũng là địa chỉ của phần tử a1) là <strong>108</strong>. Vậy chỉ số của phần tử đầu tiên a1 là:</p>

<p><code>index_of_a1 = (address_of_a1 - address_of_the_first_element) / sizeof(int32_t);</code></p>

<p><code>index_of_a1 = (108 - 108) / 4 = 0;</code></p>

<p>Như vậy, phần tử đầu tiên của mảng có chỉ số là <strong>0</strong>.</p>

<p>Đây chỉ là phần mình làm rõ cho các bạn tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0 và kết thúc tại <code>(số_phần_tử - 1)</code>. Các bạn không cần quan tâm đến việc tính toán chỉ số của mỗi phần tử mà <strong>compiler</strong> sẽ làm giúp bạn.</p>

<h5>In ra giá trị của tất cả phần tử trong mảng</h5>

<p>Để quản lý mảng một chiều, chúng ta cần biết:</p>

<ul>
<li>Địa chỉ phần tử đầu tiên của mảng. (Có thể có được thông qua <code>&lt;array_name&gt;[0]</code>)</li>
<li>Số lượng phần tử của mảng.</li>
</ul>

<p>Mình sẽ thực hiện một phương pháp tổng quát để lấy ra số lượng phần tử của mảng:</p>

<p><code>&lt;number_of_elements&gt; = sizeof(&lt;name_of_array&gt;) / sizeof(&lt;type_of_array&gt;);</code></p>

<p>Chúng ta sử dụng toán tử <strong>sizeof</strong>, truyền vào tên của mảng chúng ta sẽ nhận được giá trị là tổng kích thước bộ nhớ sử dụng cho mảng, chia cho kích thước của một phần tử của mảng chúng ta sẽ có được số lượng phần tử. Ví dụ:</p>

<pre><code>double d_values[] = { 2.08, 1.32, 6, 4.1, 12, 999.99 };
int32_t num_of_elements = sizeof(d_values) / sizeof(double);

//another way
num_of_elements = sizeof(d_values) / sizeof(d_values[0]);

cout &lt;&lt; "Number of elements = " &lt;&lt; num_of_elements &lt;&lt; endl;</code></pre>

<p>Kết quả chương trình sẽ cho ta thấy mảng có 6 phần tử:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/2.png?raw=true" width="670" height="339"></p>

<p>Như cách thông thường, chúng ta thường định nghĩa trước số lượng phần tử tối đa mà mảng một chiều có thể chứa như sau:</p>

<pre><code>#define ARRAY_SIZE 100

//........

float f_values[ARRAY_SIZE];</code></pre>

<p>Lúc này, chúng ta chỉ cần sử dụng <code>ARRAY_SIZE</code> như là số lượng phần tử của mảng. Nhưng cách này có thể là hao tốn bộ nhớ khi số lượng phần tử thực sự cần sử dụng không đạt đến con số <code>ARRAY_SIZE</code>. Vì thế, mình thường tính số phần tử của mảng theo cách tổng quát mà mình trình bày ở trên.</p>

<h5>Điều gì xảy ra nếu chúng ta truy xuất mảng bằng chỉ số lớn hơn số lượng phần tử?</h5>

<p>Các bạn thử chạy đoạn chương trình sau:</p>

<pre><code>int32_t arr[] = { 1, 2, 3, 4, 5 }; //create an array with 5 elements
cout &lt;&lt; arr[100] &lt;&lt; endl;</code></pre>

<p>Ở lần chạy đầu tiên của đoạn chương trình trên, máy mình cho ra kết quả:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/3.png?raw=true" width="668" height="337"></p>

<p>Thử chạy lại chương trình nhiều lần khác nhau, các bạn sẽ thấy được nhiều giá trị khác nhau. Những giá trị này ở đâu ra?</p>

<p>Đó chính là những giá trị thuộc vùng nhớ mà chương trình khác đang quản lý.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true" class="lightbox" title="4.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true" width="690" height="274"><div class="meta">
<span class="filename">4.png?raw=true</span><span class="informations">968x385</span><span class="expand"></span>
</div></a></div></p>

<p>Có thể sau khi các chương trình khác sử dụng vùng nhớ đó và trả lại cho hệ điều hành quản lý, giá trị của ô nhớ vẫn còn giữ nguyên, nên khi truy cập mảng với chỉ số vượt quá số lượng phần tử tối đa, chúng ta nhận được những giá trị không có ý nghĩa.</p>

<p>Trường hợp xấu hơn có thể xảy ra là khi các chương trình khác đang sử dụng vùng nhớ mà bạn truy cập đến, Visual studio sẽ đưa ra cảnh báo về việc xung đột vùng nhớ và cho dừng chương trình của bạn.</p>

<p><img src="https://raw.githubusercontent.com/nguyenchiemminhvu/CPP-Tutorial/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/5.png" width="558" height="314"></p>

<p>Vì thế việc quản lý số lượng phần tử của mảng là rất quan trọng.</p>

<h3>Nhập dữ liệu cho mảng một chiều (Array input)</h3>

<p>Giả sử chúng ta có mảng một chiều dùng để chứa 10 số nguyên (có chỉ số từ 0 đến 9). Để nhập dữ liệu cho từng phần tử trong mảng này, chúng ta có thể sử dụng đối tượng <strong>cin</strong> trong thư viện <strong>iostream</strong> mà các bạn đã được học.</p>

<p><code>cin &gt;&gt; &lt;name_of_array&gt;[index];</code></p>

<p>Trong đó, <strong>index</strong> là chỉ số của phần tử của mảng mà chúng ta cần nhập giá trị từ bàn phím và đưa vào phần tử.</p>

<pre><code>int32_t arr[10];
for(int32_t index = 0; index &lt;= 9; index++)	{
	cin &gt;&gt; arr[index];
}</code></pre>

<p>Mình vừa sử dụng vòng lặp <strong>for</strong> (vì mình biết được số lượng phần tử của mảng nên mình biết cần lặp bao nhiêu lần), trong vòng lặp <strong>for</strong> này, mình sử dụng biến <strong>index</strong> và cho nó di chuyển từ giá trị <strong>0 đến 9</strong> tương ứng với từng chỉ số của các phần tử trong mảng. Với mỗi giá trị <strong>index</strong> được gán, mình thực hiện nhập dữ liệu từ bàn phím bằng đối tượng <strong>cin</strong> cho phần tử <strong>arr[index]</strong>.</p>

<h5>Một cách tổng quát hơn để nhập dữ liệu cho mảng một chiều</h5>

<p>Ở ví dụ trên, mình cho mảng số nguyên có số lượng phần tử cố định là 10. Đối với mảng một chiều có số lượng phần tử khác nhau thì ta làm thế nào?</p>

<p>Việc đầu tiên chúng ta cần làm là tìm ra số lượng phần tử của mảng. Ví dụ:</p>

<pre><code>int32_t i_values[100];
int32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);

for(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)	{
	cin &gt;&gt; i_values[index];	
}</code></pre>

<p>Với cách này, chúng ta có thể không cần quan tâm đến số lượng phần tử hiện tại của mảng, mà mình để <strong>compiler</strong> tính giúp mình.</p>

<p>Mình cho biến index chạy từ 0 đến (num_of_elements - 1) vì như mình đã nói ở trên, mảng một chiều có chỉ số bắt đầu từ 0 đến <code>số_lượng_phần_tử</code> trừ đi 1.</p>

<h5>Đưa ra nhắc nhở khi nhập dữ liệu cho mảng</h5>

<p>Chúng ta nên thông báo cho người dùng biết là chúng ta đang nhập dữ liệu cho phần tử nào trong mảng.</p>

<pre><code>int32_t i_values[100];
int32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);

for(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)	{
	cout &lt;&lt; "Value of element " &lt;&lt; index &lt;&lt; ": ";
	cin &gt;&gt; i_values[index];	
}</code></pre>

<p>Như vậy, người dùng sẽ tránh được việc nhập nhầm thứ tự dữ liệu cho các phần tử trong mảng.</p>

<p>Ngoài việc dùng đối tượng cin, chúng ta cũng có thể gán trực tiếp giá trị cho các phần tử trong mảng thông qua toán tử gán.</p>

<pre><code>int32_t i_values[100];
int32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);

for(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)	{
	i_values[index] = index + 1;
}</code></pre>

<h5>Nhập dữ liệu cho ô nhớ có chỉ số vượt quá số lượng phần tử</h5>

<p>Cũng tương tự như việc bạn truy xuất đến phần tử với chỉ số vượt ngoài tầm số lượng phần tử trong mảng, Visual studio sẽ đưa ra cảnh báo xung đột vùng nhớ và dừng chương trình.</p>

<h2></h2>

<h3>Tổng kết</h3>

<p>Cùng nhìn lại vấn đề mình đặt ra ngay từ đầu bài học, mảng một chiều đã giúp chúng ta tiết kiệm thời gian hơn khi mà chỉ với 1 dòng lệnh khai báo mảng một chiều, chúng ta có thể quản lý 30 vùng nhớ liên tiếp nhau dùng để lưu trữ điểm của cả 30 sinh viên. Chúng ta cũng có thể biết được điểm số nào là của sinh viên nào thông qua chỉ số của mảng đó.</p>

<p>Mảng một chiều đã khắc phục nhiều nhược điểm của việc khai báo các biến đơn lẻ. Tuy nhiên, nó cũng có một số nhược điểm riêng như việc dư thừa vùng nhớ khi không dùng hết số lượng ô nhớ đã cấp phát, hoặc số lượng phần tử được yêu cầu quá lớn nên hệ điều hành không đủ khả năng cấp phát. Chúng ta sẽ tìm cách giải quyết những vấn đề này trong những bài học sau.</p>

<h3>Bài tập cơ bản</h3>

<p>Với yêu cầu đặt ra ban đầu, giảng viên cần biết điểm số cao nhất của 30 sinh viên trong lớp, đồng thời muốn biết điểm cao nhất là của sinh viên có số thứ tự bao nhiêu. Bạn hãy sử dụng mảng 1 chiều để giải quyết vấn đề này. (Điểm của sinh viên được nhập từ bàn phím)</p>

<hr>

<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>

<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>

<p><a title="DayNhauHoc" class="onebox" target="_blank">www.daynhauhoc.com</a></p>

<hr>

<h3>Link Videos khóa học</h3>

<p><a href="https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview" class="onebox" target="_blank" rel="nofollow">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>
</div></div></article></div></div></div><div class="_30zqN _1M-6l _7YJ7M" data-reactid="17"><div style="position:relative;overflow:hidden;width:100%;height:100%;" data-reactid="18"><div style="position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;-webkit-overflow-scrolling:touch;margin-right:0;margin-bottom:0;" data-reactid="19"><ul style="list-style:none;background-color:transparent;margin:0;padding:0;color:#242a31;font-family:lucida grande ,tahoma,verdana,arial,sans-serif;font-size:14px;" data-reactid="20"><li style="position:relative;" data-reactid="21"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="22"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="23"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="24"><svg height="14" width="14" data-reactid="25"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="26"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="27"><div style="line-height:24px;vertical-align:middle;font-size:1.5em;font-weight:300;font-family:Source Sans Pro,sans-serif;margin-bottom:1em;" data-reactid="28">Khóa học C++</div></div></div><span data-reactid="29"><ul style="list-style:none;padding-left:19px;" data-reactid="30"><li style="position:relative;" data-reactid="31"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="32"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="33"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="34"><svg height="14" width="14" data-reactid="35"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="36"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="37"><div style="line-height:24px;vertical-align:middle;" data-reactid="38">Giới thiệu tổng quan khóa học</div></div></div><span data-reactid="39"></span></li><li style="position:relative;" data-reactid="40"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="41"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="42"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="43"><svg height="14" width="14" data-reactid="44"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="45"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="46"><div style="line-height:24px;vertical-align:middle;" data-reactid="47">C++ cơ bản</div></div></div><span data-reactid="48"></span></li><li style="position:relative;" data-reactid="49"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="50"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="51"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="52"><svg height="14" width="14" data-reactid="53"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="54"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="55"><div style="line-height:24px;vertical-align:middle;" data-reactid="56">Cấu trúc rẽ nhánh</div></div></div><span data-reactid="57"></span></li><li style="position:relative;" data-reactid="58"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="59"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="60"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="61"><svg height="14" width="14" data-reactid="62"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="63"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="64"><div style="line-height:24px;vertical-align:middle;" data-reactid="65">Cấu trúc vòng lặp</div></div></div><span data-reactid="66"></span></li><li style="position:relative;" data-reactid="67"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="68"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="69"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="70"><svg height="14" width="14" data-reactid="71"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="72"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="73"><div style="line-height:24px;vertical-align:middle;" data-reactid="74">Nâng cao về biến, kiểu dữ liệu</div></div></div><span data-reactid="75"></span></li><li style="position:relative;" data-reactid="76"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="77"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="78"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="79"><svg height="14" width="14" data-reactid="80"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="81"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="82"><div style="line-height:24px;vertical-align:middle;" data-reactid="83">Kiểu dữ liệu mảng</div></div></div><span data-reactid="84"></span></li><li style="position:relative;" data-reactid="85"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="86"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="87"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="88"><svg height="14" width="14" data-reactid="89"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="90"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="91"><div style="line-height:24px;vertical-align:middle;" data-reactid="92">Kiểu chuỗi kí tự</div></div></div><span data-reactid="93"></span></li><li style="position:relative;" data-reactid="94"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="95"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="96"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="97"><svg height="14" width="14" data-reactid="98"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="99"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="100"><div style="line-height:24px;vertical-align:middle;" data-reactid="101">Cơ bản về Function</div></div></div><span data-reactid="102"></span></li><li style="position:relative;" data-reactid="103"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="104"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="105"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="106"><svg height="14" width="14" data-reactid="107"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="108"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="109"><div style="line-height:24px;vertical-align:middle;" data-reactid="110">Con trỏ</div></div></div><span data-reactid="111"></span></li><li style="position:relative;" data-reactid="112"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="113"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="114"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="115"><svg height="14" width="14" data-reactid="116"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="117"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="118"><div style="line-height:24px;vertical-align:middle;" data-reactid="119">Kiểu dữ liệu tự định nghĩa</div></div></div><span data-reactid="120"></span></li><li style="position:relative;" data-reactid="121"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="122"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="123"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="124"><svg height="14" width="14" data-reactid="125"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="126"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="127"><div style="line-height:24px;vertical-align:middle;" data-reactid="128">Nhập, xuất (Input &amp; Output)</div></div></div><span data-reactid="129"></span></li><li style="position:relative;" data-reactid="130"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="131"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="132"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="133"><svg height="14" width="14" data-reactid="134"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="135"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="136"><div style="line-height:24px;vertical-align:middle;" data-reactid="137">Một số thư viện thường dùng trong STL</div></div></div><span data-reactid="138"></span></li><li style="position:relative;" data-reactid="139"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="140"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="141"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="142"><svg height="14" width="14" data-reactid="143"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="144"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="145"><div style="line-height:24px;vertical-align:middle;" data-reactid="146">Auto pointer</div></div></div><span data-reactid="147"></span></li><li style="position:relative;" data-reactid="148"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="149"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="150"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="151"><svg height="14" width="14" data-reactid="152"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="153"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="154"><div style="line-height:24px;vertical-align:middle;" data-reactid="155">Quản lý mã nguồn</div></div></div><span data-reactid="156"></span></li><li style="position:relative;" data-reactid="157"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="158"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="159"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="160"><svg height="14" width="14" data-reactid="161"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="162"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="163"><div style="line-height:24px;vertical-align:middle;" data-reactid="164">Một số feature trong C++11, C++14</div></div></div><span data-reactid="165"></span></li></ul></span></li></ul></div><div style="position:absolute;height:6px;display:none;right:2px;bottom:2px;left:2px;border-radius:3px;" data-reactid="166"><div style="position:relative;display:block;height:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="167"></div></div><div style="position:absolute;width:6px;display:none;right:2px;bottom:2px;top:2px;border-radius:3px;" data-reactid="168"><div style="position:relative;display:block;width:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="169"></div></div></div></div><div class="_3eRtW _1tTpi" data-reactid="170"><span class="SVGInline" data-reactid="171"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 396.667 396.667" style="enable-background:new 0 0 396.667 396.667;" xml:space="preserve">
<g>
	<g>
		<path d="M17,87.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17C0,80.183,7.65,87.833,17,87.833z"/>
		<path d="M17,215.333h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,215.333,17,215.333z"/>
		<path d="M17,342.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,342.833,17,342.833z"/>
	</g>
</g>
</svg></span></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"title":"Cài đặt Code::blocks để lập trình C++ trên Ubuntu/Linux","route":"0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux","description":"int main() {   std::cout &lt;&lt; \"Hello World!\"; }","__filename":"generated/24563.md","__url":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/","__resourceUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html","__dataUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html.d7146b8f6b06f293bfd7d7072595786f.json"},{"title":"Cài đặt Xcode để lập trình C++ trên Mac OS X","route":"0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x","description":"int main() {     std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;     return 0; }","__filename":"generated/24606.md","__url":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/","__resourceUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html","__dataUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html.b267f6bba27c47a6fd8837792aa9ed05.json"},{"title":"Cài đặt Visual Studio 2015 để lập trình C++ trên Windows","route":"0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows","description":"","__filename":"generated/24768.md","__url":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/","__resourceUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html","__dataUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html.acf989adbfe293778195699d01ad0f77.json"},{"title":"0.0 Giới thiệu về series tutorial","route":"0/0-gioi-thieu-ve-series-tutorial","description":"Tóm tắt về bản thân  Minh tên Lê Trần Đạt, 28 tuổi, là lập trình viên lập trình nhúng, ngoài làm việc mình thích dạy học online và viết. Tự…","__filename":"generated/29402.md","__url":"/0/0-gioi-thieu-ve-series-tutorial/","__resourceUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html","__dataUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html.b3a9c7a55cfe71fb06282d41eb35a19e.json"},{"title":"0.1 Giới thiệu về ngôn ngữ lập trình","route":"0/1-gioi-thieu-ve-ngon-ngu-lap-trinh","description":"","__filename":"generated/29425.md","__url":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/","__resourceUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html","__dataUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html.ee05b7a2f09ce56983fe6ecdb5e2cae1.json"},{"title":"0.2 Giới thiệu về ngôn ngữ lập trình C++","route":"0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c","description":"","__filename":"generated/29448.md","__url":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/","__resourceUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html","__dataUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html.eb8440bdc067f39ed5ed01dcb67ec011.json"},{"title":"0.3 Các công đoạn phát triển của một chương trình C++","route":"0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c","description":"","__filename":"generated/29449.md","__url":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/","__resourceUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html.985676c594c63a65a27c349d01aba1c2.json"},{"title":"0.4 Giới thiệu môi trường phát triển ứng dụng C++","route":"0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c","description":"","__filename":"generated/29503.md","__url":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/","__resourceUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html","__dataUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html.4d09242acbe8c00d559a65dfa4e010c8.json"},{"title":"1.0 Viết chương trình đầu tiên","route":"1/0-viet-chuong-trinh-dau-tien","description":"Các bạn sẽ thấy nhiều hàm main có cách khai báo khác nhau. Nhưng với việc bạn là người mới bắt đầu học…","__filename":"generated/29504.md","__url":"/1/0-viet-chuong-trinh-dau-tien/","__resourceUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html","__dataUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html.6d8bc2f6cad6284e8e2fd1bef2562ea3.json"},{"title":"1.1 Cấu trúc cơ bản của một chương trình C++","route":"1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c","description":"\\#include &lt;iostream> using namespace std; int main()\t{ \t// We write some code inside main function. } } / We can put…","__filename":"generated/29527.md","__url":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/","__resourceUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html.1754c050053054d0d4962d6ed4069bcc.json"},{"title":"1.10 Độ ưu tiên của các toán tử","route":"1/10-do-uu-tien-cua-cac-toan-tu","description":"","__filename":"generated/29574.md","__url":"/1/10-do-uu-tien-cua-cac-toan-tu/","__resourceUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html","__dataUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html.2ed2467f55ba1f9faebf54445fa0e702.json"},{"title":"1.2 Lệnh, khối lệnh, từ khóa","route":"1/2-lenh-khoi-lenh-tu-khoa","description":"Những dòng lệnh bên trong thân hàm main. (Có thể có hoặc không) Những dòng comment. (Có thể có hoặc không) Tích hợp thư viện và không gian…","__filename":"generated/29575.md","__url":"/1/2-lenh-khoi-lenh-tu-khoa/","__resourceUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html","__dataUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html.bf958184eaea47730791808e2dc576df.json"},{"title":"1.3 Sử dụng các lệnh liên quan đến xuất dữ liệu","route":"1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu","description":"","__filename":"generated/29796.md","__url":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/","__resourceUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html","__dataUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html.764e0a3a06f81e99ab53a9ab17e892f9.json"},{"title":"1.4 Biến và các kiểu dữ liệu trong C++","route":"1/4-bien-va-cac-kieu-du-lieu-trong-c","description":"float valueFloat = 5.394; // (2) Xin hệ điều hành thêm một vùng nhớ để chứa 1 số thực string myName = \"Minh Vu\"; // (3) Biến này chứa được…","__filename":"generated/29935.md","__url":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/","__resourceUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html","__dataUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html.dffc5fbfdf664d44b3b28b7905117ee5.json"},{"title":"1.5 Nhập và xuất dữ liệu","route":"1/5-nhap-va-xuat-du-lieu","description":"","__filename":"generated/29936.md","__url":"/1/5-nhap-va-xuat-du-lieu/","__resourceUrl":"/1/5-nhap-va-xuat-du-lieu/index.html","__dataUrl":"/1/5-nhap-va-xuat-du-lieu/index.html.c56c9c3f92a8e8db1438ddde847a2a16.json"},{"title":"1.6 Hằng số","route":"1/6-hang-so","description":"","__filename":"generated/29938.md","__url":"/1/6-hang-so/","__resourceUrl":"/1/6-hang-so/index.html","__dataUrl":"/1/6-hang-so/index.html.a053963fb53e3188dd8ab0c9dac43085.json"},{"title":"1.7 Phạm vi của biến","route":"1/7-pham-vi-cua-bien","description":"int value = 1; int main()\t{ }","__filename":"generated/29939.md","__url":"/1/7-pham-vi-cua-bien/","__resourceUrl":"/1/7-pham-vi-cua-bien/index.html","__dataUrl":"/1/7-pham-vi-cua-bien/index.html.64607a2e78fc6b0159cfb3975ff151d6.json"},{"title":"1.8 Các phép toán cơ bản","route":"1/8-cac-phep-toan-co-ban","description":"int another_variable = 3; variable = another_variable \\* 2; variable = variable + 1; //tăng giá trị biến variable lên…","__filename":"generated/29944.md","__url":"/1/8-cac-phep-toan-co-ban/","__resourceUrl":"/1/8-cac-phep-toan-co-ban/index.html","__dataUrl":"/1/8-cac-phep-toan-co-ban/index.html.66e87835a401bc447f8384e79b564131.json"},{"title":"1.9 Toán tử tăng giảm","route":"1/9-toan-tu-tang-giam","description":"","__filename":"generated/29945.md","__url":"/1/9-toan-tu-tang-giam/","__resourceUrl":"/1/9-toan-tu-tang-giam/index.html","__dataUrl":"/1/9-toan-tu-tang-giam/index.html.abef97628c0b0b73bcc4d77d8d04b434.json"},{"title":"2.0 Boolean","route":"2/0-boolean","description":"int a = 2, b = 4; a \\* 3 != b; //đúng int main() { \tcout &lt;&lt; true &lt;&lt; endl; \tcout &lt;&lt; false &lt;&lt; endl; } int main…","__filename":"generated/29992.md","__url":"/2/0-boolean/","__resourceUrl":"/2/0-boolean/index.html","__dataUrl":"/2/0-boolean/index.html.68ed7d7b73e2f995c30477ffd2450120.json"},{"title":"2.1 Giới thiệu một số cấu trúc điều khiển","route":"2/1-gioi-thieu-mot-so-cau-truc-dieu-khien","description":"int main() { \tcout &lt;&lt; \"This line is printed out.\" &lt;&lt; endl; \texit(-1); //Terminate and return -1 to operating system.  \tcout &lt…","__filename":"generated/30007.md","__url":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/","__resourceUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html","__dataUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html.f922a5691cd782f11d83854853313a15.json"},{"title":"2.2 if statements","route":"2/2-if-statements","description":"} } if(value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; } if (value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl…","__filename":"generated/30008.md","__url":"/2/2-if-statements/","__resourceUrl":"/2/2-if-statements/index.html","__dataUrl":"/2/2-if-statements/index.html.7b04da482f36108555912c4dc0604cc1.json"},{"title":"2.3 switch case statements","route":"2/3-switch-case-statements","description":"} }","__filename":"generated/30009.md","__url":"/2/3-switch-case-statements/","__resourceUrl":"/2/3-switch-case-statements/index.html","__dataUrl":"/2/3-switch-case-statements/index.html.9fe094b93c2d8db3141fd46d847d467c.json"},{"title":"3.0 Vòng lặp while","route":"3/0-vong-lap-while","description":"} while (score &lt; 4) { \tcount++; \tcout &lt;&lt; \"Learn C++ programming language...\" &lt;&lt; endl; \tcout &lt;&lt; \"Enter your final score…","__filename":"generated/30011.md","__url":"/3/0-vong-lap-while/","__resourceUrl":"/3/0-vong-lap-while/index.html","__dataUrl":"/3/0-vong-lap-while/index.html.8611da6a5d3acd3ba1b3db2bccd4ded2.json"},{"title":"3.1 Vòng lặp do-while","route":"3/1-vong-lap-do-while","description":"} const int ID = 123; const int password = 123456; int main() { \t//................. }","__filename":"generated/30012.md","__url":"/3/1-vong-lap-do-while/","__resourceUrl":"/3/1-vong-lap-do-while/index.html","__dataUrl":"/3/1-vong-lap-do-while/index.html.8118d8e5f576f351b305bd20ccff339a.json"},{"title":"3.2 Vòng lặp for","route":"3/2-vong-lap-for","description":"}","__filename":"generated/30013.md","__url":"/3/2-vong-lap-for/","__resourceUrl":"/3/2-vong-lap-for/index.html","__dataUrl":"/3/2-vong-lap-for/index.html.d9f9bf135a584e44a623c43dc2a1d4b7.json"},{"title":"3.3 từ khóa break và continue","route":"3/3-tu-khoa-break-va-continue","description":"} } }","__filename":"generated/30014.md","__url":"/3/3-tu-khoa-break-va-continue/","__resourceUrl":"/3/3-tu-khoa-break-va-continue/index.html","__dataUrl":"/3/3-tu-khoa-break-va-continue/index.html.3b5d42b0f50995d27f54e8f8be5a4cc0.json"},{"title":"4.0 Sử dụng thư viện cstdint","route":"4/0-su-dung-thu-vien-cstdint","description":"int main()\t{ } //in ra kết quả là giá trị lớn nhất của 5 số vừa nhập //in ra kết quả là giá trị nhỏ nhất của 5 số vừa nhập int main…","__filename":"generated/30016.md","__url":"/4/0-su-dung-thu-vien-cstdint/","__resourceUrl":"/4/0-su-dung-thu-vien-cstdint/index.html","__dataUrl":"/4/0-su-dung-thu-vien-cstdint/index.html.869678da0bbdefddf5a0857f8355c79b.json"},{"title":"4.1 Kiểu kí tự","route":"4/1-kieu-ki-tu","description":"//check if there is any character exist in stdin file object if (!cin.eof())\t{ \tcout &lt;&lt; \"There are some character more in stdin file…","__filename":"generated/30018.md","__url":"/4/1-kieu-ki-tu/","__resourceUrl":"/4/1-kieu-ki-tu/index.html","__dataUrl":"/4/1-kieu-ki-tu/index.html.9982f009ee563c9838c9470e7bccce0d.json"},{"title":"4.2 Ép kiểu dữ liệu","route":"4/2-ep-kieu-du-lieu","description":"","__filename":"generated/30019.md","__url":"/4/2-ep-kieu-du-lieu/","__resourceUrl":"/4/2-ep-kieu-du-lieu/index.html","__dataUrl":"/4/2-ep-kieu-du-lieu/index.html.9093a9b251652c3f0d9c518a05058b3c.json"},{"title":"4.3 auto và decltype","route":"4/3-auto-va-decltype","description":"// compare the type of n with type int32_t if (typeid(int32_t) == typeid(n)) \tcout &lt;&lt; \"n is an object of type int32_t\" &lt;&lt; endl…","__filename":"generated/30020.md","__url":"/4/3-auto-va-decltype/","__resourceUrl":"/4/3-auto-va-decltype/index.html","__dataUrl":"/4/3-auto-va-decltype/index.html.6492a2c327eec109328a4f36f875b5ec.json"},{"title":"4.4 Địa chỉ của biến","route":"4/4-dia-chi-cua-bien","description":"cout &lt;&lt; \"Value of var: \" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; \"Value of var_reference: \" &lt;&lt; var_reference &lt;&lt; endl…","__filename":"generated/30022.md","__url":"/4/4-dia-chi-cua-bien/","__resourceUrl":"/4/4-dia-chi-cua-bien/index.html","__dataUrl":"/4/4-dia-chi-cua-bien/index.html.ec3e9179d8d83f7637aea29c682e42c9.json"},{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt…","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.db023247931fdd0e22e4bdf7ad1c7ff1.json"},{"title":"5.1 Các thao tác cơ bản với mảng một chiều","route":"5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu","description":"int32_t arr[ARRAY_SIZE];\t int32_t arr_clone[ARRAY_SIZE]; } } int main() { \tchar ch_array\\[] = { 'L', 'e', 'T', 'r', 'a', 'n', 'D', 'a…","__filename":"generated/30082.md","__url":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/","__resourceUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html","__dataUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html.8a635c59a7efecc14b6166c240ef06ff.json"},{"title":"5.2 Thư viện array trong STL","route":"5/2-thu-vien-array-trong-stl","description":"//Access to all of elements of arr object for (int32_t index = 0; index &lt;= arr.size() - 1; index++) { \tcout &lt;&lt; arr[index] &lt;&lt…","__filename":"generated/30083.md","__url":"/5/2-thu-vien-array-trong-stl/","__resourceUrl":"/5/2-thu-vien-array-trong-stl/index.html","__dataUrl":"/5/2-thu-vien-array-trong-stl/index.html.4d2fcee9d1d839fa510361a92690a625.json"},{"title":"5.3 Mảng hai chiều","route":"5/3-mang-hai-chieu","description":"for(int row = 0; row &lt; 3; row++) { \tfor(int col = 0; col &lt; 4; col++) \t{ \t\tcout &lt;&lt; board[row][col] &lt;&lt; \" \"; \t} \tcout &lt;&lt…","__filename":"generated/30085.md","__url":"/5/3-mang-hai-chieu/","__resourceUrl":"/5/3-mang-hai-chieu/index.html","__dataUrl":"/5/3-mang-hai-chieu/index.html.b5c4d6bd648ebce96975afc0a540003c.json"},{"title":"5.4 Các thao tác cơ bản với mảng hai chiều","route":"5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu","description":"} }","__filename":"generated/30086.md","__url":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/","__resourceUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html","__dataUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html.6e869616a193f204da370ff6042afac3.json"},{"title":"6.0 Mảng kí tự","route":"6/0-mang-ki-tu","description":"cout &lt;&lt; \"Enter your full name: \"; cin >> full_name; cout &lt;&lt; \"Your full name is \" &lt;&lt; full_name &lt;&lt; endl; cout &lt…","__filename":"generated/30090.md","__url":"/6/0-mang-ki-tu/","__resourceUrl":"/6/0-mang-ki-tu/index.html","__dataUrl":"/6/0-mang-ki-tu/index.html.e00029e1f168f1d138caba46b0257e9f.json"},{"title":"6.1 Các thao tác cơ bản với mảng kí tự","route":"6/1-cac-thao-tac-co-ban-voi-mang-ki-tu","description":"memset(foo, '-', 7); cout &lt;&lt; foo &lt;&lt; endl; \\-------every programmer should know memset! strcpy(str_destination, str_source…","__filename":"generated/30091.md","__url":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/","__resourceUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html","__dataUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html.b7aa8fed8d72491d018cc1daa25b8509.json"},{"title":"6.2 Thư viện string trong C++","route":"6/2-thu-vien-string-trong-c","description":"//......... string my_string; string temp_string(\"What the hell is going on?\"); string one_more = temp_string; string it_just_began(temp…","__filename":"generated/30092.md","__url":"/6/2-thu-vien-string-trong-c/","__resourceUrl":"/6/2-thu-vien-string-trong-c/index.html","__dataUrl":"/6/2-thu-vien-string-trong-c/index.html.fa8f82230a15f56f06af44a5d465f939.json"},{"title":"7.0 Làm quen với khái niệm function","route":"7/0-lam-quen-voi-khai-niem-function","description":"if(strlen(str1) == strlen(str2))\t{ \t//do something } void introduce() { \tcout &lt;&lt; \"Hello!\" &lt;&lt; endl; \tcout &lt;&lt; \"I'm a…","__filename":"generated/30132.md","__url":"/7/0-lam-quen-voi-khai-niem-function/","__resourceUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html","__dataUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html.65f217e229d77ce8b2497175dceac24f.json"},{"title":"7.1 Thiết kế chương trình dựa trên khái niệm function","route":"7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function","description":"} } float subtraction(float value1, float value2) { \treturn value1 - value2; } float multiplication(float value1, float value2) { \treturn…","__filename":"generated/30133.md","__url":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/","__resourceUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html","__dataUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html.709c05b00b2bae84c7baad49de176dbd.json"},{"title":"7.2 Truyền đối số cho hàm là giá trị hoặc tham chiếu","route":"7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu","description":"} } int main() { \tint argument; \tcout &lt;&lt; \"Address of argument: \" &lt;&lt; &argument &lt;&lt; endl; \tprintAddressOfParameter(argument…","__filename":"generated/30319.md","__url":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html.9f6c74d5d714f90dd4eb8741c7848e47.json"},{"title":"7.3 Hàm trả về giá trị hoặc tham chiếu","route":"7/3-ham-tra-ve-gia-tri-hoac-tham-chieu","description":"// .............. // function call int result = doubleValue(10); // ................ // function call int & myRef = returnReference(); for…","__filename":"generated/30381.md","__url":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html.461ae9d757da250cc59984265501a866.json"},{"title":"7.4 Tham số mặc định, tham số hằng","route":"7/4-tham-so-mac-dinh-tham-so-hang","description":"int main() { \tstring non_const_msg = \"This is non-const message\"; \tconst string const_msg = \"This is const message\"; } int main() { }","__filename":"generated/30382.md","__url":"/7/4-tham-so-mac-dinh-tham-so-hang/","__resourceUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html","__dataUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html.9d8d265a84d637c3c05004f404728474.json"},{"title":"7.5 Function overloading","route":"7/5-function-overloading","description":"float addFloat(float f1, float f2) { \treturn f1 + f2; } float add(float f1, float f2) { \treturn f1 + f2; } print(0); print('a'); print…","__filename":"generated/30477.md","__url":"/7/5-function-overloading/","__resourceUrl":"/7/5-function-overloading/index.html","__dataUrl":"/7/5-function-overloading/index.html.2290b48f00a85929ef4aba00f5401e08.json"},{"title":"8.0 Con trỏ","route":"8/0-con-tr","description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt…","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.c96a1fa2938a6be431d4ca1446f891e1.json"},{"title":"8.1 Toán tử tăng, giảm dùng cho con trỏ","route":"8/1-toan-tu-tang-giam-dung-cho-con-tr","description":"cout &lt;&lt; \"Before decreased: \" &lt;&lt; ptr &lt;&lt; endl; ptr--; cout &lt;&lt; \" After decreased: \" &lt;&lt; ptr &lt;&lt; endl; cout…","__filename":"generated/30699.md","__url":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/","__resourceUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html","__dataUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html.b0629507a79bd1a3061af63f38b13ff9.json"},{"title":"8.2 Con trỏ và mảng một chiều","route":"8/2-con-tr-va-mang-mot-chieu","description":"//show address of the first element of arr cout &lt;&lt; &arr[0] &lt;&lt; endl; //show address of the first element of arr cout &lt;&lt…","__filename":"generated/30788.md","__url":"/8/2-con-tr-va-mang-mot-chieu/","__resourceUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html","__dataUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html.b5e8e82e62fce2b9e1353768b39948ca.json"},{"title":"8.3 Con trỏ và mảng kí tự","route":"8/3-con-tr-va-mang-ki-tu","description":"p_name[1] = 'E'; cout &lt;&lt; my_name &lt;&lt; endl; cout &lt;&lt; p_name &lt;&lt; endl; } \"Le Tran Dat\"[1] = 'E'; //this line will make…","__filename":"generated/30876.md","__url":"/8/3-con-tr-va-mang-ki-tu/","__resourceUrl":"/8/3-con-tr-va-mang-ki-tu/index.html","__dataUrl":"/8/3-con-tr-va-mang-ki-tu/index.html.5583c492247883ef973e567716a9ec31.json"},{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt…","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.eb83f8a3bbb96ccc9afb58a885bbae19.json"},{"title":"8.5 Con trỏ và hằng","route":"8/5-con-tr-va-hang","description":"int value1 = 5; ptr = &value1; int value2 = 10; ptr = &value2; &ptr = 10; //compile error int otherValue = 10; ptr = &otherValue…","__filename":"generated/31355.md","__url":"/8/5-con-tr-va-hang/","__resourceUrl":"/8/5-con-tr-va-hang/index.html","__dataUrl":"/8/5-con-tr-va-hang/index.html.db6a1713c09e060e1515fabd7a42c5d4.json"},{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int…","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.792da3c393bbac25881f92a268beee71.json"},{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue…","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.bc2b8ac23d5e828477e2e837d3519fd7.json"},{"title":"8.10 Phân loại các vùng nhớ (stack & heap ...)","route":"8/10-phan-loai-cac-vung-nho-stack-va-heap","description":"","__filename":"generated/32101.md","__url":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/","__resourceUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html","__dataUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html.ee65b1f85a502eb43fca51c20ed8fb57.json"},{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int…","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.6e1574bcefc94d2d2e3a4ef309681497.json"},{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i…","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/8/7-con-tr-tr-den-con-tr/index.html.d07a86154a6961984bd2566d041f6e1e.json"},{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl…","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.054dae5e872a1f2c75e3062bd577174a.json"},{"title":"9.0 Kiểu liệt kê (enum)","route":"9/0-kieu-liet-ke-enum","description":"enum Color { \tRED, \tGREEN, \tBLUE, \tWHITE }; enum Animal { \tCAT, \tDOG, \tHORSE, \tMONKEY, \tCHICKEN }; } int iValue = LETTER_A; cout &lt;&lt…","__filename":"generated/32760.md","__url":"/9/0-kieu-liet-ke-enum/","__resourceUrl":"/9/0-kieu-liet-ke-enum/index.html","__dataUrl":"/9/0-kieu-liet-ke-enum/index.html.860576a918a655f1f53e822bc51c8bf5.json"},{"title":"9.1 Structs","route":"9/1-structs","description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent…","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.3a2cb4930e4325d583c56db63e3817bf.json"},{"title":"9.2 Structs and pointer","route":"9/2-structs-and-pointer","description":"int main() { \tBankAccount myAccount = { 123456789, 50 }; // $50 \tBankAccount \\*pAccount = &myAccount;  } int main() { \tBankAccount…","__filename":"generated/33521.md","__url":"/9/2-structs-and-pointer/","__resourceUrl":"/9/2-structs-and-pointer/index.html","__dataUrl":"/9/2-structs-and-pointer/index.html.670178e35e40d08eb17402bbc3b5d4c3.json"},{"title":"Khóa học C++","description":"","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.6be0918faeb891a3ade9da07ef33c29b.json"}];window.__INITIAL_STATE__ = {"pages":{"/5/0-mang-mot-chieu/":{"head":{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt…"},"body":"\n<h4>Chào tất cả các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục với bài học ngày hôm nay, chúng ta sẽ cùng tìm hiểu về một cách tổ chức dữ liệu cơ bản trong thiết bị lưu trữ tạm thời của máy tính giúp khắc phục một số nhược điểm của việc sử dụng các biến thông thường.</p>\n\n<h5>Đặt vấn đề</h5>\n\n<p>Giảng viên cần tìm ra điểm số cao nhất của bài kiểm tra môn lập trình cơ sở. Giả sử lớp học có 30 sinh viên có số thứ tự 1 đến 30. </p>\n\n<p>Công việc của những lập trình viên chúng ta là giúp giảng viên này chỉ ra số thứ tự của sinh viên có điểm kiểm tra cao nhất, và điểm cao nhất đó là bao nhiêu bằng cách viết chương trình ngôn ngữ C++ trên máy tính để tiết kiệm thời gian suy nghĩ.</p>\n\n<h5>Tìm hướng giải quyết</h5>\n\n<p>Với yêu cầu như trên, chúng ta cần 30 biến để lưu lại điểm của 30 sinh viên.</p>\n\n<pre><code>int32_t score_of_student1;\nint32_t score_of_student2;\n//....\nint32_t score_of_student30;</code></pre>\n\n<p>Vậy là chúng ta cần tới 30 dòng lệnh khai báo 30 biến, chưa kể mất thời gian viết thêm 30 dòng lệnh nhập dữ liệu vào là điểm của từng sinh viên, sau đó chúng ta còn phải tìm điểm cao nhất. </p>\n\n<p>Một vấn đề khác nãy sinh: Sau khi tìm ra điểm số cao nhất từ 30 biến trên, làm thế nào chúng ta biết điểm số đó là của sinh viên có số thứ tự nào trong khi 30 biến này được cấp phát hoàn toàn tách biệt nhau (không theo 1 thứ tự nhất định)?</p>\n\n<p>Rất may mắn cho chúng ta khi ngôn ngữ C/C++ đưa ra cho chúng ta một khái niệm về tổ chức dữ liệu liên tiếp nhau trên thiết bị cung cấp bộ nhớ. Chúng ta có thể gọi là <strong>Mảng một chiều (Array)</strong>.</p>\n\n<h2></h2>\n\n<h3>Mảng một chiều (Array)</h3>\n\n<p>Mảng một chiều (<strong>array</strong>) là một dãy các phần tử có cùng kiểu dữ liệu được đặt liên tiếp nhau trong một vùng nhớ, chúng ta có thể ngay lập tức truy xuất đến một phần tử của dãy đó thông qua chỉ số của mỗi phần tử.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" width=\"690\" height=\"287\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">915x381</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như hình trên, giả sử mình khai báo mảng một chiều có 3 phần tử kiểu <strong>int32_t</strong>, mỗi phần tử sẽ có kích thước <strong>4 bytes</strong>. </p>\n\n<p>Mình lấy ví dụ hệ điều hành tìm thấy vùng nhớ trống đủ chổ chứa 3 phần tử của mảng tại địa chỉ <strong>108</strong>, thì phần tử đầu tiên a1 sẽ có địa chỉ là địa chỉ ô nhớ đầu tiên mà hệ điều hành cấp phát (là <strong>108</strong>). Khi đó, phần tử thứ 2 sẽ có địa chỉ là địa chỉ của phần tử thứ nhất cộng thêm 4 (4 là kích thước kiểu dữ liệu <strong>int32_t</strong>), tương tự cho phần tử thứ 3.</p>\n\n<p>Với kiểu tổ chức dữ liệu này, chúng ta chỉ cần quan tâm đến 2 điều:</p>\n\n<ul>\n<li>Địa chỉ ô nhớ đầu tiên trong mảng.</li>\n<li>Số phần tử của mảng.</li>\n</ul>\n\n<p>Từ đó, chúng ta có thể truy xuất đến toàn bộ phần tử trong mảng.</p>\n\n<h3>Khai báo mảng một chiều</h3>\n\n<p>Chúng ta có nhiều cách để khai báo mảng một chiều khác nhau:</p>\n\n<ul><li>Khai báo nhưng không khởi tạo các phần tử:</li></ul>\n\n<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[&lt;number_of_elements&gt;];</code></p>\n\n<p>Với cách khai báo này, chúng ta cần ghi rõ cho <strong>compiler</strong> biết số lượng phần tử mà bạn cần sử dụng đặt trong cặp dấu ngoặc vuông. Ví dụ:</p>\n\n<pre><code>int32_t age_of_students[30];</code></pre>\n\n<p>Mình vừa tạo ra một mảng dữ liệu kiểu <strong>int32_t</strong> để lưu trữ số tuổi của 30 sinh viên trong 1 lớp học.</p>\n\n<p>Vì mình chưa khởi tạo giá trị cụ thể cho 30 phần tử trong mảng, nên khi truy xuất đến giá trị của từng phần tử, chúng ta có thể nhận được giá trị khởi tạo mặc định của kiểu int32_t là 0 hoặc giá trị rác (tùy vào <strong>compiler</strong>).</p>\n\n<ul><li>Khai báo và khởi tạo giá trị cho mỗi phần tử:</li></ul>\n\n<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[] = { &lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; };</code></p>\n\n<p>Với cách khai báo này, chúng ta không cần thiết xác định trước số phần tử của mảng. Compiler sẽ xác định số phần tử thông qua số lượng giá trị mà bạn khởi tạo.</p>\n\n<pre><code>char my_string[] = { 'H', 'e', 'l', 'l', 'o', '\\0' };</code></pre>\n\n<p>Mình vừa khai báo một mảng phần tử với kiểu kí tự (Chúng ta sẽ đi sâu hơn về chuỗi kí tự trong những bài học sau), <strong>compiler</strong> nhìn vào số lượng kí tự mình khởi tạo và cấp phát 6 ô nhớ liên tục nhau trên vùng nhớ còn trống.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true\" width=\"690\" height=\"223\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">912x296</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p><em>Với kiểu kí tự, mỗi phần tử chỉ chiếm 1 byte, nên chúng ta có 6 bytes liên tiếp nhau để chứa được chuỗi kí tự trên.</em></p>\n\n<h3>Truy xuất đến các phần tử trong mảng một chiều</h3>\n\n<p>Sau khi biết cách khai báo mảng một chiều (<strong>array</strong>), điều tiếp theo chúng ta cần quan tâm là làm thế nào để truy xuất đến một phần tử trong mảng.</p>\n\n<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng. Phần tử đầu tiên của mảng mang chỉ số <strong>0</strong>, phần tử cuối cùng của mảng có <strong>N</strong> phần tử sẽ có chỉ số <strong>(N - 1)</strong>.</p></blockquote>\n\n<p>Cú pháp truy xuất phần tử trong mảng một chiều:</p>\n\n<p><code>&lt;name_of_array&gt;[index];</code></p>\n\n<p>Trong đó, <strong>index</strong> là một số nguyên đại diện cho chỉ số của phần tử trong mảng một chiều.</p>\n\n<p>Ví dụ với một mảng một chiều kiểu int32_t có 5 phần tử được khai báo như sau:</p>\n\n<pre><code>int32_t values[] = { 2, 4, 6, 8, 10 };</code></pre>\n\n<p>Khi đó, các phần tử trong mảng lần lượt là:</p>\n\n<pre><code>values[0]; //2\nvalues[1]; //4\nvalues[2]; //6\nvalues[3]; //8\nvalues[4]; //10</code></pre>\n\n<h5>Giải thích cho việc tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0:</h5>\n\n<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng.</p></blockquote>\n\n<p>Sau khi khai báo mảng một chiều, địa chỉ của mảng ứng với địa chỉ của phần tử đầu tiên trong mảng. Vị trí của các phần tử sẽ được tính dựa trên công thức:</p>\n\n<p><code>index = (address_of_current_element - address_of_the_first_element) / sizeof(data_type);</code></p>\n\n<p>Lấy lại ví dụ mảng có 3 phần tử kiểu int32_t như trong mục <strong>Mảng một chiều (Array)</strong></p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" width=\"690\" height=\"287\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">915x381</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Cho rằng địa chỉ của mảng <strong>a</strong> (cũng là địa chỉ của phần tử a1) là <strong>108</strong>. Vậy chỉ số của phần tử đầu tiên a1 là:</p>\n\n<p><code>index_of_a1 = (address_of_a1 - address_of_the_first_element) / sizeof(int32_t);</code></p>\n\n<p><code>index_of_a1 = (108 - 108) / 4 = 0;</code></p>\n\n<p>Như vậy, phần tử đầu tiên của mảng có chỉ số là <strong>0</strong>.</p>\n\n<p>Đây chỉ là phần mình làm rõ cho các bạn tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0 và kết thúc tại <code>(số_phần_tử - 1)</code>. Các bạn không cần quan tâm đến việc tính toán chỉ số của mỗi phần tử mà <strong>compiler</strong> sẽ làm giúp bạn.</p>\n\n<h5>In ra giá trị của tất cả phần tử trong mảng</h5>\n\n<p>Để quản lý mảng một chiều, chúng ta cần biết:</p>\n\n<ul>\n<li>Địa chỉ phần tử đầu tiên của mảng. (Có thể có được thông qua <code>&lt;array_name&gt;[0]</code>)</li>\n<li>Số lượng phần tử của mảng.</li>\n</ul>\n\n<p>Mình sẽ thực hiện một phương pháp tổng quát để lấy ra số lượng phần tử của mảng:</p>\n\n<p><code>&lt;number_of_elements&gt; = sizeof(&lt;name_of_array&gt;) / sizeof(&lt;type_of_array&gt;);</code></p>\n\n<p>Chúng ta sử dụng toán tử <strong>sizeof</strong>, truyền vào tên của mảng chúng ta sẽ nhận được giá trị là tổng kích thước bộ nhớ sử dụng cho mảng, chia cho kích thước của một phần tử của mảng chúng ta sẽ có được số lượng phần tử. Ví dụ:</p>\n\n<pre><code>double d_values[] = { 2.08, 1.32, 6, 4.1, 12, 999.99 };\nint32_t num_of_elements = sizeof(d_values) / sizeof(double);\n\n//another way\nnum_of_elements = sizeof(d_values) / sizeof(d_values[0]);\n\ncout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt;&lt; endl;</code></pre>\n\n<p>Kết quả chương trình sẽ cho ta thấy mảng có 6 phần tử:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/2.png?raw=true\" width=\"670\" height=\"339\"></p>\n\n<p>Như cách thông thường, chúng ta thường định nghĩa trước số lượng phần tử tối đa mà mảng một chiều có thể chứa như sau:</p>\n\n<pre><code>#define ARRAY_SIZE 100\n\n//........\n\nfloat f_values[ARRAY_SIZE];</code></pre>\n\n<p>Lúc này, chúng ta chỉ cần sử dụng <code>ARRAY_SIZE</code> như là số lượng phần tử của mảng. Nhưng cách này có thể là hao tốn bộ nhớ khi số lượng phần tử thực sự cần sử dụng không đạt đến con số <code>ARRAY_SIZE</code>. Vì thế, mình thường tính số phần tử của mảng theo cách tổng quát mà mình trình bày ở trên.</p>\n\n<h5>Điều gì xảy ra nếu chúng ta truy xuất mảng bằng chỉ số lớn hơn số lượng phần tử?</h5>\n\n<p>Các bạn thử chạy đoạn chương trình sau:</p>\n\n<pre><code>int32_t arr[] = { 1, 2, 3, 4, 5 }; //create an array with 5 elements\ncout &lt;&lt; arr[100] &lt;&lt; endl;</code></pre>\n\n<p>Ở lần chạy đầu tiên của đoạn chương trình trên, máy mình cho ra kết quả:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/3.png?raw=true\" width=\"668\" height=\"337\"></p>\n\n<p>Thử chạy lại chương trình nhiều lần khác nhau, các bạn sẽ thấy được nhiều giá trị khác nhau. Những giá trị này ở đâu ra?</p>\n\n<p>Đó chính là những giá trị thuộc vùng nhớ mà chương trình khác đang quản lý.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true\" class=\"lightbox\" title=\"4.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true\" width=\"690\" height=\"274\"><div class=\"meta\">\n<span class=\"filename\">4.png?raw=true</span><span class=\"informations\">968x385</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Có thể sau khi các chương trình khác sử dụng vùng nhớ đó và trả lại cho hệ điều hành quản lý, giá trị của ô nhớ vẫn còn giữ nguyên, nên khi truy cập mảng với chỉ số vượt quá số lượng phần tử tối đa, chúng ta nhận được những giá trị không có ý nghĩa.</p>\n\n<p>Trường hợp xấu hơn có thể xảy ra là khi các chương trình khác đang sử dụng vùng nhớ mà bạn truy cập đến, Visual studio sẽ đưa ra cảnh báo về việc xung đột vùng nhớ và cho dừng chương trình của bạn.</p>\n\n<p><img src=\"https://raw.githubusercontent.com/nguyenchiemminhvu/CPP-Tutorial/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/5.png\" width=\"558\" height=\"314\"></p>\n\n<p>Vì thế việc quản lý số lượng phần tử của mảng là rất quan trọng.</p>\n\n<h3>Nhập dữ liệu cho mảng một chiều (Array input)</h3>\n\n<p>Giả sử chúng ta có mảng một chiều dùng để chứa 10 số nguyên (có chỉ số từ 0 đến 9). Để nhập dữ liệu cho từng phần tử trong mảng này, chúng ta có thể sử dụng đối tượng <strong>cin</strong> trong thư viện <strong>iostream</strong> mà các bạn đã được học.</p>\n\n<p><code>cin &gt;&gt; &lt;name_of_array&gt;[index];</code></p>\n\n<p>Trong đó, <strong>index</strong> là chỉ số của phần tử của mảng mà chúng ta cần nhập giá trị từ bàn phím và đưa vào phần tử.</p>\n\n<pre><code>int32_t arr[10];\nfor(int32_t index = 0; index &lt;= 9; index++)\t{\n\tcin &gt;&gt; arr[index];\n}</code></pre>\n\n<p>Mình vừa sử dụng vòng lặp <strong>for</strong> (vì mình biết được số lượng phần tử của mảng nên mình biết cần lặp bao nhiêu lần), trong vòng lặp <strong>for</strong> này, mình sử dụng biến <strong>index</strong> và cho nó di chuyển từ giá trị <strong>0 đến 9</strong> tương ứng với từng chỉ số của các phần tử trong mảng. Với mỗi giá trị <strong>index</strong> được gán, mình thực hiện nhập dữ liệu từ bàn phím bằng đối tượng <strong>cin</strong> cho phần tử <strong>arr[index]</strong>.</p>\n\n<h5>Một cách tổng quát hơn để nhập dữ liệu cho mảng một chiều</h5>\n\n<p>Ở ví dụ trên, mình cho mảng số nguyên có số lượng phần tử cố định là 10. Đối với mảng một chiều có số lượng phần tử khác nhau thì ta làm thế nào?</p>\n\n<p>Việc đầu tiên chúng ta cần làm là tìm ra số lượng phần tử của mảng. Ví dụ:</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\tcin &gt;&gt; i_values[index];\t\n}</code></pre>\n\n<p>Với cách này, chúng ta có thể không cần quan tâm đến số lượng phần tử hiện tại của mảng, mà mình để <strong>compiler</strong> tính giúp mình.</p>\n\n<p>Mình cho biến index chạy từ 0 đến (num_of_elements - 1) vì như mình đã nói ở trên, mảng một chiều có chỉ số bắt đầu từ 0 đến <code>số_lượng_phần_tử</code> trừ đi 1.</p>\n\n<h5>Đưa ra nhắc nhở khi nhập dữ liệu cho mảng</h5>\n\n<p>Chúng ta nên thông báo cho người dùng biết là chúng ta đang nhập dữ liệu cho phần tử nào trong mảng.</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\tcout &lt;&lt; \"Value of element \" &lt;&lt; index &lt;&lt; \": \";\n\tcin &gt;&gt; i_values[index];\t\n}</code></pre>\n\n<p>Như vậy, người dùng sẽ tránh được việc nhập nhầm thứ tự dữ liệu cho các phần tử trong mảng.</p>\n\n<p>Ngoài việc dùng đối tượng cin, chúng ta cũng có thể gán trực tiếp giá trị cho các phần tử trong mảng thông qua toán tử gán.</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\ti_values[index] = index + 1;\n}</code></pre>\n\n<h5>Nhập dữ liệu cho ô nhớ có chỉ số vượt quá số lượng phần tử</h5>\n\n<p>Cũng tương tự như việc bạn truy xuất đến phần tử với chỉ số vượt ngoài tầm số lượng phần tử trong mảng, Visual studio sẽ đưa ra cảnh báo xung đột vùng nhớ và dừng chương trình.</p>\n\n<h2></h2>\n\n<h3>Tổng kết</h3>\n\n<p>Cùng nhìn lại vấn đề mình đặt ra ngay từ đầu bài học, mảng một chiều đã giúp chúng ta tiết kiệm thời gian hơn khi mà chỉ với 1 dòng lệnh khai báo mảng một chiều, chúng ta có thể quản lý 30 vùng nhớ liên tiếp nhau dùng để lưu trữ điểm của cả 30 sinh viên. Chúng ta cũng có thể biết được điểm số nào là của sinh viên nào thông qua chỉ số của mảng đó.</p>\n\n<p>Mảng một chiều đã khắc phục nhiều nhược điểm của việc khai báo các biến đơn lẻ. Tuy nhiên, nó cũng có một số nhược điểm riêng như việc dư thừa vùng nhớ khi không dùng hết số lượng ô nhớ đã cấp phát, hoặc số lượng phần tử được yêu cầu quá lớn nên hệ điều hành không đủ khả năng cấp phát. Chúng ta sẽ tìm cách giải quyết những vấn đề này trong những bài học sau.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>Với yêu cầu đặt ra ban đầu, giảng viên cần biết điểm số cao nhất của 30 sinh viên trong lớp, đồng thời muốn biết điểm cao nhất là của sinh viên có số thứ tự bao nhiêu. Bạn hãy sử dụng mảng 1 chiều để giải quyết vấn đề này. (Điểm của sinh viên được nhập từ bàn phím)</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","rawBody":"\n<h4>Chào tất cả các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục với bài học ngày hôm nay, chúng ta sẽ cùng tìm hiểu về một cách tổ chức dữ liệu cơ bản trong thiết bị lưu trữ tạm thời của máy tính giúp khắc phục một số nhược điểm của việc sử dụng các biến thông thường.</p>\n\n<h5>Đặt vấn đề</h5>\n\n<p>Giảng viên cần tìm ra điểm số cao nhất của bài kiểm tra môn lập trình cơ sở. Giả sử lớp học có 30 sinh viên có số thứ tự 1 đến 30. </p>\n\n<p>Công việc của những lập trình viên chúng ta là giúp giảng viên này chỉ ra số thứ tự của sinh viên có điểm kiểm tra cao nhất, và điểm cao nhất đó là bao nhiêu bằng cách viết chương trình ngôn ngữ C++ trên máy tính để tiết kiệm thời gian suy nghĩ.</p>\n\n<h5>Tìm hướng giải quyết</h5>\n\n<p>Với yêu cầu như trên, chúng ta cần 30 biến để lưu lại điểm của 30 sinh viên.</p>\n\n<pre><code>int32_t score_of_student1;\nint32_t score_of_student2;\n//....\nint32_t score_of_student30;</code></pre>\n\n<p>Vậy là chúng ta cần tới 30 dòng lệnh khai báo 30 biến, chưa kể mất thời gian viết thêm 30 dòng lệnh nhập dữ liệu vào là điểm của từng sinh viên, sau đó chúng ta còn phải tìm điểm cao nhất. </p>\n\n<p>Một vấn đề khác nãy sinh: Sau khi tìm ra điểm số cao nhất từ 30 biến trên, làm thế nào chúng ta biết điểm số đó là của sinh viên có số thứ tự nào trong khi 30 biến này được cấp phát hoàn toàn tách biệt nhau (không theo 1 thứ tự nhất định)?</p>\n\n<p>Rất may mắn cho chúng ta khi ngôn ngữ C/C++ đưa ra cho chúng ta một khái niệm về tổ chức dữ liệu liên tiếp nhau trên thiết bị cung cấp bộ nhớ. Chúng ta có thể gọi là <strong>Mảng một chiều (Array)</strong>.</p>\n\n<h2></h2>\n\n<h3>Mảng một chiều (Array)</h3>\n\n<p>Mảng một chiều (<strong>array</strong>) là một dãy các phần tử có cùng kiểu dữ liệu được đặt liên tiếp nhau trong một vùng nhớ, chúng ta có thể ngay lập tức truy xuất đến một phần tử của dãy đó thông qua chỉ số của mỗi phần tử.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" width=\"690\" height=\"287\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">915x381</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như hình trên, giả sử mình khai báo mảng một chiều có 3 phần tử kiểu <strong>int32_t</strong>, mỗi phần tử sẽ có kích thước <strong>4 bytes</strong>. </p>\n\n<p>Mình lấy ví dụ hệ điều hành tìm thấy vùng nhớ trống đủ chổ chứa 3 phần tử của mảng tại địa chỉ <strong>108</strong>, thì phần tử đầu tiên a1 sẽ có địa chỉ là địa chỉ ô nhớ đầu tiên mà hệ điều hành cấp phát (là <strong>108</strong>). Khi đó, phần tử thứ 2 sẽ có địa chỉ là địa chỉ của phần tử thứ nhất cộng thêm 4 (4 là kích thước kiểu dữ liệu <strong>int32_t</strong>), tương tự cho phần tử thứ 3.</p>\n\n<p>Với kiểu tổ chức dữ liệu này, chúng ta chỉ cần quan tâm đến 2 điều:</p>\n\n<ul>\n<li>Địa chỉ ô nhớ đầu tiên trong mảng.</li>\n<li>Số phần tử của mảng.</li>\n</ul>\n\n<p>Từ đó, chúng ta có thể truy xuất đến toàn bộ phần tử trong mảng.</p>\n\n<h3>Khai báo mảng một chiều</h3>\n\n<p>Chúng ta có nhiều cách để khai báo mảng một chiều khác nhau:</p>\n\n<ul><li>Khai báo nhưng không khởi tạo các phần tử:</li></ul>\n\n<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[&lt;number_of_elements&gt;];</code></p>\n\n<p>Với cách khai báo này, chúng ta cần ghi rõ cho <strong>compiler</strong> biết số lượng phần tử mà bạn cần sử dụng đặt trong cặp dấu ngoặc vuông. Ví dụ:</p>\n\n<pre><code>int32_t age_of_students[30];</code></pre>\n\n<p>Mình vừa tạo ra một mảng dữ liệu kiểu <strong>int32_t</strong> để lưu trữ số tuổi của 30 sinh viên trong 1 lớp học.</p>\n\n<p>Vì mình chưa khởi tạo giá trị cụ thể cho 30 phần tử trong mảng, nên khi truy xuất đến giá trị của từng phần tử, chúng ta có thể nhận được giá trị khởi tạo mặc định của kiểu int32_t là 0 hoặc giá trị rác (tùy vào <strong>compiler</strong>).</p>\n\n<ul><li>Khai báo và khởi tạo giá trị cho mỗi phần tử:</li></ul>\n\n<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[] = { &lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; };</code></p>\n\n<p>Với cách khai báo này, chúng ta không cần thiết xác định trước số phần tử của mảng. Compiler sẽ xác định số phần tử thông qua số lượng giá trị mà bạn khởi tạo.</p>\n\n<pre><code>char my_string[] = { 'H', 'e', 'l', 'l', 'o', '\\0' };</code></pre>\n\n<p>Mình vừa khai báo một mảng phần tử với kiểu kí tự (Chúng ta sẽ đi sâu hơn về chuỗi kí tự trong những bài học sau), <strong>compiler</strong> nhìn vào số lượng kí tự mình khởi tạo và cấp phát 6 ô nhớ liên tục nhau trên vùng nhớ còn trống.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true\" width=\"690\" height=\"223\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">912x296</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p><em>Với kiểu kí tự, mỗi phần tử chỉ chiếm 1 byte, nên chúng ta có 6 bytes liên tiếp nhau để chứa được chuỗi kí tự trên.</em></p>\n\n<h3>Truy xuất đến các phần tử trong mảng một chiều</h3>\n\n<p>Sau khi biết cách khai báo mảng một chiều (<strong>array</strong>), điều tiếp theo chúng ta cần quan tâm là làm thế nào để truy xuất đến một phần tử trong mảng.</p>\n\n<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng. Phần tử đầu tiên của mảng mang chỉ số <strong>0</strong>, phần tử cuối cùng của mảng có <strong>N</strong> phần tử sẽ có chỉ số <strong>(N - 1)</strong>.</p></blockquote>\n\n<p>Cú pháp truy xuất phần tử trong mảng một chiều:</p>\n\n<p><code>&lt;name_of_array&gt;[index];</code></p>\n\n<p>Trong đó, <strong>index</strong> là một số nguyên đại diện cho chỉ số của phần tử trong mảng một chiều.</p>\n\n<p>Ví dụ với một mảng một chiều kiểu int32_t có 5 phần tử được khai báo như sau:</p>\n\n<pre><code>int32_t values[] = { 2, 4, 6, 8, 10 };</code></pre>\n\n<p>Khi đó, các phần tử trong mảng lần lượt là:</p>\n\n<pre><code>values[0]; //2\nvalues[1]; //4\nvalues[2]; //6\nvalues[3]; //8\nvalues[4]; //10</code></pre>\n\n<h5>Giải thích cho việc tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0:</h5>\n\n<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng.</p></blockquote>\n\n<p>Sau khi khai báo mảng một chiều, địa chỉ của mảng ứng với địa chỉ của phần tử đầu tiên trong mảng. Vị trí của các phần tử sẽ được tính dựa trên công thức:</p>\n\n<p><code>index = (address_of_current_element - address_of_the_first_element) / sizeof(data_type);</code></p>\n\n<p>Lấy lại ví dụ mảng có 3 phần tử kiểu int32_t như trong mục <strong>Mảng một chiều (Array)</strong></p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" width=\"690\" height=\"287\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">915x381</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Cho rằng địa chỉ của mảng <strong>a</strong> (cũng là địa chỉ của phần tử a1) là <strong>108</strong>. Vậy chỉ số của phần tử đầu tiên a1 là:</p>\n\n<p><code>index_of_a1 = (address_of_a1 - address_of_the_first_element) / sizeof(int32_t);</code></p>\n\n<p><code>index_of_a1 = (108 - 108) / 4 = 0;</code></p>\n\n<p>Như vậy, phần tử đầu tiên của mảng có chỉ số là <strong>0</strong>.</p>\n\n<p>Đây chỉ là phần mình làm rõ cho các bạn tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0 và kết thúc tại <code>(số_phần_tử - 1)</code>. Các bạn không cần quan tâm đến việc tính toán chỉ số của mỗi phần tử mà <strong>compiler</strong> sẽ làm giúp bạn.</p>\n\n<h5>In ra giá trị của tất cả phần tử trong mảng</h5>\n\n<p>Để quản lý mảng một chiều, chúng ta cần biết:</p>\n\n<ul>\n<li>Địa chỉ phần tử đầu tiên của mảng. (Có thể có được thông qua <code>&lt;array_name&gt;[0]</code>)</li>\n<li>Số lượng phần tử của mảng.</li>\n</ul>\n\n<p>Mình sẽ thực hiện một phương pháp tổng quát để lấy ra số lượng phần tử của mảng:</p>\n\n<p><code>&lt;number_of_elements&gt; = sizeof(&lt;name_of_array&gt;) / sizeof(&lt;type_of_array&gt;);</code></p>\n\n<p>Chúng ta sử dụng toán tử <strong>sizeof</strong>, truyền vào tên của mảng chúng ta sẽ nhận được giá trị là tổng kích thước bộ nhớ sử dụng cho mảng, chia cho kích thước của một phần tử của mảng chúng ta sẽ có được số lượng phần tử. Ví dụ:</p>\n\n<pre><code>double d_values[] = { 2.08, 1.32, 6, 4.1, 12, 999.99 };\nint32_t num_of_elements = sizeof(d_values) / sizeof(double);\n\n//another way\nnum_of_elements = sizeof(d_values) / sizeof(d_values[0]);\n\ncout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt;&lt; endl;</code></pre>\n\n<p>Kết quả chương trình sẽ cho ta thấy mảng có 6 phần tử:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/2.png?raw=true\" width=\"670\" height=\"339\"></p>\n\n<p>Như cách thông thường, chúng ta thường định nghĩa trước số lượng phần tử tối đa mà mảng một chiều có thể chứa như sau:</p>\n\n<pre><code>#define ARRAY_SIZE 100\n\n//........\n\nfloat f_values[ARRAY_SIZE];</code></pre>\n\n<p>Lúc này, chúng ta chỉ cần sử dụng <code>ARRAY_SIZE</code> như là số lượng phần tử của mảng. Nhưng cách này có thể là hao tốn bộ nhớ khi số lượng phần tử thực sự cần sử dụng không đạt đến con số <code>ARRAY_SIZE</code>. Vì thế, mình thường tính số phần tử của mảng theo cách tổng quát mà mình trình bày ở trên.</p>\n\n<h5>Điều gì xảy ra nếu chúng ta truy xuất mảng bằng chỉ số lớn hơn số lượng phần tử?</h5>\n\n<p>Các bạn thử chạy đoạn chương trình sau:</p>\n\n<pre><code>int32_t arr[] = { 1, 2, 3, 4, 5 }; //create an array with 5 elements\ncout &lt;&lt; arr[100] &lt;&lt; endl;</code></pre>\n\n<p>Ở lần chạy đầu tiên của đoạn chương trình trên, máy mình cho ra kết quả:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/3.png?raw=true\" width=\"668\" height=\"337\"></p>\n\n<p>Thử chạy lại chương trình nhiều lần khác nhau, các bạn sẽ thấy được nhiều giá trị khác nhau. Những giá trị này ở đâu ra?</p>\n\n<p>Đó chính là những giá trị thuộc vùng nhớ mà chương trình khác đang quản lý.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true\" class=\"lightbox\" title=\"4.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true\" width=\"690\" height=\"274\"><div class=\"meta\">\n<span class=\"filename\">4.png?raw=true</span><span class=\"informations\">968x385</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Có thể sau khi các chương trình khác sử dụng vùng nhớ đó và trả lại cho hệ điều hành quản lý, giá trị của ô nhớ vẫn còn giữ nguyên, nên khi truy cập mảng với chỉ số vượt quá số lượng phần tử tối đa, chúng ta nhận được những giá trị không có ý nghĩa.</p>\n\n<p>Trường hợp xấu hơn có thể xảy ra là khi các chương trình khác đang sử dụng vùng nhớ mà bạn truy cập đến, Visual studio sẽ đưa ra cảnh báo về việc xung đột vùng nhớ và cho dừng chương trình của bạn.</p>\n\n<p><img src=\"https://raw.githubusercontent.com/nguyenchiemminhvu/CPP-Tutorial/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/5.png\" width=\"558\" height=\"314\"></p>\n\n<p>Vì thế việc quản lý số lượng phần tử của mảng là rất quan trọng.</p>\n\n<h3>Nhập dữ liệu cho mảng một chiều (Array input)</h3>\n\n<p>Giả sử chúng ta có mảng một chiều dùng để chứa 10 số nguyên (có chỉ số từ 0 đến 9). Để nhập dữ liệu cho từng phần tử trong mảng này, chúng ta có thể sử dụng đối tượng <strong>cin</strong> trong thư viện <strong>iostream</strong> mà các bạn đã được học.</p>\n\n<p><code>cin &gt;&gt; &lt;name_of_array&gt;[index];</code></p>\n\n<p>Trong đó, <strong>index</strong> là chỉ số của phần tử của mảng mà chúng ta cần nhập giá trị từ bàn phím và đưa vào phần tử.</p>\n\n<pre><code>int32_t arr[10];\nfor(int32_t index = 0; index &lt;= 9; index++)\t{\n\tcin &gt;&gt; arr[index];\n}</code></pre>\n\n<p>Mình vừa sử dụng vòng lặp <strong>for</strong> (vì mình biết được số lượng phần tử của mảng nên mình biết cần lặp bao nhiêu lần), trong vòng lặp <strong>for</strong> này, mình sử dụng biến <strong>index</strong> và cho nó di chuyển từ giá trị <strong>0 đến 9</strong> tương ứng với từng chỉ số của các phần tử trong mảng. Với mỗi giá trị <strong>index</strong> được gán, mình thực hiện nhập dữ liệu từ bàn phím bằng đối tượng <strong>cin</strong> cho phần tử <strong>arr[index]</strong>.</p>\n\n<h5>Một cách tổng quát hơn để nhập dữ liệu cho mảng một chiều</h5>\n\n<p>Ở ví dụ trên, mình cho mảng số nguyên có số lượng phần tử cố định là 10. Đối với mảng một chiều có số lượng phần tử khác nhau thì ta làm thế nào?</p>\n\n<p>Việc đầu tiên chúng ta cần làm là tìm ra số lượng phần tử của mảng. Ví dụ:</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\tcin &gt;&gt; i_values[index];\t\n}</code></pre>\n\n<p>Với cách này, chúng ta có thể không cần quan tâm đến số lượng phần tử hiện tại của mảng, mà mình để <strong>compiler</strong> tính giúp mình.</p>\n\n<p>Mình cho biến index chạy từ 0 đến (num_of_elements - 1) vì như mình đã nói ở trên, mảng một chiều có chỉ số bắt đầu từ 0 đến <code>số_lượng_phần_tử</code> trừ đi 1.</p>\n\n<h5>Đưa ra nhắc nhở khi nhập dữ liệu cho mảng</h5>\n\n<p>Chúng ta nên thông báo cho người dùng biết là chúng ta đang nhập dữ liệu cho phần tử nào trong mảng.</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\tcout &lt;&lt; \"Value of element \" &lt;&lt; index &lt;&lt; \": \";\n\tcin &gt;&gt; i_values[index];\t\n}</code></pre>\n\n<p>Như vậy, người dùng sẽ tránh được việc nhập nhầm thứ tự dữ liệu cho các phần tử trong mảng.</p>\n\n<p>Ngoài việc dùng đối tượng cin, chúng ta cũng có thể gán trực tiếp giá trị cho các phần tử trong mảng thông qua toán tử gán.</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\ti_values[index] = index + 1;\n}</code></pre>\n\n<h5>Nhập dữ liệu cho ô nhớ có chỉ số vượt quá số lượng phần tử</h5>\n\n<p>Cũng tương tự như việc bạn truy xuất đến phần tử với chỉ số vượt ngoài tầm số lượng phần tử trong mảng, Visual studio sẽ đưa ra cảnh báo xung đột vùng nhớ và dừng chương trình.</p>\n\n<h2></h2>\n\n<h3>Tổng kết</h3>\n\n<p>Cùng nhìn lại vấn đề mình đặt ra ngay từ đầu bài học, mảng một chiều đã giúp chúng ta tiết kiệm thời gian hơn khi mà chỉ với 1 dòng lệnh khai báo mảng một chiều, chúng ta có thể quản lý 30 vùng nhớ liên tiếp nhau dùng để lưu trữ điểm của cả 30 sinh viên. Chúng ta cũng có thể biết được điểm số nào là của sinh viên nào thông qua chỉ số của mảng đó.</p>\n\n<p>Mảng một chiều đã khắc phục nhiều nhược điểm của việc khai báo các biến đơn lẻ. Tuy nhiên, nó cũng có một số nhược điểm riêng như việc dư thừa vùng nhớ khi không dùng hết số lượng ô nhớ đã cấp phát, hoặc số lượng phần tử được yêu cầu quá lớn nên hệ điều hành không đủ khả năng cấp phát. Chúng ta sẽ tìm cách giải quyết những vấn đề này trong những bài học sau.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>Với yêu cầu đặt ra ban đầu, giảng viên cần biết điểm số cao nhất của 30 sinh viên trong lớp, đồng thời muốn biết điểm cao nhất là của sinh viên có số thứ tự bao nhiêu. Bạn hãy sử dụng mảng 1 chiều để giải quyết vấn đề này. (Điểm của sinh viên được nhập từ bàn phím)</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","raw":"---json\n{\"title\":\"5.0 Mảng một chiều\",\"route\":\"5/0-mang-mot-chieu\"}\n---\n\n<h4>Chào tất cả các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục với bài học ngày hôm nay, chúng ta sẽ cùng tìm hiểu về một cách tổ chức dữ liệu cơ bản trong thiết bị lưu trữ tạm thời của máy tính giúp khắc phục một số nhược điểm của việc sử dụng các biến thông thường.</p>\n\n<h5>Đặt vấn đề</h5>\n\n<p>Giảng viên cần tìm ra điểm số cao nhất của bài kiểm tra môn lập trình cơ sở. Giả sử lớp học có 30 sinh viên có số thứ tự 1 đến 30. </p>\n\n<p>Công việc của những lập trình viên chúng ta là giúp giảng viên này chỉ ra số thứ tự của sinh viên có điểm kiểm tra cao nhất, và điểm cao nhất đó là bao nhiêu bằng cách viết chương trình ngôn ngữ C++ trên máy tính để tiết kiệm thời gian suy nghĩ.</p>\n\n<h5>Tìm hướng giải quyết</h5>\n\n<p>Với yêu cầu như trên, chúng ta cần 30 biến để lưu lại điểm của 30 sinh viên.</p>\n\n<pre><code>int32_t score_of_student1;\nint32_t score_of_student2;\n//....\nint32_t score_of_student30;</code></pre>\n\n<p>Vậy là chúng ta cần tới 30 dòng lệnh khai báo 30 biến, chưa kể mất thời gian viết thêm 30 dòng lệnh nhập dữ liệu vào là điểm của từng sinh viên, sau đó chúng ta còn phải tìm điểm cao nhất. </p>\n\n<p>Một vấn đề khác nãy sinh: Sau khi tìm ra điểm số cao nhất từ 30 biến trên, làm thế nào chúng ta biết điểm số đó là của sinh viên có số thứ tự nào trong khi 30 biến này được cấp phát hoàn toàn tách biệt nhau (không theo 1 thứ tự nhất định)?</p>\n\n<p>Rất may mắn cho chúng ta khi ngôn ngữ C/C++ đưa ra cho chúng ta một khái niệm về tổ chức dữ liệu liên tiếp nhau trên thiết bị cung cấp bộ nhớ. Chúng ta có thể gọi là <strong>Mảng một chiều (Array)</strong>.</p>\n\n<h2></h2>\n\n<h3>Mảng một chiều (Array)</h3>\n\n<p>Mảng một chiều (<strong>array</strong>) là một dãy các phần tử có cùng kiểu dữ liệu được đặt liên tiếp nhau trong một vùng nhớ, chúng ta có thể ngay lập tức truy xuất đến một phần tử của dãy đó thông qua chỉ số của mỗi phần tử.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" width=\"690\" height=\"287\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">915x381</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như hình trên, giả sử mình khai báo mảng một chiều có 3 phần tử kiểu <strong>int32_t</strong>, mỗi phần tử sẽ có kích thước <strong>4 bytes</strong>. </p>\n\n<p>Mình lấy ví dụ hệ điều hành tìm thấy vùng nhớ trống đủ chổ chứa 3 phần tử của mảng tại địa chỉ <strong>108</strong>, thì phần tử đầu tiên a1 sẽ có địa chỉ là địa chỉ ô nhớ đầu tiên mà hệ điều hành cấp phát (là <strong>108</strong>). Khi đó, phần tử thứ 2 sẽ có địa chỉ là địa chỉ của phần tử thứ nhất cộng thêm 4 (4 là kích thước kiểu dữ liệu <strong>int32_t</strong>), tương tự cho phần tử thứ 3.</p>\n\n<p>Với kiểu tổ chức dữ liệu này, chúng ta chỉ cần quan tâm đến 2 điều:</p>\n\n<ul>\n<li>Địa chỉ ô nhớ đầu tiên trong mảng.</li>\n<li>Số phần tử của mảng.</li>\n</ul>\n\n<p>Từ đó, chúng ta có thể truy xuất đến toàn bộ phần tử trong mảng.</p>\n\n<h3>Khai báo mảng một chiều</h3>\n\n<p>Chúng ta có nhiều cách để khai báo mảng một chiều khác nhau:</p>\n\n<ul><li>Khai báo nhưng không khởi tạo các phần tử:</li></ul>\n\n<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[&lt;number_of_elements&gt;];</code></p>\n\n<p>Với cách khai báo này, chúng ta cần ghi rõ cho <strong>compiler</strong> biết số lượng phần tử mà bạn cần sử dụng đặt trong cặp dấu ngoặc vuông. Ví dụ:</p>\n\n<pre><code>int32_t age_of_students[30];</code></pre>\n\n<p>Mình vừa tạo ra một mảng dữ liệu kiểu <strong>int32_t</strong> để lưu trữ số tuổi của 30 sinh viên trong 1 lớp học.</p>\n\n<p>Vì mình chưa khởi tạo giá trị cụ thể cho 30 phần tử trong mảng, nên khi truy xuất đến giá trị của từng phần tử, chúng ta có thể nhận được giá trị khởi tạo mặc định của kiểu int32_t là 0 hoặc giá trị rác (tùy vào <strong>compiler</strong>).</p>\n\n<ul><li>Khai báo và khởi tạo giá trị cho mỗi phần tử:</li></ul>\n\n<p><code>&lt;data_type&gt; &lt;name_of_array&gt;[] = { &lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; };</code></p>\n\n<p>Với cách khai báo này, chúng ta không cần thiết xác định trước số phần tử của mảng. Compiler sẽ xác định số phần tử thông qua số lượng giá trị mà bạn khởi tạo.</p>\n\n<pre><code>char my_string[] = { 'H', 'e', 'l', 'l', 'o', '\\0' };</code></pre>\n\n<p>Mình vừa khai báo một mảng phần tử với kiểu kí tự (Chúng ta sẽ đi sâu hơn về chuỗi kí tự trong những bài học sau), <strong>compiler</strong> nhìn vào số lượng kí tự mình khởi tạo và cấp phát 6 ô nhớ liên tục nhau trên vùng nhớ còn trống.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/1.png?raw=true\" width=\"690\" height=\"223\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">912x296</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p><em>Với kiểu kí tự, mỗi phần tử chỉ chiếm 1 byte, nên chúng ta có 6 bytes liên tiếp nhau để chứa được chuỗi kí tự trên.</em></p>\n\n<h3>Truy xuất đến các phần tử trong mảng một chiều</h3>\n\n<p>Sau khi biết cách khai báo mảng một chiều (<strong>array</strong>), điều tiếp theo chúng ta cần quan tâm là làm thế nào để truy xuất đến một phần tử trong mảng.</p>\n\n<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng. Phần tử đầu tiên của mảng mang chỉ số <strong>0</strong>, phần tử cuối cùng của mảng có <strong>N</strong> phần tử sẽ có chỉ số <strong>(N - 1)</strong>.</p></blockquote>\n\n<p>Cú pháp truy xuất phần tử trong mảng một chiều:</p>\n\n<p><code>&lt;name_of_array&gt;[index];</code></p>\n\n<p>Trong đó, <strong>index</strong> là một số nguyên đại diện cho chỉ số của phần tử trong mảng một chiều.</p>\n\n<p>Ví dụ với một mảng một chiều kiểu int32_t có 5 phần tử được khai báo như sau:</p>\n\n<pre><code>int32_t values[] = { 2, 4, 6, 8, 10 };</code></pre>\n\n<p>Khi đó, các phần tử trong mảng lần lượt là:</p>\n\n<pre><code>values[0]; //2\nvalues[1]; //4\nvalues[2]; //6\nvalues[3]; //8\nvalues[4]; //10</code></pre>\n\n<h5>Giải thích cho việc tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0:</h5>\n\n<blockquote><p>Mỗi phần tử trong mảng sẽ đi kèm với một chỉ số cho biết vị trí của phần tử có khoảng cách bao nhiêu so với phần tử đầu tiên của mảng.</p></blockquote>\n\n<p>Sau khi khai báo mảng một chiều, địa chỉ của mảng ứng với địa chỉ của phần tử đầu tiên trong mảng. Vị trí của các phần tử sẽ được tính dựa trên công thức:</p>\n\n<p><code>index = (address_of_current_element - address_of_the_first_element) / sizeof(data_type);</code></p>\n\n<p>Lấy lại ví dụ mảng có 3 phần tử kiểu int32_t như trong mục <strong>Mảng một chiều (Array)</strong></p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/0.png?raw=true\" width=\"690\" height=\"287\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">915x381</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Cho rằng địa chỉ của mảng <strong>a</strong> (cũng là địa chỉ của phần tử a1) là <strong>108</strong>. Vậy chỉ số của phần tử đầu tiên a1 là:</p>\n\n<p><code>index_of_a1 = (address_of_a1 - address_of_the_first_element) / sizeof(int32_t);</code></p>\n\n<p><code>index_of_a1 = (108 - 108) / 4 = 0;</code></p>\n\n<p>Như vậy, phần tử đầu tiên của mảng có chỉ số là <strong>0</strong>.</p>\n\n<p>Đây chỉ là phần mình làm rõ cho các bạn tại sao chỉ số của mảng một chiều trong C/C++ bắt đầu từ 0 và kết thúc tại <code>(số_phần_tử - 1)</code>. Các bạn không cần quan tâm đến việc tính toán chỉ số của mỗi phần tử mà <strong>compiler</strong> sẽ làm giúp bạn.</p>\n\n<h5>In ra giá trị của tất cả phần tử trong mảng</h5>\n\n<p>Để quản lý mảng một chiều, chúng ta cần biết:</p>\n\n<ul>\n<li>Địa chỉ phần tử đầu tiên của mảng. (Có thể có được thông qua <code>&lt;array_name&gt;[0]</code>)</li>\n<li>Số lượng phần tử của mảng.</li>\n</ul>\n\n<p>Mình sẽ thực hiện một phương pháp tổng quát để lấy ra số lượng phần tử của mảng:</p>\n\n<p><code>&lt;number_of_elements&gt; = sizeof(&lt;name_of_array&gt;) / sizeof(&lt;type_of_array&gt;);</code></p>\n\n<p>Chúng ta sử dụng toán tử <strong>sizeof</strong>, truyền vào tên của mảng chúng ta sẽ nhận được giá trị là tổng kích thước bộ nhớ sử dụng cho mảng, chia cho kích thước của một phần tử của mảng chúng ta sẽ có được số lượng phần tử. Ví dụ:</p>\n\n<pre><code>double d_values[] = { 2.08, 1.32, 6, 4.1, 12, 999.99 };\nint32_t num_of_elements = sizeof(d_values) / sizeof(double);\n\n//another way\nnum_of_elements = sizeof(d_values) / sizeof(d_values[0]);\n\ncout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt;&lt; endl;</code></pre>\n\n<p>Kết quả chương trình sẽ cho ta thấy mảng có 6 phần tử:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/2.png?raw=true\" width=\"670\" height=\"339\"></p>\n\n<p>Như cách thông thường, chúng ta thường định nghĩa trước số lượng phần tử tối đa mà mảng một chiều có thể chứa như sau:</p>\n\n<pre><code>#define ARRAY_SIZE 100\n\n//........\n\nfloat f_values[ARRAY_SIZE];</code></pre>\n\n<p>Lúc này, chúng ta chỉ cần sử dụng <code>ARRAY_SIZE</code> như là số lượng phần tử của mảng. Nhưng cách này có thể là hao tốn bộ nhớ khi số lượng phần tử thực sự cần sử dụng không đạt đến con số <code>ARRAY_SIZE</code>. Vì thế, mình thường tính số phần tử của mảng theo cách tổng quát mà mình trình bày ở trên.</p>\n\n<h5>Điều gì xảy ra nếu chúng ta truy xuất mảng bằng chỉ số lớn hơn số lượng phần tử?</h5>\n\n<p>Các bạn thử chạy đoạn chương trình sau:</p>\n\n<pre><code>int32_t arr[] = { 1, 2, 3, 4, 5 }; //create an array with 5 elements\ncout &lt;&lt; arr[100] &lt;&lt; endl;</code></pre>\n\n<p>Ở lần chạy đầu tiên của đoạn chương trình trên, máy mình cho ra kết quả:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/3.png?raw=true\" width=\"668\" height=\"337\"></p>\n\n<p>Thử chạy lại chương trình nhiều lần khác nhau, các bạn sẽ thấy được nhiều giá trị khác nhau. Những giá trị này ở đâu ra?</p>\n\n<p>Đó chính là những giá trị thuộc vùng nhớ mà chương trình khác đang quản lý.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true\" class=\"lightbox\" title=\"4.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/4.png?raw=true\" width=\"690\" height=\"274\"><div class=\"meta\">\n<span class=\"filename\">4.png?raw=true</span><span class=\"informations\">968x385</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Có thể sau khi các chương trình khác sử dụng vùng nhớ đó và trả lại cho hệ điều hành quản lý, giá trị của ô nhớ vẫn còn giữ nguyên, nên khi truy cập mảng với chỉ số vượt quá số lượng phần tử tối đa, chúng ta nhận được những giá trị không có ý nghĩa.</p>\n\n<p>Trường hợp xấu hơn có thể xảy ra là khi các chương trình khác đang sử dụng vùng nhớ mà bạn truy cập đến, Visual studio sẽ đưa ra cảnh báo về việc xung đột vùng nhớ và cho dừng chương trình của bạn.</p>\n\n<p><img src=\"https://raw.githubusercontent.com/nguyenchiemminhvu/CPP-Tutorial/master/5-kieu-du-lieu-mang/5-0-mang-mot-chieu/5.png\" width=\"558\" height=\"314\"></p>\n\n<p>Vì thế việc quản lý số lượng phần tử của mảng là rất quan trọng.</p>\n\n<h3>Nhập dữ liệu cho mảng một chiều (Array input)</h3>\n\n<p>Giả sử chúng ta có mảng một chiều dùng để chứa 10 số nguyên (có chỉ số từ 0 đến 9). Để nhập dữ liệu cho từng phần tử trong mảng này, chúng ta có thể sử dụng đối tượng <strong>cin</strong> trong thư viện <strong>iostream</strong> mà các bạn đã được học.</p>\n\n<p><code>cin &gt;&gt; &lt;name_of_array&gt;[index];</code></p>\n\n<p>Trong đó, <strong>index</strong> là chỉ số của phần tử của mảng mà chúng ta cần nhập giá trị từ bàn phím và đưa vào phần tử.</p>\n\n<pre><code>int32_t arr[10];\nfor(int32_t index = 0; index &lt;= 9; index++)\t{\n\tcin &gt;&gt; arr[index];\n}</code></pre>\n\n<p>Mình vừa sử dụng vòng lặp <strong>for</strong> (vì mình biết được số lượng phần tử của mảng nên mình biết cần lặp bao nhiêu lần), trong vòng lặp <strong>for</strong> này, mình sử dụng biến <strong>index</strong> và cho nó di chuyển từ giá trị <strong>0 đến 9</strong> tương ứng với từng chỉ số của các phần tử trong mảng. Với mỗi giá trị <strong>index</strong> được gán, mình thực hiện nhập dữ liệu từ bàn phím bằng đối tượng <strong>cin</strong> cho phần tử <strong>arr[index]</strong>.</p>\n\n<h5>Một cách tổng quát hơn để nhập dữ liệu cho mảng một chiều</h5>\n\n<p>Ở ví dụ trên, mình cho mảng số nguyên có số lượng phần tử cố định là 10. Đối với mảng một chiều có số lượng phần tử khác nhau thì ta làm thế nào?</p>\n\n<p>Việc đầu tiên chúng ta cần làm là tìm ra số lượng phần tử của mảng. Ví dụ:</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\tcin &gt;&gt; i_values[index];\t\n}</code></pre>\n\n<p>Với cách này, chúng ta có thể không cần quan tâm đến số lượng phần tử hiện tại của mảng, mà mình để <strong>compiler</strong> tính giúp mình.</p>\n\n<p>Mình cho biến index chạy từ 0 đến (num_of_elements - 1) vì như mình đã nói ở trên, mảng một chiều có chỉ số bắt đầu từ 0 đến <code>số_lượng_phần_tử</code> trừ đi 1.</p>\n\n<h5>Đưa ra nhắc nhở khi nhập dữ liệu cho mảng</h5>\n\n<p>Chúng ta nên thông báo cho người dùng biết là chúng ta đang nhập dữ liệu cho phần tử nào trong mảng.</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\tcout &lt;&lt; \"Value of element \" &lt;&lt; index &lt;&lt; \": \";\n\tcin &gt;&gt; i_values[index];\t\n}</code></pre>\n\n<p>Như vậy, người dùng sẽ tránh được việc nhập nhầm thứ tự dữ liệu cho các phần tử trong mảng.</p>\n\n<p>Ngoài việc dùng đối tượng cin, chúng ta cũng có thể gán trực tiếp giá trị cho các phần tử trong mảng thông qua toán tử gán.</p>\n\n<pre><code>int32_t i_values[100];\nint32_t num_of_elements = sizeof(i_values) / sizeof(int32_t);\n\nfor(int32_t index = 0; index &lt;= (num_of_elements - 1); index++)\t{\n\ti_values[index] = index + 1;\n}</code></pre>\n\n<h5>Nhập dữ liệu cho ô nhớ có chỉ số vượt quá số lượng phần tử</h5>\n\n<p>Cũng tương tự như việc bạn truy xuất đến phần tử với chỉ số vượt ngoài tầm số lượng phần tử trong mảng, Visual studio sẽ đưa ra cảnh báo xung đột vùng nhớ và dừng chương trình.</p>\n\n<h2></h2>\n\n<h3>Tổng kết</h3>\n\n<p>Cùng nhìn lại vấn đề mình đặt ra ngay từ đầu bài học, mảng một chiều đã giúp chúng ta tiết kiệm thời gian hơn khi mà chỉ với 1 dòng lệnh khai báo mảng một chiều, chúng ta có thể quản lý 30 vùng nhớ liên tiếp nhau dùng để lưu trữ điểm của cả 30 sinh viên. Chúng ta cũng có thể biết được điểm số nào là của sinh viên nào thông qua chỉ số của mảng đó.</p>\n\n<p>Mảng một chiều đã khắc phục nhiều nhược điểm của việc khai báo các biến đơn lẻ. Tuy nhiên, nó cũng có một số nhược điểm riêng như việc dư thừa vùng nhớ khi không dùng hết số lượng ô nhớ đã cấp phát, hoặc số lượng phần tử được yêu cầu quá lớn nên hệ điều hành không đủ khả năng cấp phát. Chúng ta sẽ tìm cách giải quyết những vấn đề này trong những bài học sau.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>Với yêu cầu đặt ra ban đầu, giảng viên cần biết điểm số cao nhất của 30 sinh viên trong lớp, đồng thời muốn biết điểm cao nhất là của sinh viên có số thứ tự bao nhiêu. Bạn hãy sử dụng mảng 1 chiều để giải quyết vấn đề này. (Điểm của sinh viên được nhập từ bàn phím)</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.db023247931fdd0e22e4bdf7ad1c7ff1.json"}}}</script><script src="/phenomic.browser.89bd9961942b8ff9392f.js"></script></body></html>