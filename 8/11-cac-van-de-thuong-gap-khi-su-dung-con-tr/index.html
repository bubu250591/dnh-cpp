<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/phenomic.browser.6197dc9ae9d5f1cfb86f.css" /><meta data-react-helmet="true" property="og:site_name" content="dnh-cpp"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="8.11 Các vấn đề thường gặp khi sử dụng con trỏ"/><meta data-react-helmet="true" property="og:url" content="/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/"/><meta data-react-helmet="true" property="og:description" content="} } } char  getName(char fullname) { } int main()	{ } } } } int main()	{ } int main() { 	int \*p = newIntValue(0); } int \*pTemp = ptr; ptr…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="8.11 Các vấn đề thường gặp khi sử dụng con trỏ"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="} } } char  getName(char fullname) { } int main()	{ } } } } int main()	{ } int main() { 	int \*p = newIntValue(0); } int \*pTemp = ptr; ptr…"/><meta data-react-helmet="true" name="description" content="} } } char  getName(char fullname) { } int main()	{ } } } } int main()	{ } int main() { 	int \*p = newIntValue(0); } int \*pTemp = ptr; ptr…"/><title data-react-helmet="true">8.11 Các vấn đề thường gặp khi sử dụng con trỏ</title><link data-react-helmet="true" rel="icon" type="image/png" sizes="144x144" href="//daynhauhoc.s3.amazonaws.com/36ee34de6c73f268424fceaef858c5428d8fb2a976.ico"/><link data-react-helmet="true" rel="icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/><link data-react-helmet="true" rel="apple-touch-icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/></head><body><div id="phenomic"><div class="_2lE56" data-reactroot="" data-reactid="1" data-react-checksum="76485145"><!-- react-empty: 2 --><div class="_1Ih7a" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><div class="_1G2C6 _3fTO1" data-reactid="7"><div class="aCd9j" data-reactid="8"><a href="https://github.com/daynhauhoc/cppcoban" target="_blank" data-hint="Fork on Github" class="hint--bottom-left _2dICi" data-reactid="9"><span class="SVGInline" data-reactid="10"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span></a><a href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank" data-hint="Share on Facebook" class="hint--bottom-left _2dICi" data-reactid="11"><span class="SVGInline" data-reactid="12"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="430.113px" height="430.114px" viewBox="0 0 430.113 430.114" style="enable-background:new 0 0 430.113 430.114;"
	 xml:space="preserve">
<g>
	<path id="Facebook" d="M158.081,83.3c0,10.839,0,59.218,0,59.218h-43.385v72.412h43.385v215.183h89.122V214.936h59.805
		c0,0,5.601-34.721,8.316-72.685c-7.784,0-67.784,0-67.784,0s0-42.127,0-49.511c0-7.4,9.717-17.354,19.321-17.354
		c9.586,0,29.818,0,48.557,0c0-9.859,0-43.924,0-75.385c-25.016,0-53.476,0-66.021,0C155.878-0.004,158.081,72.48,158.081,83.3z"/>
</g>
</svg></span></a></div></div><article class="markdown-body" data-reactid="13"><h1 data-reactid="14">8.11 Các vấn đề thường gặp khi sử dụng con trỏ</h1><div data-reactid="15"><div class="phenomic-BodyContainer" data-reactid="16"><h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>
<p>Trong bài học này, chúng ta sẽ cùng tìm hiểu về những lỗi thường gặp ở những bạn mới học lập trình khi sử dụng con trỏ trong chương trình. Những lỗi này thường xuất hiện do các bạn mới học chưa hiểu rõ cách quản lý vùng nhớ trong chương trình, do cách tổ chức chương trình chưa hợp lý, hoặc do sơ ý... Trong đó, một số lỗi không nghiêm trọng sẽ không gây ảnh hưởng nhiều đến hoạt động của chương trình, một số lỗi nghiêm trọng có thể làm chương trình phải kết thúc ngay lập tức. Dù lỗi gây có có nghiêm trọng hay không, chúng ta chủ động ngăn chặn thì vẫn tốt hơn.</p>
<h5>Con trỏ trỏ đến vùng nhớ nằm ngoài phạm vi chương trình đang quản lý</h5>
<p>Mình có đoạn chương trình như sau:</p>
<p></p><pre><code class="lang-auto">int main()
{
	//allocate memory on Heap
	int *p = new int;
<pre><code>//p point to somewhere
p -= 10000;

//dereference to the area of other program
*p = 1;

system("pause");
return 0;
</code></pre>
<p>}</code></pre></p>
<p>Đầu tiên, chương trình cấp phát một vùng nhớ có kích thước <strong>4 bytes</strong> trên phân vùng <strong>Heap</strong> và cho con trỏ nắm giữ địa chỉ trả về của toán tử <strong>new</strong>. Sau đó, mình lại cho con trỏ p trỏ lung tung trên bộ nhớ ảo và cố tình thay đổi nội dung bên trong vùng nhớ mới trỏ đến. Khi để ở chế độ <strong>Debug</strong>, Visual Studio sẽ chặn chương trình của chúng ta lại và đưa ra cảnh báo. Nhưng nếu chúng ta chuyển sang chế độ <strong>Release</strong> và <strong>build</strong> ra sản phẩm thành một phần mềm, chạy phần mềm này sẽ gây <strong>crash</strong> và phần mềm phải kết thúc ngay lập tức.</p>
<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/0.png?raw=true" class="lightbox" title="0.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/0.png?raw=true" width="690" height="302"><div class="meta">
<span class="filename">0.png?raw=true</span><span class="informations">1233x540</span><span class="expand"></span>
</div></a></div></p>
<p>Thật ra cũng không có ai rãnh rỗi đến mức gán địa chỉ sai cho con trỏ, điều mà mình muốn nói ở đây là khi chương trình chúng ta viết bị <strong>crash</strong> khi chạy, có thể lỗi này đến từ việc gán địa chỉ không hợp lý.</p>
<p>Trong thực tế, lỗi này sẽ xuất hiện dưới một hình thức khác. Ví dụ:</p>
<p></p><pre><code class="lang-auto">int main()
{
	int *p = new int[10];
	cout &lt;&lt; p &lt;&lt; endl;
<pre><code>delete[] p;

cout &#x26;lt;&#x26;lt; p &#x26;lt;&#x26;lt; endl;

_sleep(10000);

for (int i = 0; i &#x26;lt; 10; i++)
    cin &#x26;gt;&#x26;gt; p[i];

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Chương trình này yêu cầu cấp phát 1 dãy địa chỉ có kích thước <strong>40 bytes trên Heap</strong>. Sau đó in ra địa chỉ của vùng nhớ vừa được cấp phát thành công. Tiếp theo, mình không muốn sử dụng vùng nhớ này nữa nên mình trả lại cho hệ điều hành thông qua toán tử <strong>delete</strong>. Trên thực tế, có thể mình sẽ không giải phóng vùng nhớ ngay lập tức mà sử dụng xong rồi mới giải phóng nó đi. Sau khi giải phóng vùng nhớ đó, mình in ra lại địa chỉ mà con trỏ p đang nắm giữ thì thấy p vẫn đang trỏ đến địa chỉ mà mình đã giải phóng. Vậy là chúng ta đã gặp phải lỗi mà mình đưa ra ở ví dụ đầu tiên trong bài học này, đó là con trỏ trỏ đến một vùng nhớ không chịu sử quản lý của chương trình. Lúc này, mình chưa <strong>dereference</strong> đến vùng nhớ đó ngay lập tức mà vẫn cho chương trình tiếp tục thực thi. Cuối cùng, mình không nhớ rằng vùng nhớ ban đầu đã được giải phóng ở đâu đó nên vẫn tiếp tục sử dụng bằng cách nhập dữ liệu vào đó thông qua con trỏ p.</p>
<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/1.png?raw=true" class="lightbox" title="1.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/1.png?raw=true" width="690" height="290"><div class="meta">
<span class="filename">1.png?raw=true</span><span class="informations">1281x539</span><span class="expand"></span>
</div></a></div></p>
<p>Kết quả là phần mềm đang chạy thì bị <strong>crash</strong> vì có thể hệ điều hành đã cấp phát vùng nhớ đã được giải phóng cho phần mềm khác sử dụng. Khi chạy chương trình dưới chế độ Debug trong Visual Studio, lỗi này có thể không phát hiện được do nó vẫn chạy bình thường mà không có thông báo mà cũng không bị crash. Điều này làm chúng ta tưởng rằng chương trình hoạt động tốt, và <strong>build</strong> nó ra thành phần mềm lỗi.</p>
<p>Để khắc phục trường hợp này, chúng ta nên cho con trỏ quản lý vùng nhớ được cấp phát trỏ về <strong>NULL</strong> ngay sau khi giải phóng vùng nhớ đó.</p>
<p></p><pre><code class="lang-auto">int main()
{
	int *p = NULL;
	p = new int[10];
	cout &lt;&lt; p &lt;&lt; endl;
<pre><code>delete[] p;
p = NULL;

cout &#x26;lt;&#x26;lt; p &#x26;lt;&#x26;lt; endl;

_sleep(10000);

if (p != NULL) {

    for (int i = 0; i &#x26;lt; 10; i++)
        cin &#x26;gt;&#x26;gt; p[i];
}

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Bất cứ khi nào sử dụng vùng nhớ thông qua con trỏ, chúng ta cũng nên kiểm tra xem con trỏ có khác NULL hay không. Nếu con trỏ khác NULL thì chúng ta hiểu rằng vùng nhớ đó vẫn chưa được giải phóng. Đây chỉ là một cách quy ước mình tự đặt ra giúp cách viết chương trình của mình an toàn hơn, cách của mình có thể khác với một số lập trình viên khác.</p>
<p>Nhưng lỗi này còn có thể xuất hiện dưới một hình thức khác nữa. Đó là sử dụng 2 con trỏ cùng trỏ đến một vùng nhớ trong chương trình.</p>
<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
<p>char <em> getName(char </em>fullname) {

if (fullName == NULL)
return NULL;

char *pTemp = strrchr(fullname, ' ');</p>
<pre><code>if (pTemp == NULL)
    return fullname;
else
    return pTemp + 1;
</code></pre>
<p>}</p>
<p>int main()	{</p>
<pre><code>char *fullName = new char[50];

cout &#x26;lt;&#x26;lt; "Enter your full name: ";
cin.getline(fullName, 50);

cout &#x26;lt;&#x26;lt; "Your last name is: ";
char *name = getName(fullName);

delete[] fullName;

cout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Đoạn chương trình này thực hiện công việc yêu cầu người dùng nhập vào đầy đủ họ và tên, sau đó in ra tên mà người dùng vừa nhập vào (bỏ qua họ và tên đệm). Nhưng trước đó, mình cần yêu cầu cấp phát một vùng nhớ trên <strong>Heap</strong> đủ để người dùng nhập vào họ tên.</p>
<p>Cách hoạt động của hàm getName như sau:</p>
<p>(1) Nhận vào đối số là địa chỉ của một địa chỉ của một chuỗi kí tự, trong trường hợp này là full name của người dùng.<br>(2) Sử dụng hàm <strong>strrchr</strong> trong thư viện <strong>cstring</strong> để trả về địa chỉ xuất hiện kí tự khoảng trắng cuối cùng trong chuỗi kí tự.<br>(3) Nếu không có kí tự khoảng trắng thì trả về địa chỉ đầu tiên của chuỗi kí tự (cho rằng người dùng chỉ nhập tên chứ không nhập họ và tên đệm), nếu có xuất hiện khoảng trắng thì trả về địa chỉ của phần tử đứng sau khoảng trắng.</p>
<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/2.png?raw=true" class="lightbox" title="2.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/2.png?raw=true" width="690" height="259"><div class="meta">
<span class="filename">2.png?raw=true</span><span class="informations">958x360</span><span class="expand"></span>
</div></a></div></p>
<p>Như chúng ta thấy, địa chỉ của tên người dùng được trả về từ hàm <strong>getName</strong> cũng thuộc phạm vi vùng nhớ được cấp phát và đang được quản lý thông qua con trỏ <strong>fullName</strong>. Tuy nhiên, trong đoạn chương trình trên, lập trình viên này đã nghĩ rằng sau khi sử dụng xong hàm getName thì không cần sử dụng đến con trỏ <strong>fullName</strong> nữa, vậy là <strong>delete</strong> luôn vùng nhớ mà con trỏ <strong>fullName</strong> đang nắm giữ, dẫn đến việc con trỏ <strong>name</strong> đã trỏ tới một vùng nhớ không còn thuộc quyền quản lý của chương trình nữa. Và kết quả cho ra không đúng với mong đợi:</p>
<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/3.png?raw=true" width="579" height="384"></p>
<p>Tuy nhiên, khi mình chạy chương trình trên, kết quả vẫn đúng. Đó là do mình sử dụng vùng nhớ đó ngay sau khi trả lại cho hệ điều hành. Hệ điều hành lúc này vẫn chưa tác động gì đến vùng nhớ đã được giải phóng, hoặc nếu đã có cấp phát cho chương trình khác thì chương trình đó vẫn chưa thay đổi nội dung trong phạm vi này. Bây giờ mình giả sử chúng ta thực thi công việc khác, sau một vài giây sau mới cần in ra kết quả thì sẽ dễ phát hiện lỗi hơn:</p>
<p></p><pre><code class="lang-auto">int main()	{
<pre><code>char *fullName = new char[50];

cout &#x26;lt;&#x26;lt; "Enter your full name: ";
cin.getline(fullName, 50);

cout &#x26;lt;&#x26;lt; "Your last name is: ";
char *name = getName(fullName);

delete[] fullName;

_sleep(5000);
cout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;

return 0;
</code></pre>
<p>}</code></pre></p>
<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/4.png?raw=true" width="579" height="384"></p>
<p>Để khắc phục trường hợp này, chúng ta cần xác định rằng khi nào thực sự không còn sử dụng đến vùng nhớ nào đó thì mới giải phóng. Sửa lại đoạn chương trình trên như sau:</p>
<p></p><pre><code class="lang-auto">int main()	{
<pre><code>char *fullName = new char[50];

cout &#x26;lt;&#x26;lt; "Enter your full name: ";
cin.getline(fullName, 50);

cout &#x26;lt;&#x26;lt; "Your last name is: ";
char *name = getName(fullName);
cout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;

delete[] fullName;
fullName = NULL;

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Hoặc chúng ta vẫn muốn sử dụng tiếp vùng nhớ quản lý bởi con trỏ <strong>fullName</strong> mà không muốn sử dụng đến con trỏ <strong>name</strong> nữa, chúng ta nên sửa lại như sau:</p>
<p></p><pre><code class="lang-auto">int main()	{
<pre><code>char *fullName = new char[50];

cout &#x26;lt;&#x26;lt; "Enter your full name: ";
cin.getline(fullName, 50);

cout &#x26;lt;&#x26;lt; "Your last name is: ";
char *name = getName(fullName);
cout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;

name = NULL;

//keep using fullName
//and then deallocate it

delete[] fullName;

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Con trỏ <strong>name</strong> chỉ trỏ đến địa chỉ bên trong vùng nhớ được cấp phát cho con trỏ <strong>fullName</strong>, nên chúng ta không nên sử dụng toán tử <strong>delete</strong> cho con trỏ <strong>name</strong>.</p>
<p>Trường hợp con trỏ trỏ đến vùng nhớ không chịu sự quản lý của chương trình cũng thường xuất hiện khi trả về địa chỉ của biến cục bộ trong hàm.</p>
<p></p><pre><code class="lang-auto">int * newIntValue(int value = 0)
{
	int n = value;
	return &amp;n;
}
<p>int main()	{</p>
<pre><code>int *pInt = newIntValue(0);

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Như các bạn đã biết, biến cục bộ sẽ bị đưa ra khỏi <strong>Stack</strong> khi ra khỏi phạm vi khối lệnh. Dó đó, địa chỉ của biến n trong hàm <strong>newIntValue</strong> vẫn được trả về trước khi bị hủy. Chúng ta nên thay bằng <strong>Dynamic memory allocation:</strong></p>
<p></p><pre><code class="lang-auto">int * newIntValue(int value = 0)
{
	return new int(value);
}
<p>int main()
{
int *p = newIntValue(0);

delete p;

return 0;
}</code></pre></p>
<h5>memory leak</h5>
<p><strong>Memory leak</strong> là trường hợp cấp phát vùng nhớ cho chương trình (thường là cấp phát trên <strong>Heap</strong>) nhưng vùng nhớ không được sử dụng hoặc không được giải phóng. Điều này làm giảm dung lượng bộ nhớ có thể sử dụng được cho những chương trình khác, khiến các chương trình hoạt động chậm hơn hoặc có thể làm crash chương trình. </p>
<p>Đây là một ví dụ thường gặp ở những lập trình viên mới học về kỹ thuật <strong>Dynamic memory allocation:</strong></p>
<p></p><pre><code class="lang-auto">int *ptr = new int[10];
//................
ptr = NULL;</code></pre>
<p>Trong đoạn chương trình này, lập trình viên tự ý cho con trỏ ptr trỏ đi nơi khác. Điều này dẫn đến việc vùng nhớ được cấp phát trước đó không thể quản lý được nữa. Muốn quản lý một vùng nhớ được cấp phát trên Heap, chúng ta cần sử dụng ít nhất một con trỏ. Nhưng trong trường hợp này, không còn con trỏ nào được dùng để quản lý vùng nhớ đã được cấp phát. Do đó, vùng nhớ được cấp phát chỉ có thể được giải phóng khi toàn bộ chương trình kết thúc.</p>
<p>Để khắc phục trường hợp này, chúng ta cần có một con trỏ khác thay thế vị trí của con trỏ <strong>ptr</strong> trước khi cho con trỏ <strong>ptr</strong> trỏ đi nơi khác:</p>
<p></p><pre><code class="lang-auto">int *ptr = new int[10];
//.................
<p>int *pTemp = ptr;
ptr = NULL;</code></pre></p>
<p>Việc <strong>resize</strong> kích thước của vùng nhớ cũng có thể gây ra lỗi <strong>memory leak</strong> nếu sơ ý:</p>
<p></p><pre><code class="lang-auto">void resizeArray(int *&amp;p, int oldLength, int newLength)
{
	int *pTemp = p;
	p = allocateArray(newLength);
	
	//copy data
	if(oldLength &lt; newLength)
	{
		for(int i = 0; i &lt; oldLength; i++)
		{
			p[i] = pTemp[i];
		}
	}
	else
	{
		for(int i = 0; i &lt; newLength; i++)
		{
			p[i] = pTemp[i];
		}
	}
}
<p>int main()	{</p>
<pre><code>int length = 10;
int *p = new int[length];

int newLength = 20;
resizeArray(p, length, newLength);

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Khi cấp phát lại vùng nhớ, con trỏ p được gán vào địa chỉ mới, vùng nhớ ban đầu được con trỏ <strong>pTemp</strong> quản lý, nhưng khi ra khỏi hàm thì con trỏ pTemp bị hủy (vì <strong>pTemp</strong> cũng là biến cục bộ, được cấp phát trên <strong>Stack</strong>). Như vậy, vùng nhớ cũ không còn được quản lý nữa.</p>
<p>Chúng ta nên sửa lại đoạn chương trình trên như sau:</p>
<p></p><pre><code class="lang-auto">void resizeArray(int *&amp;p, int oldLength, int newLength)
{
	int *pTemp = p;
	p = allocateArray(newLength);
	
	//copy data
	if(oldLength &lt; newLength)
	{
		for(int i = 0; i &lt; oldLength; i++)
		{
			p[i] = pTemp[i];
		}
	}
	else
	{
		for(int i = 0; i &lt; newLength; i++)
		{
			p[i] = pTemp[i];
		}
	}
	
	delete[] pTemp;
}
<p>int main()	{</p>
<pre><code>int length = 10;
int *p = new int[length];

int newLength = 20;
resizeArray(p, length, newLength);

delete[] p;

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Còn một trường hợp thường thấy nữa, đó là việc sử dụng sai toán tử delete cho con trỏ:</p>
<p></p><pre><code class="lang-auto">int main()	{
<pre><code>int *p = new int[10];

delete p;

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Như các bạn thấy, chúng ta yêu cầu cấp phát một dãy vùng nhớ cho 10 phần tử kiểu <strong>int</strong>, nhưng khi giải phóng thì sử dụng toán tử <strong>delete</strong> để giải phóng một biến đơn. Visual Studio không báo lỗi cho trường hợp này, do đó lỗi này thường cũng khó nhận ra. Chúng ta nên sửa lại như sau:</p>
<p></p><pre><code class="lang-auto">int main()	{
<pre><code>int *p = new int[10];

delete[] p;

return 0;
</code></pre>
<p>}</code></pre></p>
<hr>
<h3>Tổng kết</h3>
<p>Trong bài học này, chúng ta đã cùng tìm hiểu một số nguyên nhân gây ra lỗi khi sử dụng con trỏ trong ngôn ngữ C++. Đây là một số lỗi thường gặp ở những người mới học lập trình C++. Như các bạn thấy, việc quản lý vùng nhớ một cách thủ công khá là phức tạp. Trong chuẩn C++ mới đã có hổ trợ cho chúng ta <strong>Smart Pointer</strong> giúp chúng ta tránh được những lỗi thường gặp này. Chúng ta sẽ tìm hiểu về <strong>Smart Pointer</strong> trong những bài học sau.</p>
<hr>
<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>
<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>
<p><strong><a href="http://www.daynhauhoc.com">www.daynhauhoc.com</a></strong></p>
</div></div></article><div id="discourse-comments" data-reactid="17"></div></div></div></div><div class="_30zqN _1M-6l" data-reactid="18"><ul style="list-style:none;background-color:transparent;margin:0;padding:0;color:#242a31;font-family:lucida grande ,tahoma,verdana,arial,sans-serif;font-size:14px;" data-reactid="19"><li style="position:relative;" data-reactid="20"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="21"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="22"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="23"><svg height="14" width="14" data-reactid="24"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="25"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="26"><div style="line-height:24px;vertical-align:middle;font-size:1.5em;font-weight:300;font-family:Source Sans Pro,sans-serif;margin-bottom:1em;" data-reactid="27">Khóa học C++</div></div></div><span data-reactid="28"><ul style="list-style:none;padding-left:19px;" data-reactid="29"><li style="position:relative;" data-reactid="30"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="31"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="32"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="33"><svg height="14" width="14" data-reactid="34"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="35"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="36"><div style="line-height:24px;vertical-align:middle;" data-reactid="37">Giới thiệu tổng quan khóa học</div></div></div><span data-reactid="38"></span></li><li style="position:relative;" data-reactid="39"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="40"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="41"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="42"><svg height="14" width="14" data-reactid="43"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="44"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="45"><div style="line-height:24px;vertical-align:middle;" data-reactid="46">C++ cơ bản</div></div></div><span data-reactid="47"></span></li><li style="position:relative;" data-reactid="48"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="49"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="50"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="51"><svg height="14" width="14" data-reactid="52"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="53"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="54"><div style="line-height:24px;vertical-align:middle;" data-reactid="55">Cấu trúc rẽ nhánh</div></div></div><span data-reactid="56"></span></li><li style="position:relative;" data-reactid="57"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="58"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="59"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="60"><svg height="14" width="14" data-reactid="61"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="62"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="63"><div style="line-height:24px;vertical-align:middle;" data-reactid="64">Cấu trúc vòng lặp</div></div></div><span data-reactid="65"></span></li><li style="position:relative;" data-reactid="66"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="67"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="68"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="69"><svg height="14" width="14" data-reactid="70"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="71"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="72"><div style="line-height:24px;vertical-align:middle;" data-reactid="73">Nâng cao về biến, kiểu dữ liệu</div></div></div><span data-reactid="74"></span></li><li style="position:relative;" data-reactid="75"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="76"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="77"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="78"><svg height="14" width="14" data-reactid="79"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="80"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="81"><div style="line-height:24px;vertical-align:middle;" data-reactid="82">Kiểu dữ liệu mảng</div></div></div><span data-reactid="83"></span></li><li style="position:relative;" data-reactid="84"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="85"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="86"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="87"><svg height="14" width="14" data-reactid="88"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="89"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="90"><div style="line-height:24px;vertical-align:middle;" data-reactid="91">Kiểu chuỗi kí tự</div></div></div><span data-reactid="92"></span></li><li style="position:relative;" data-reactid="93"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="94"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="95"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="96"><svg height="14" width="14" data-reactid="97"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="98"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="99"><div style="line-height:24px;vertical-align:middle;" data-reactid="100">Cơ bản về Function</div></div></div><span data-reactid="101"></span></li><li style="position:relative;" data-reactid="102"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="103"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="104"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="105"><svg height="14" width="14" data-reactid="106"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="107"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="108"><div style="line-height:24px;vertical-align:middle;" data-reactid="109">Con trỏ</div></div></div><span data-reactid="110"></span></li><li style="position:relative;" data-reactid="111"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="112"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="113"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="114"><svg height="14" width="14" data-reactid="115"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="116"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="117"><div style="line-height:24px;vertical-align:middle;" data-reactid="118">Kiểu dữ liệu tự định nghĩa</div></div></div><span data-reactid="119"></span></li><li style="position:relative;" data-reactid="120"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="121"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="122"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="123"><svg height="14" width="14" data-reactid="124"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="125"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="126"><div style="line-height:24px;vertical-align:middle;" data-reactid="127">Nhập, xuất, streams (Input &amp; Output)</div></div></div><span data-reactid="128"></span></li><li style="position:relative;" data-reactid="129"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="130"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="131"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="132"><svg height="14" width="14" data-reactid="133"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="134"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="135"><div style="line-height:24px;vertical-align:middle;" data-reactid="136">Standard Template Library</div></div></div><span data-reactid="137"></span></li><li style="position:relative;" data-reactid="138"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="139"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="140"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="141"><svg height="14" width="14" data-reactid="142"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="143"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="144"><div style="line-height:24px;vertical-align:middle;" data-reactid="145">Auto pointer</div></div></div><span data-reactid="146"></span></li><li style="position:relative;" data-reactid="147"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="148"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="149"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="150"><svg height="14" width="14" data-reactid="151"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="152"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="153"><div style="line-height:24px;vertical-align:middle;" data-reactid="154">Quản lý mã nguồn</div></div></div><span data-reactid="155"></span></li><li style="position:relative;" data-reactid="156"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="157"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="158"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="159"><svg height="14" width="14" data-reactid="160"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="161"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="162"><div style="line-height:24px;vertical-align:middle;" data-reactid="163">Một số feature trong C++11, C++14</div></div></div><span data-reactid="164"></span></li></ul></span></li></ul></div><div class="_3eRtW" data-reactid="165"><span class="SVGInline" data-reactid="166"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 396.667 396.667" style="enable-background:new 0 0 396.667 396.667;" xml:space="preserve">
<g>
	<g>
		<path d="M17,87.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17C0,80.183,7.65,87.833,17,87.833z"/>
		<path d="M17,215.333h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,215.333,17,215.333z"/>
		<path d="M17,342.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,342.833,17,342.833z"/>
	</g>
</g>
</svg></span></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"title":"Cài đặt Code::blocks để lập trình C++ trên Ubuntu/Linux","route":"0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux","id":24563,"description":"int main() {   std::cout &lt;&lt; \"Hello World!\"; }","__filename":"generated/24563.md","__url":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/","__resourceUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html","__dataUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html.3ad2186767d90d121ec4cf565f5c1dd8.json"},{"title":"Cài đặt Xcode để lập trình C++ trên Mac OS X","route":"0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x","id":24606,"description":"int main() {     std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;     return 0; }","__filename":"generated/24606.md","__url":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/","__resourceUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html","__dataUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html.8c393057c45fd132c8e63270c6b51de9.json"},{"title":"Cài đặt Visual Studio 2015 để lập trình C++ trên Windows","route":"0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows","id":24768,"description":"","__filename":"generated/24768.md","__url":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/","__resourceUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html","__dataUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html.ee5116c3f1d988558f587037fbca2366.json"},{"title":"0.0 Giới thiệu về series tutorial","route":"0/0-gioi-thieu-ve-series-tutorial","id":29402,"description":"Tóm tắt về bản thân  Minh tên Lê Trần Đạt, 28 tuổi, là lập trình viên lập trình nhúng, ngoài làm việc mình thích dạy học online và viết. Tự…","__filename":"generated/29402.md","__url":"/0/0-gioi-thieu-ve-series-tutorial/","__resourceUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html","__dataUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html.078c42a7bcb638e7a6288e3b5eca8db0.json"},{"title":"0.1 Giới thiệu về ngôn ngữ lập trình","route":"0/1-gioi-thieu-ve-ngon-ngu-lap-trinh","id":29425,"description":"","__filename":"generated/29425.md","__url":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/","__resourceUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html","__dataUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html.9809f133b2b8d62313a69257668cb67b.json"},{"title":"0.2 Giới thiệu về ngôn ngữ lập trình C++","route":"0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c","id":29448,"description":"","__filename":"generated/29448.md","__url":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/","__resourceUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html","__dataUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html.c812ae7d3909d89717f7e886ac243ab3.json"},{"title":"0.3 Các công đoạn phát triển của một chương trình C++","route":"0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c","id":29449,"description":"","__filename":"generated/29449.md","__url":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/","__resourceUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html.f0b19108e622a8c6734cb0d5743e5745.json"},{"title":"0.4 Giới thiệu môi trường phát triển ứng dụng C++","route":"0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c","id":29503,"description":"","__filename":"generated/29503.md","__url":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/","__resourceUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html","__dataUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html.2c25af91e3aa61d907d4da959782452c.json"},{"title":"1.0 Viết chương trình đầu tiên","route":"1/0-viet-chuong-trinh-dau-tien","id":29504,"description":"Các bạn sẽ thấy nhiều hàm main có cách khai báo khác nhau. Nhưng với việc bạn là người mới bắt đầu học C++, mình khuyến nghị các bạn nên sử…","__filename":"generated/29504.md","__url":"/1/0-viet-chuong-trinh-dau-tien/","__resourceUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html","__dataUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html.a512d65564a3c061c7f754360a019b46.json"},{"title":"1.1 Cấu trúc cơ bản của một chương trình C++","route":"1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c","id":29527,"description":"\\#include &lt;iostream> using namespace std; int main()\t{ \t// We write some code inside main function. } } / We can put comment everywhere…","__filename":"generated/29527.md","__url":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/","__resourceUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html.8df49c7894cffb0fcf8925108166f28e.json"},{"title":"1.10 Độ ưu tiên của các toán tử","route":"1/10-do-uu-tien-cua-cac-toan-tu","id":29574,"description":"","__filename":"generated/29574.md","__url":"/1/10-do-uu-tien-cua-cac-toan-tu/","__resourceUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html","__dataUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html.7a47c8f2c1a6101a3700bbc2c0ee315e.json"},{"title":"1.2 Lệnh, khối lệnh, từ khóa","route":"1/2-lenh-khoi-lenh-tu-khoa","id":29575,"description":"Những dòng lệnh bên trong thân hàm main. (Có thể có hoặc không) Những dòng comment. (Có thể có hoặc không) Tích hợp thư viện và không gian…","__filename":"generated/29575.md","__url":"/1/2-lenh-khoi-lenh-tu-khoa/","__resourceUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html","__dataUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html.7475fb0565b3dc36b5f6c2b16530378c.json"},{"title":"1.3 Sử dụng các lệnh liên quan đến xuất dữ liệu","route":"1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu","id":29796,"description":"","__filename":"generated/29796.md","__url":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/","__resourceUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html","__dataUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html.736841fb7471e11813ab50bf85285809.json"},{"title":"1.4 Biến và các kiểu dữ liệu trong C++","route":"1/4-bien-va-cac-kieu-du-lieu-trong-c","id":29935,"description":"float valueFloat = 5.394; // (2) Xin hệ điều hành thêm một vùng nhớ để chứa 1 số thực string myName = \"Minh Vu\"; // (3) Biến này chứa được…","__filename":"generated/29935.md","__url":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/","__resourceUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html","__dataUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html.13c577638c6f91eda9b5863c77255544.json"},{"title":"1.5 Nhập và xuất dữ liệu","route":"1/5-nhap-va-xuat-du-lieu","id":29936,"description":"","__filename":"generated/29936.md","__url":"/1/5-nhap-va-xuat-du-lieu/","__resourceUrl":"/1/5-nhap-va-xuat-du-lieu/index.html","__dataUrl":"/1/5-nhap-va-xuat-du-lieu/index.html.ef6e11684dfcb7f6b992aba2c8e21426.json"},{"title":"1.6 Hằng số","route":"1/6-hang-so","id":29938,"description":"","__filename":"generated/29938.md","__url":"/1/6-hang-so/","__resourceUrl":"/1/6-hang-so/index.html","__dataUrl":"/1/6-hang-so/index.html.f3ddc6bdde6d54a411e4b79e348d0572.json"},{"title":"1.7 Phạm vi của biến","route":"1/7-pham-vi-cua-bien","id":29939,"description":"int value = 1; int main()\t{ }","__filename":"generated/29939.md","__url":"/1/7-pham-vi-cua-bien/","__resourceUrl":"/1/7-pham-vi-cua-bien/index.html","__dataUrl":"/1/7-pham-vi-cua-bien/index.html.7b8e3af7da9532eb3642eb19b7367ed9.json"},{"title":"1.8 Các phép toán cơ bản","route":"1/8-cac-phep-toan-co-ban","id":29944,"description":"int another_variable = 3; variable = another_variable \\* 2; variable = variable + 1; //tăng giá trị biến variable lên 1. variable =…","__filename":"generated/29944.md","__url":"/1/8-cac-phep-toan-co-ban/","__resourceUrl":"/1/8-cac-phep-toan-co-ban/index.html","__dataUrl":"/1/8-cac-phep-toan-co-ban/index.html.e7174a44027feba3c434a4373886310e.json"},{"title":"1.9 Toán tử tăng giảm","route":"1/9-toan-tu-tang-giam","id":29945,"description":"","__filename":"generated/29945.md","__url":"/1/9-toan-tu-tang-giam/","__resourceUrl":"/1/9-toan-tu-tang-giam/index.html","__dataUrl":"/1/9-toan-tu-tang-giam/index.html.17809ba92bb7526bb6d72300ea06de47.json"},{"title":"2.0 Boolean","route":"2/0-boolean","id":29992,"description":"int a = 2, b = 4; a \\* 3 != b; //đúng int main() { \tcout &lt;&lt; true &lt;&lt; endl; \tcout &lt;&lt; false &lt;&lt; endl; } int main() {…","__filename":"generated/29992.md","__url":"/2/0-boolean/","__resourceUrl":"/2/0-boolean/index.html","__dataUrl":"/2/0-boolean/index.html.62f9a66039eff1016579fc6484f79273.json"},{"title":"2.1 Giới thiệu một số cấu trúc điều khiển","route":"2/1-gioi-thieu-mot-so-cau-truc-dieu-khien","id":30007,"description":"int main() { \tcout &lt;&lt; \"This line is printed out.\" &lt;&lt; endl; \texit(-1); //Terminate and return -1 to operating system.  \tcout…","__filename":"generated/30007.md","__url":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/","__resourceUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html","__dataUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html.1d4fd6576fff1c9f6ebbde9296cb7ccf.json"},{"title":"2.2 if statements","route":"2/2-if-statements","id":30008,"description":"} } if(value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; } if (value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; }…","__filename":"generated/30008.md","__url":"/2/2-if-statements/","__resourceUrl":"/2/2-if-statements/index.html","__dataUrl":"/2/2-if-statements/index.html.5fc7b6ae8899008a02ec037a2bf0194c.json"},{"title":"2.3 switch case statements","route":"2/3-switch-case-statements","id":30009,"description":"} }","__filename":"generated/30009.md","__url":"/2/3-switch-case-statements/","__resourceUrl":"/2/3-switch-case-statements/index.html","__dataUrl":"/2/3-switch-case-statements/index.html.51348d4d78f70d37586bb9c11de9341f.json"},{"title":"3.0 Vòng lặp while","route":"3/0-vong-lap-while","id":30011,"description":"} while (score &lt; 4) { \tcount++; \tcout &lt;&lt; \"Learn C++ programming language...\" &lt;&lt; endl; \tcout &lt;&lt; \"Enter your final…","__filename":"generated/30011.md","__url":"/3/0-vong-lap-while/","__resourceUrl":"/3/0-vong-lap-while/index.html","__dataUrl":"/3/0-vong-lap-while/index.html.ca3b73cc92989d89c9963bb13aeaa718.json"},{"title":"3.1 Vòng lặp do-while","route":"3/1-vong-lap-do-while","id":30012,"description":"} const int ID = 123; const int password = 123456; int main() { \t//................. }","__filename":"generated/30012.md","__url":"/3/1-vong-lap-do-while/","__resourceUrl":"/3/1-vong-lap-do-while/index.html","__dataUrl":"/3/1-vong-lap-do-while/index.html.9652947ce2cac76fc244291dfe0e7da9.json"},{"title":"3.2 Vòng lặp for","route":"3/2-vong-lap-for","id":30013,"description":"}","__filename":"generated/30013.md","__url":"/3/2-vong-lap-for/","__resourceUrl":"/3/2-vong-lap-for/index.html","__dataUrl":"/3/2-vong-lap-for/index.html.91200558d1e346b99f3bfe6615546b0d.json"},{"title":"3.3 từ khóa break và continue","route":"3/3-tu-khoa-break-va-continue","id":30014,"description":"} } }","__filename":"generated/30014.md","__url":"/3/3-tu-khoa-break-va-continue/","__resourceUrl":"/3/3-tu-khoa-break-va-continue/index.html","__dataUrl":"/3/3-tu-khoa-break-va-continue/index.html.ce5d9d1bafbf829b21faafe2d437e44f.json"},{"title":"4.0 Sử dụng thư viện cstdint","route":"4/0-su-dung-thu-vien-cstdint","id":30016,"description":"int main()\t{ } //in ra kết quả là giá trị lớn nhất của 5 số vừa nhập //in ra kết quả là giá trị nhỏ nhất của 5 số vừa nhập int main()\t {…","__filename":"generated/30016.md","__url":"/4/0-su-dung-thu-vien-cstdint/","__resourceUrl":"/4/0-su-dung-thu-vien-cstdint/index.html","__dataUrl":"/4/0-su-dung-thu-vien-cstdint/index.html.a2801fa4ada10c23f504f07e4ee78b63.json"},{"title":"4.1 Kiểu kí tự","route":"4/1-kieu-ki-tu","id":30018,"description":"//check if there is any character exist in stdin file object if (!cin.eof())\t{ \tcout &lt;&lt; \"There are some character more in stdin file…","__filename":"generated/30018.md","__url":"/4/1-kieu-ki-tu/","__resourceUrl":"/4/1-kieu-ki-tu/index.html","__dataUrl":"/4/1-kieu-ki-tu/index.html.3d3eff45a05d59492b7b40b7e7817293.json"},{"title":"4.2 Ép kiểu dữ liệu","route":"4/2-ep-kieu-du-lieu","id":30019,"description":"","__filename":"generated/30019.md","__url":"/4/2-ep-kieu-du-lieu/","__resourceUrl":"/4/2-ep-kieu-du-lieu/index.html","__dataUrl":"/4/2-ep-kieu-du-lieu/index.html.2ce390588cf4f5b31eb1090272f305c3.json"},{"title":"4.3 auto và decltype","route":"4/3-auto-va-decltype","id":30020,"description":"// compare the type of n with type int32_t if (typeid(int32_t) == typeid(n)) \tcout &lt;&lt; \"n is an object of type int32_t\" &lt;&lt; endl;…","__filename":"generated/30020.md","__url":"/4/3-auto-va-decltype/","__resourceUrl":"/4/3-auto-va-decltype/index.html","__dataUrl":"/4/3-auto-va-decltype/index.html.0d8f1c6d9c4f8f1eff25628a38272254.json"},{"title":"4.4 Địa chỉ của biến","route":"4/4-dia-chi-cua-bien","id":30022,"description":"cout &lt;&lt; \"Value of var: \" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; \"Value of var_reference: \" &lt;&lt; var_reference &lt;&lt; endl;…","__filename":"generated/30022.md","__url":"/4/4-dia-chi-cua-bien/","__resourceUrl":"/4/4-dia-chi-cua-bien/index.html","__dataUrl":"/4/4-dia-chi-cua-bien/index.html.7700a863d95ebd2c72f590db3ae556c8.json"},{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","id":30080,"description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements…","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.2bdadf3c58a38e337057a0de9d3374f6.json"},{"title":"5.1 Các thao tác cơ bản với mảng một chiều","route":"5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu","id":30082,"description":"int32_t arr[ARRAY_SIZE];\t int32_t arr_clone[ARRAY_SIZE]; } } int main() { \tchar ch_array\\[] = { 'L', 'e', 'T', 'r', 'a', 'n', 'D', 'a',…","__filename":"generated/30082.md","__url":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/","__resourceUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html","__dataUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html.c358cb5702d7e0848c1d0fcafea76326.json"},{"title":"5.2 Thư viện array trong STL","route":"5/2-thu-vien-array-trong-stl","id":30083,"description":"//Access to all of elements of arr object for (int32_t index = 0; index &lt;= arr.size() - 1; index++) { \tcout &lt;&lt; arr[index] &lt;&lt;…","__filename":"generated/30083.md","__url":"/5/2-thu-vien-array-trong-stl/","__resourceUrl":"/5/2-thu-vien-array-trong-stl/index.html","__dataUrl":"/5/2-thu-vien-array-trong-stl/index.html.f6855e3cf847058a20cddbfbd1924e9a.json"},{"title":"5.3 Mảng hai chiều","route":"5/3-mang-hai-chieu","id":30085,"description":"for(int row = 0; row &lt; 3; row++) { \tfor(int col = 0; col &lt; 4; col++) \t{ \t\tcout &lt;&lt; board[row][col] &lt;&lt; \" \"; \t} \tcout…","__filename":"generated/30085.md","__url":"/5/3-mang-hai-chieu/","__resourceUrl":"/5/3-mang-hai-chieu/index.html","__dataUrl":"/5/3-mang-hai-chieu/index.html.20eabc78d6c5ccd506f5e0a0d9bc1987.json"},{"title":"5.4 Các thao tác cơ bản với mảng hai chiều","route":"5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu","id":30086,"description":"} }","__filename":"generated/30086.md","__url":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/","__resourceUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html","__dataUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html.d255b4de5fe60dec619e7ce656009b5a.json"},{"title":"6.0 Mảng kí tự","route":"6/0-mang-ki-tu","id":30090,"description":"cout &lt;&lt; \"Enter your full name: \"; cin >> full_name; cout &lt;&lt; \"Your full name is \" &lt;&lt; full_name &lt;&lt; endl; cout…","__filename":"generated/30090.md","__url":"/6/0-mang-ki-tu/","__resourceUrl":"/6/0-mang-ki-tu/index.html","__dataUrl":"/6/0-mang-ki-tu/index.html.c07e54b9b2919b7ae2f406f37d0fbed3.json"},{"title":"6.1 Các thao tác cơ bản với mảng kí tự","route":"6/1-cac-thao-tac-co-ban-voi-mang-ki-tu","id":30091,"description":"memset(foo, '-', 7); cout &lt;&lt; foo &lt;&lt; endl; \\-------every programmer should know memset! strcpy(str_destination, str_source);…","__filename":"generated/30091.md","__url":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/","__resourceUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html","__dataUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html.f0846f159064ae244ee4452151734f0f.json"},{"title":"6.2 Thư viện string trong C++","route":"6/2-thu-vien-string-trong-c","id":30092,"description":"//......... string my_string; string temp_string(\"What the hell is going on?\"); string one_more = temp_string; string…","__filename":"generated/30092.md","__url":"/6/2-thu-vien-string-trong-c/","__resourceUrl":"/6/2-thu-vien-string-trong-c/index.html","__dataUrl":"/6/2-thu-vien-string-trong-c/index.html.c5528a05ca23fbe3ff253526b42ee2f6.json"},{"title":"7.0 Làm quen với khái niệm function","route":"7/0-lam-quen-voi-khai-niem-function","id":30132,"description":"if(strlen(str1) == strlen(str2))\t{ \t//do something } void introduce() { \tcout &lt;&lt; \"Hello!\" &lt;&lt; endl; \tcout &lt;&lt; \"I'm a…","__filename":"generated/30132.md","__url":"/7/0-lam-quen-voi-khai-niem-function/","__resourceUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html","__dataUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html.6701f9806c1a33418b356bcbfebc4392.json"},{"title":"7.1 Thiết kế chương trình dựa trên khái niệm function","route":"7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function","id":30133,"description":"} } float subtraction(float value1, float value2) { \treturn value1 - value2; } float multiplication(float value1, float value2) { \treturn…","__filename":"generated/30133.md","__url":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/","__resourceUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html","__dataUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html.0dd052d16304cb05be843573b6ec0e45.json"},{"title":"7.2 Truyền đối số cho hàm là giá trị hoặc tham chiếu","route":"7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu","id":30319,"description":"} } int main() { \tint argument; \tcout &lt;&lt; \"Address of argument: \" &lt;&lt; &argument &lt;&lt; endl;…","__filename":"generated/30319.md","__url":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html.3219ee44dcef6a14dae07111a5c0abf3.json"},{"title":"7.3 Hàm trả về giá trị hoặc tham chiếu","route":"7/3-ham-tra-ve-gia-tri-hoac-tham-chieu","id":30381,"description":"// .............. // function call int result = doubleValue(10); // ................ // function call int & myRef = returnReference(); for…","__filename":"generated/30381.md","__url":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html.4288591cda8969c5c9199b250877f786.json"},{"title":"7.4 Tham số mặc định, tham số hằng","route":"7/4-tham-so-mac-dinh-tham-so-hang","id":30382,"description":"int main() { \tstring non_const_msg = \"This is non-const message\"; \tconst string const_msg = \"This is const message\"; } int main() { }","__filename":"generated/30382.md","__url":"/7/4-tham-so-mac-dinh-tham-so-hang/","__resourceUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html","__dataUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html.b234bc219b3b3db4f46f8d654d7af624.json"},{"title":"7.5 Function overloading","route":"7/5-function-overloading","id":30477,"description":"float addFloat(float f1, float f2) { \treturn f1 + f2; } float add(float f1, float f2) { \treturn f1 + f2; } print(0); print('a'); print('a');","__filename":"generated/30477.md","__url":"/7/5-function-overloading/","__resourceUrl":"/7/5-function-overloading/index.html","__dataUrl":"/7/5-function-overloading/index.html.5657ec584a875acb4601350f19853ed3.json"},{"title":"8.0 Con trỏ","route":"8/0-con-tr","id":30541,"description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt;…","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.a46c66f365403503c34cafdc9863cfa3.json"},{"title":"8.1 Toán tử tăng, giảm dùng cho con trỏ","route":"8/1-toan-tu-tang-giam-dung-cho-con-tr","id":30699,"description":"cout &lt;&lt; \"Before decreased: \" &lt;&lt; ptr &lt;&lt; endl; ptr--; cout &lt;&lt; \" After decreased: \" &lt;&lt; ptr &lt;&lt; endl; cout…","__filename":"generated/30699.md","__url":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/","__resourceUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html","__dataUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html.cce9500249671524aec88406806baa9e.json"},{"title":"8.2 Con trỏ và mảng một chiều","route":"8/2-con-tr-va-mang-mot-chieu","id":30788,"description":"//show address of the first element of arr cout &lt;&lt; &arr[0] &lt;&lt; endl; //show address of the first element of arr cout &lt;&lt;…","__filename":"generated/30788.md","__url":"/8/2-con-tr-va-mang-mot-chieu/","__resourceUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html","__dataUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html.3c8778e4780dd872224eef1cc8f11097.json"},{"title":"8.3 Con trỏ và mảng kí tự","route":"8/3-con-tr-va-mang-ki-tu","id":30876,"description":"p_name[1] = 'E'; cout &lt;&lt; my_name &lt;&lt; endl; cout &lt;&lt; p_name &lt;&lt; endl; } \"Le Tran Dat\"[1] = 'E'; //this line will make…","__filename":"generated/30876.md","__url":"/8/3-con-tr-va-mang-ki-tu/","__resourceUrl":"/8/3-con-tr-va-mang-ki-tu/index.html","__dataUrl":"/8/3-con-tr-va-mang-ki-tu/index.html.dc406539fbe2db6bafb4f3a63ad20fbc.json"},{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","id":31145,"description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt;…","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.e0fca4aed8a1bfd6079218b8f9cd5649.json"},{"title":"8.5 Con trỏ và hằng","route":"8/5-con-tr-va-hang","id":31355,"description":"int value1 = 5; ptr = &value1; int value2 = 10; ptr = &value2; &ptr = 10; //compile error int otherValue = 10; ptr = &otherValue; //compile…","__filename":"generated/31355.md","__url":"/8/5-con-tr-va-hang/","__resourceUrl":"/8/5-con-tr-va-hang/index.html","__dataUrl":"/8/5-con-tr-va-hang/index.html.9717e378d7312e77dd0af404f3ce878a.json"},{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","id":31625,"description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int iPtr…","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.95810b485beb7091df5fbe0cdad166a6.json"},{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","id":31810,"description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl; }…","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.807439d811fbe3c25a6fe7de6f440dcd.json"},{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","id":31959,"description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue;…","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.95b3e8ea543c2c88ac5aed6fae7dd5bc.json"},{"title":"8.10 Phân loại các vùng nhớ (stack & heap ...)","route":"8/10-phan-loai-cac-vung-nho-stack-va-heap","id":32101,"description":"","__filename":"generated/32101.md","__url":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/","__resourceUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html","__dataUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html.f3d953ab58d5d6d7caa9a6825ab85eff.json"},{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","id":32133,"description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int \\*pTemp = ptr; ptr…","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.9b5398e8d66b8730b73fe13cf4859166.json"},{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","id":32159,"description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i++) {…","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/8/7-con-tr-tr-den-con-tr/index.html.9e711455792370d4585f9b6422ec5c75.json"},{"title":"9.0 Kiểu liệt kê (enum)","route":"9/0-kieu-liet-ke-enum","id":32760,"description":"enum Color { \tRED, \tGREEN, \tBLUE, \tWHITE }; enum Animal { \tCAT, \tDOG, \tHORSE, \tMONKEY, \tCHICKEN }; } int iValue = LETTER_A; cout &lt;&lt;…","__filename":"generated/32760.md","__url":"/9/0-kieu-liet-ke-enum/","__resourceUrl":"/9/0-kieu-liet-ke-enum/index.html","__dataUrl":"/9/0-kieu-liet-ke-enum/index.html.5bcab9708527435f7e4986ca2293f162.json"},{"title":"9.1 Structs","route":"9/1-structs","id":33291,"description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent; }; //................…","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.218b89a947ee10e7345fd63f614e71bf.json"},{"title":"9.2 Structs and pointer","route":"9/2-structs-and-pointer","id":33521,"description":"int main() { \tBankAccount myAccount = { 123456789, 50 }; // $50 \tBankAccount \\*pAccount = &myAccount;  } int main() { \tBankAccount…","__filename":"generated/33521.md","__url":"/9/2-structs-and-pointer/","__resourceUrl":"/9/2-structs-and-pointer/index.html","__dataUrl":"/9/2-structs-and-pointer/index.html.3dac4346cb7783e552949ccfe8b270fd.json"},{"title":"11.0 Giới thiệu về STL","route":"11/0-gioi-thieu-ve-stl","id":34001,"description":"","__filename":"generated/34001.md","__url":"/11/0-gioi-thieu-ve-stl/","__resourceUrl":"/11/0-gioi-thieu-ve-stl/index.html","__dataUrl":"/11/0-gioi-thieu-ve-stl/index.html.d381e349b21471222160fc598695cb22.json"},{"title":"11.1 STL containers","route":"11/1-stl-containers","id":34210,"description":"std::vector&lt;\\_\\_int32> vecInt32; std::vector&lt;int32> vec2(5); //gọi phương thức khởi tạo std::vector(size_t \\_Count) với giá trị…","__filename":"generated/34210.md","__url":"/11/1-stl-containers/","__resourceUrl":"/11/1-stl-containers/index.html","__dataUrl":"/11/1-stl-containers/index.html.801d3937ec25c5210d7a3d9a39a6cc9b.json"},{"title":"Khóa học C++","description":"Cạnh tranh với Udemy luôn. Các bạn vào nhập mã REHON_UDEMY Hoặc bấm vào link này http&#x3A;//bit.ly/rehon_udemy Vào đăng ký học rẻ hơn mã…","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.b5876e909f5a87e4ec2b20bf919bf9fa.json"}];window.__INITIAL_STATE__ = {"pages":{"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/":{"head":{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","id":32133,"description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int \\*pTemp = ptr; ptr…"},"body":"<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n<p>Trong bài học này, chúng ta sẽ cùng tìm hiểu về những lỗi thường gặp ở những bạn mới học lập trình khi sử dụng con trỏ trong chương trình. Những lỗi này thường xuất hiện do các bạn mới học chưa hiểu rõ cách quản lý vùng nhớ trong chương trình, do cách tổ chức chương trình chưa hợp lý, hoặc do sơ ý... Trong đó, một số lỗi không nghiêm trọng sẽ không gây ảnh hưởng nhiều đến hoạt động của chương trình, một số lỗi nghiêm trọng có thể làm chương trình phải kết thúc ngay lập tức. Dù lỗi gây có có nghiêm trọng hay không, chúng ta chủ động ngăn chặn thì vẫn tốt hơn.</p>\n<h5>Con trỏ trỏ đến vùng nhớ nằm ngoài phạm vi chương trình đang quản lý</h5>\n<p>Mình có đoạn chương trình như sau:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\t//allocate memory on Heap\n\tint *p = new int;\n<pre><code>//p point to somewhere\np -= 10000;\n\n//dereference to the area of other program\n*p = 1;\n\nsystem(\"pause\");\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Đầu tiên, chương trình cấp phát một vùng nhớ có kích thước <strong>4 bytes</strong> trên phân vùng <strong>Heap</strong> và cho con trỏ nắm giữ địa chỉ trả về của toán tử <strong>new</strong>. Sau đó, mình lại cho con trỏ p trỏ lung tung trên bộ nhớ ảo và cố tình thay đổi nội dung bên trong vùng nhớ mới trỏ đến. Khi để ở chế độ <strong>Debug</strong>, Visual Studio sẽ chặn chương trình của chúng ta lại và đưa ra cảnh báo. Nhưng nếu chúng ta chuyển sang chế độ <strong>Release</strong> và <strong>build</strong> ra sản phẩm thành một phần mềm, chạy phần mềm này sẽ gây <strong>crash</strong> và phần mềm phải kết thúc ngay lập tức.</p>\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/0.png?raw=true\" width=\"690\" height=\"302\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">1233x540</span><span class=\"expand\"></span>\n</div></a></div></p>\n<p>Thật ra cũng không có ai rãnh rỗi đến mức gán địa chỉ sai cho con trỏ, điều mà mình muốn nói ở đây là khi chương trình chúng ta viết bị <strong>crash</strong> khi chạy, có thể lỗi này đến từ việc gán địa chỉ không hợp lý.</p>\n<p>Trong thực tế, lỗi này sẽ xuất hiện dưới một hình thức khác. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint *p = new int[10];\n\tcout &lt;&lt; p &lt;&lt; endl;\n<pre><code>delete[] p;\n\ncout &#x26;lt;&#x26;lt; p &#x26;lt;&#x26;lt; endl;\n\n_sleep(10000);\n\nfor (int i = 0; i &#x26;lt; 10; i++)\n    cin &#x26;gt;&#x26;gt; p[i];\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Chương trình này yêu cầu cấp phát 1 dãy địa chỉ có kích thước <strong>40 bytes trên Heap</strong>. Sau đó in ra địa chỉ của vùng nhớ vừa được cấp phát thành công. Tiếp theo, mình không muốn sử dụng vùng nhớ này nữa nên mình trả lại cho hệ điều hành thông qua toán tử <strong>delete</strong>. Trên thực tế, có thể mình sẽ không giải phóng vùng nhớ ngay lập tức mà sử dụng xong rồi mới giải phóng nó đi. Sau khi giải phóng vùng nhớ đó, mình in ra lại địa chỉ mà con trỏ p đang nắm giữ thì thấy p vẫn đang trỏ đến địa chỉ mà mình đã giải phóng. Vậy là chúng ta đã gặp phải lỗi mà mình đưa ra ở ví dụ đầu tiên trong bài học này, đó là con trỏ trỏ đến một vùng nhớ không chịu sử quản lý của chương trình. Lúc này, mình chưa <strong>dereference</strong> đến vùng nhớ đó ngay lập tức mà vẫn cho chương trình tiếp tục thực thi. Cuối cùng, mình không nhớ rằng vùng nhớ ban đầu đã được giải phóng ở đâu đó nên vẫn tiếp tục sử dụng bằng cách nhập dữ liệu vào đó thông qua con trỏ p.</p>\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/1.png?raw=true\" width=\"690\" height=\"290\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">1281x539</span><span class=\"expand\"></span>\n</div></a></div></p>\n<p>Kết quả là phần mềm đang chạy thì bị <strong>crash</strong> vì có thể hệ điều hành đã cấp phát vùng nhớ đã được giải phóng cho phần mềm khác sử dụng. Khi chạy chương trình dưới chế độ Debug trong Visual Studio, lỗi này có thể không phát hiện được do nó vẫn chạy bình thường mà không có thông báo mà cũng không bị crash. Điều này làm chúng ta tưởng rằng chương trình hoạt động tốt, và <strong>build</strong> nó ra thành phần mềm lỗi.</p>\n<p>Để khắc phục trường hợp này, chúng ta nên cho con trỏ quản lý vùng nhớ được cấp phát trỏ về <strong>NULL</strong> ngay sau khi giải phóng vùng nhớ đó.</p>\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint *p = NULL;\n\tp = new int[10];\n\tcout &lt;&lt; p &lt;&lt; endl;\n<pre><code>delete[] p;\np = NULL;\n\ncout &#x26;lt;&#x26;lt; p &#x26;lt;&#x26;lt; endl;\n\n_sleep(10000);\n\nif (p != NULL) {\n\n    for (int i = 0; i &#x26;lt; 10; i++)\n        cin &#x26;gt;&#x26;gt; p[i];\n}\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Bất cứ khi nào sử dụng vùng nhớ thông qua con trỏ, chúng ta cũng nên kiểm tra xem con trỏ có khác NULL hay không. Nếu con trỏ khác NULL thì chúng ta hiểu rằng vùng nhớ đó vẫn chưa được giải phóng. Đây chỉ là một cách quy ước mình tự đặt ra giúp cách viết chương trình của mình an toàn hơn, cách của mình có thể khác với một số lập trình viên khác.</p>\n<p>Nhưng lỗi này còn có thể xuất hiện dưới một hình thức khác nữa. Đó là sử dụng 2 con trỏ cùng trỏ đến một vùng nhớ trong chương trình.</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n<p>char <em> getName(char </em>fullname) {\n\nif (fullName == NULL)\nreturn NULL;\n\nchar *pTemp = strrchr(fullname, ' ');</p>\n<pre><code>if (pTemp == NULL)\n    return fullname;\nelse\n    return pTemp + 1;\n</code></pre>\n<p>}</p>\n<p>int main()\t{</p>\n<pre><code>char *fullName = new char[50];\n\ncout &#x26;lt;&#x26;lt; \"Enter your full name: \";\ncin.getline(fullName, 50);\n\ncout &#x26;lt;&#x26;lt; \"Your last name is: \";\nchar *name = getName(fullName);\n\ndelete[] fullName;\n\ncout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Đoạn chương trình này thực hiện công việc yêu cầu người dùng nhập vào đầy đủ họ và tên, sau đó in ra tên mà người dùng vừa nhập vào (bỏ qua họ và tên đệm). Nhưng trước đó, mình cần yêu cầu cấp phát một vùng nhớ trên <strong>Heap</strong> đủ để người dùng nhập vào họ tên.</p>\n<p>Cách hoạt động của hàm getName như sau:</p>\n<p>(1) Nhận vào đối số là địa chỉ của một địa chỉ của một chuỗi kí tự, trong trường hợp này là full name của người dùng.<br>(2) Sử dụng hàm <strong>strrchr</strong> trong thư viện <strong>cstring</strong> để trả về địa chỉ xuất hiện kí tự khoảng trắng cuối cùng trong chuỗi kí tự.<br>(3) Nếu không có kí tự khoảng trắng thì trả về địa chỉ đầu tiên của chuỗi kí tự (cho rằng người dùng chỉ nhập tên chứ không nhập họ và tên đệm), nếu có xuất hiện khoảng trắng thì trả về địa chỉ của phần tử đứng sau khoảng trắng.</p>\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/2.png?raw=true\" class=\"lightbox\" title=\"2.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/2.png?raw=true\" width=\"690\" height=\"259\"><div class=\"meta\">\n<span class=\"filename\">2.png?raw=true</span><span class=\"informations\">958x360</span><span class=\"expand\"></span>\n</div></a></div></p>\n<p>Như chúng ta thấy, địa chỉ của tên người dùng được trả về từ hàm <strong>getName</strong> cũng thuộc phạm vi vùng nhớ được cấp phát và đang được quản lý thông qua con trỏ <strong>fullName</strong>. Tuy nhiên, trong đoạn chương trình trên, lập trình viên này đã nghĩ rằng sau khi sử dụng xong hàm getName thì không cần sử dụng đến con trỏ <strong>fullName</strong> nữa, vậy là <strong>delete</strong> luôn vùng nhớ mà con trỏ <strong>fullName</strong> đang nắm giữ, dẫn đến việc con trỏ <strong>name</strong> đã trỏ tới một vùng nhớ không còn thuộc quyền quản lý của chương trình nữa. Và kết quả cho ra không đúng với mong đợi:</p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/3.png?raw=true\" width=\"579\" height=\"384\"></p>\n<p>Tuy nhiên, khi mình chạy chương trình trên, kết quả vẫn đúng. Đó là do mình sử dụng vùng nhớ đó ngay sau khi trả lại cho hệ điều hành. Hệ điều hành lúc này vẫn chưa tác động gì đến vùng nhớ đã được giải phóng, hoặc nếu đã có cấp phát cho chương trình khác thì chương trình đó vẫn chưa thay đổi nội dung trong phạm vi này. Bây giờ mình giả sử chúng ta thực thi công việc khác, sau một vài giây sau mới cần in ra kết quả thì sẽ dễ phát hiện lỗi hơn:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>char *fullName = new char[50];\n\ncout &#x26;lt;&#x26;lt; \"Enter your full name: \";\ncin.getline(fullName, 50);\n\ncout &#x26;lt;&#x26;lt; \"Your last name is: \";\nchar *name = getName(fullName);\n\ndelete[] fullName;\n\n_sleep(5000);\ncout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-11-cac-van-de-thuong-gap-khi-su-dung-con-tro/4.png?raw=true\" width=\"579\" height=\"384\"></p>\n<p>Để khắc phục trường hợp này, chúng ta cần xác định rằng khi nào thực sự không còn sử dụng đến vùng nhớ nào đó thì mới giải phóng. Sửa lại đoạn chương trình trên như sau:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>char *fullName = new char[50];\n\ncout &#x26;lt;&#x26;lt; \"Enter your full name: \";\ncin.getline(fullName, 50);\n\ncout &#x26;lt;&#x26;lt; \"Your last name is: \";\nchar *name = getName(fullName);\ncout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;\n\ndelete[] fullName;\nfullName = NULL;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Hoặc chúng ta vẫn muốn sử dụng tiếp vùng nhớ quản lý bởi con trỏ <strong>fullName</strong> mà không muốn sử dụng đến con trỏ <strong>name</strong> nữa, chúng ta nên sửa lại như sau:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>char *fullName = new char[50];\n\ncout &#x26;lt;&#x26;lt; \"Enter your full name: \";\ncin.getline(fullName, 50);\n\ncout &#x26;lt;&#x26;lt; \"Your last name is: \";\nchar *name = getName(fullName);\ncout &#x26;lt;&#x26;lt; name &#x26;lt;&#x26;lt; endl;\n\nname = NULL;\n\n//keep using fullName\n//and then deallocate it\n\ndelete[] fullName;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Con trỏ <strong>name</strong> chỉ trỏ đến địa chỉ bên trong vùng nhớ được cấp phát cho con trỏ <strong>fullName</strong>, nên chúng ta không nên sử dụng toán tử <strong>delete</strong> cho con trỏ <strong>name</strong>.</p>\n<p>Trường hợp con trỏ trỏ đến vùng nhớ không chịu sự quản lý của chương trình cũng thường xuất hiện khi trả về địa chỉ của biến cục bộ trong hàm.</p>\n<p></p><pre><code class=\"lang-auto\">int * newIntValue(int value = 0)\n{\n\tint n = value;\n\treturn &amp;n;\n}\n<p>int main()\t{</p>\n<pre><code>int *pInt = newIntValue(0);\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Như các bạn đã biết, biến cục bộ sẽ bị đưa ra khỏi <strong>Stack</strong> khi ra khỏi phạm vi khối lệnh. Dó đó, địa chỉ của biến n trong hàm <strong>newIntValue</strong> vẫn được trả về trước khi bị hủy. Chúng ta nên thay bằng <strong>Dynamic memory allocation:</strong></p>\n<p></p><pre><code class=\"lang-auto\">int * newIntValue(int value = 0)\n{\n\treturn new int(value);\n}\n<p>int main()\n{\nint *p = newIntValue(0);\n\ndelete p;\n\nreturn 0;\n}</code></pre></p>\n<h5>memory leak</h5>\n<p><strong>Memory leak</strong> là trường hợp cấp phát vùng nhớ cho chương trình (thường là cấp phát trên <strong>Heap</strong>) nhưng vùng nhớ không được sử dụng hoặc không được giải phóng. Điều này làm giảm dung lượng bộ nhớ có thể sử dụng được cho những chương trình khác, khiến các chương trình hoạt động chậm hơn hoặc có thể làm crash chương trình. </p>\n<p>Đây là một ví dụ thường gặp ở những lập trình viên mới học về kỹ thuật <strong>Dynamic memory allocation:</strong></p>\n<p></p><pre><code class=\"lang-auto\">int *ptr = new int[10];\n//................\nptr = NULL;</code></pre>\n<p>Trong đoạn chương trình này, lập trình viên tự ý cho con trỏ ptr trỏ đi nơi khác. Điều này dẫn đến việc vùng nhớ được cấp phát trước đó không thể quản lý được nữa. Muốn quản lý một vùng nhớ được cấp phát trên Heap, chúng ta cần sử dụng ít nhất một con trỏ. Nhưng trong trường hợp này, không còn con trỏ nào được dùng để quản lý vùng nhớ đã được cấp phát. Do đó, vùng nhớ được cấp phát chỉ có thể được giải phóng khi toàn bộ chương trình kết thúc.</p>\n<p>Để khắc phục trường hợp này, chúng ta cần có một con trỏ khác thay thế vị trí của con trỏ <strong>ptr</strong> trước khi cho con trỏ <strong>ptr</strong> trỏ đi nơi khác:</p>\n<p></p><pre><code class=\"lang-auto\">int *ptr = new int[10];\n//.................\n<p>int *pTemp = ptr;\nptr = NULL;</code></pre></p>\n<p>Việc <strong>resize</strong> kích thước của vùng nhớ cũng có thể gây ra lỗi <strong>memory leak</strong> nếu sơ ý:</p>\n<p></p><pre><code class=\"lang-auto\">void resizeArray(int *&amp;p, int oldLength, int newLength)\n{\n\tint *pTemp = p;\n\tp = allocateArray(newLength);\n\t\n\t//copy data\n\tif(oldLength &lt; newLength)\n\t{\n\t\tfor(int i = 0; i &lt; oldLength; i++)\n\t\t{\n\t\t\tp[i] = pTemp[i];\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i &lt; newLength; i++)\n\t\t{\n\t\t\tp[i] = pTemp[i];\n\t\t}\n\t}\n}\n<p>int main()\t{</p>\n<pre><code>int length = 10;\nint *p = new int[length];\n\nint newLength = 20;\nresizeArray(p, length, newLength);\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Khi cấp phát lại vùng nhớ, con trỏ p được gán vào địa chỉ mới, vùng nhớ ban đầu được con trỏ <strong>pTemp</strong> quản lý, nhưng khi ra khỏi hàm thì con trỏ pTemp bị hủy (vì <strong>pTemp</strong> cũng là biến cục bộ, được cấp phát trên <strong>Stack</strong>). Như vậy, vùng nhớ cũ không còn được quản lý nữa.</p>\n<p>Chúng ta nên sửa lại đoạn chương trình trên như sau:</p>\n<p></p><pre><code class=\"lang-auto\">void resizeArray(int *&amp;p, int oldLength, int newLength)\n{\n\tint *pTemp = p;\n\tp = allocateArray(newLength);\n\t\n\t//copy data\n\tif(oldLength &lt; newLength)\n\t{\n\t\tfor(int i = 0; i &lt; oldLength; i++)\n\t\t{\n\t\t\tp[i] = pTemp[i];\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i &lt; newLength; i++)\n\t\t{\n\t\t\tp[i] = pTemp[i];\n\t\t}\n\t}\n\t\n\tdelete[] pTemp;\n}\n<p>int main()\t{</p>\n<pre><code>int length = 10;\nint *p = new int[length];\n\nint newLength = 20;\nresizeArray(p, length, newLength);\n\ndelete[] p;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Còn một trường hợp thường thấy nữa, đó là việc sử dụng sai toán tử delete cho con trỏ:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>int *p = new int[10];\n\ndelete p;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Như các bạn thấy, chúng ta yêu cầu cấp phát một dãy vùng nhớ cho 10 phần tử kiểu <strong>int</strong>, nhưng khi giải phóng thì sử dụng toán tử <strong>delete</strong> để giải phóng một biến đơn. Visual Studio không báo lỗi cho trường hợp này, do đó lỗi này thường cũng khó nhận ra. Chúng ta nên sửa lại như sau:</p>\n<p></p><pre><code class=\"lang-auto\">int main()\t{\n<pre><code>int *p = new int[10];\n\ndelete[] p;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<hr>\n<h3>Tổng kết</h3>\n<p>Trong bài học này, chúng ta đã cùng tìm hiểu một số nguyên nhân gây ra lỗi khi sử dụng con trỏ trong ngôn ngữ C++. Đây là một số lỗi thường gặp ở những người mới học lập trình C++. Như các bạn thấy, việc quản lý vùng nhớ một cách thủ công khá là phức tạp. Trong chuẩn C++ mới đã có hổ trợ cho chúng ta <strong>Smart Pointer</strong> giúp chúng ta tránh được những lỗi thường gặp này. Chúng ta sẽ tìm hiểu về <strong>Smart Pointer</strong> trong những bài học sau.</p>\n<hr>\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>\n<p><strong><a href=\"http://www.daynhauhoc.com\">www.daynhauhoc.com</a></strong></p>\n","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.9b5398e8d66b8730b73fe13cf4859166.json"}}}</script><script src="/phenomic.browser.6e734c8f92717d6bc98a.js"></script></body></html>