{"head":{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","id":31145,"description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt…"},"body":"\n<h4>Chào các bạn học viên đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong bài học này, mình sẽ tiếp tục giới thiệu đến các bạn một số vấn đề về con trỏ và sử dụng con trỏ để quản lý bộ nhớ ảo trong ngôn ngữ C++.</p>\n\n<p>Như mình đã đề cập trong bài học <a href=\"//daynhauhoc.com/t/pham-vi-cua-bien/29939\">phạm vi của biến</a>, thời gian tồn tại của biến phụ thuộc vào vị trí bạn khai báo biến.</p>\n\n<ul>\n<li>Biến toàn cục (<strong>global variable</strong>) được khai báo bên ngoài khối lệnh, có thể được truy xuất tại bất cứ dòng lệnh nào đặt bên dưới biến đó. Biến toàn cục tồn tại đến khi chương trình bị kết thúc.</li>\n<li>Biến cục bộ (<strong>local variable</strong>) được khai báo bên trong khối lệnh, có thể được truy xuất tại bất cứ dòng lệnh nào đặt bên dưới biến đó và trong cùng khối lệnh. Biến cục bộ bị hủy khi chương trình chạy ra ngoài khối lệnh chứa biến đó.</li>\n</ul>\n\n<p>Tương ứng với 2 kiểu khai báo biến này là 2 cách thức cấp phát bộ nhớ cho chương trình trên bộ nhớ ảo:</p>\n\n<h5>Static memory allocation (cấp phát bộ nhớ tĩnh)</h5>\n\n<p><strong>Static memory allocation</strong> còn được gọi là <strong>Compile-time allocation</strong>, được áp dụng cho biến <strong>static</strong> và biến toàn cục.</p>\n\n<ul>\n<li>Vùng nhớ của các biến này được cấp phát ngay khi chạy chương trình.</li>\n<li>Kích thước của vùng nhớ được cấp phát phải được cung cấp tại thời điểm biên dịch chương trình.</li>\n<li>Đối với việc khai báo mảng một chiều, đây là lý do tại sao số lượng phần tử là hằng số.</li>\n</ul>\n\n<h5>Automatic memory allocation (cấp phát bộ nhớ tự động)</h5>\n\n<p><strong>Automatic memory allocation</strong> được sử dụng để cấp phát vùng nhớ cho các biến cục bộ, tham số của hàm.</p>\n\n<ul>\n<li>Bộ nhớ được cấp phát tại thời điểm chương trình đang chạy, khi chương trình đi vào một khối lệnh.</li>\n<li>Các vùng nhớ được cấp phát sẽ được thu hồi khi chương trình đi ra khỏi một khối lệnh.</li>\n<li>Kích thước vùng cần cấp phát cũng phải được cung cấp rõ ràng.</li>\n</ul>\n\n<h5>Nhược điểm của các phương thức cấp phát bộ nhớ đã học</h5>\n\n<p><strong>Kích thước vùng nhớ cấp phát phải được cung cấp tại thời điểm biên dịch chương trình</strong></p>\n\n<p>Lấy ví dụ, chúng ta cần lưu trữ tên của tất cả sinh viên trong một lớp học. Chúng ta sẽ sử dụng một mảng các string để lưu trữ như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">string name_of_students[50];</code></pre>\n\n<p>Mình hiện tại không biết có bao nhiêu sinh viên trong một lớp học, nên mình chỉ ước tính con số tối đa lượng sinh viên của lớp này là 50 người. Vậy điều gì xảy ra khi lớp học có nhiều hơn 50 sinh viên? Mảng <code>name_of_students</code> sẽ không thể lưu hết tên của tất cả sinh viên được. Bên cạnh đó, nếu số lượng sinh viên của lớp học chỉ có 30 người, mảng <code>name_of_students</code> sẽ thừa ra 20 phần tử không cần sử dụng đến.</p>\n\n<p><strong>Cấp phát và thu hồi vùng nhớ do chương trình quyết định</strong></p>\n\n<p>Trong một số trường hợp, chúng ta cần sử dụng biến toàn cục để có thể truy cập vùng nhớ của biến tại nhiều khối lệnh khác nhau trong chương trình, nhưng thời gian tồn tại của biến toàn cục khá lâu, nên khi sử dụng biến toàn cục sẽ gây ảnh hưởng đáng kể lượng tài nguyên bộ nhớ của máy tính nếu chúng ta cấp phát cho biến toàn cục một vùng nhớ lớn.</p>\n\n<p>Hoặc trong một số trường hợp khác, chúng ta vẫn muốn sử dụng tiếp vùng nhớ cấp phát cho biến bên trong hàm, nhưng biến cục bộ đặt trong khối lệnh (cùng với vùng nhớ nó quản lý) sẽ bị hủy khi hàm kết thúc.</p>\n\n<p><strong>Kích thước bộ nhớ dùng cho Static memory allocation và Automatic memory allocation bị giới hạn</strong></p>\n\n<p>Bộ nhớ ảo được chia thành nhiều phân vùng khác nhau sử dụng cho những loại tài nguyên khác nhau. Trong đó, các phương thức cấp phát bộ nhớ <strong>Static memory allocation</strong> hay <strong>Automatic memory allocation</strong> sẽ sử dụng phân vùng <strong>Stack</strong> để lưu trữ. Chúng ta sẽ có một bài học để nói chi tiết về các phân vùng trên bộ nhớ ảo. Bây giờ các bạn tạm thời hình dung bộ nhớ ảo chúng ta sẽ chia thành các phần như sau:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Phân vùng <strong>Stack</strong> được đặt tại vùng có địa chỉ cao nhất trong dãy bộ nhớ ảo. Dung lượng của phân vùng này khá hạn chế. Tùy vào mỗi hệ điều hành mà dung lượng bộ nhớ của phân vùng <strong>Stack</strong> khác nhau. Đối với Visual studio 2015 chạy trên hệ điều hành Windows, dung lượng bộ nhớ của phân vùng <strong>Stack</strong> là khoảng 1MB (tương đương khoảng 1024 bytes).</p>\n\n<p>Với sự hạn chế về dung lượng bộ nhớ của phân vùng <strong>Stack</strong>, chương trình của chúng ta sẽ phát sinh lỗi <strong>stack overflow</strong> nếu các bạn yêu cầu cấp phát vùng nhớ vượt quá dung lượng của <strong>Stack</strong>. Các bạn có thể chạy thử 2 đoạn chương trình sau để kiểm chứng:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    char ch_array[1024 * 1000];\n\n    system(\"pause\");\n    return 0;\n}</code></pre>\n\n<p>Trong đoạn chương trình trên, mình khai báo một mảng kí tự có tên <code>ch_array</code>, như các bạn biết kiểu char có kích thước 1 byte cho mỗi biến đơn (tương ứng với mỗi phần tử trong mảng kí tự), 1024 bytes sẽ tương ứng với 1Kb (Kilobyte). Do <code>ch_array</code> là biến cục bộ, nó sẽ được cấp phát vùng nhớ trên phân vùng Stack của bộ nhớ ảo. Như vậy, mảng <code>ch_array</code> sẽ được cấp phát 1000 kilobytes trên phân vùng Stack, nhưng con số này vẫn chưa vượt quá giới hạn 1Mb (1 Megabyte = 1024 Kilobytes) nên chương trình vẫn chạy bình thường. Bây giờ các bạn thử lại với đoạn chương trình sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    char ch_array[1024 * 1024];\n\n    system(\"pause\");\n    return 0;\n}</code></pre>\n\n<p>Kích thước vùng nhớ được yêu cầu cấp phát bây giờ là đúng bằng <strong>1 Mb</strong>. Thử chạy chương trình ở chế độ Debug, Visual Studio 2015 trên máy tính mình đưa ra thông báo:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/1.png?raw=true\" width=\"545\" height=\"311\"></p>\n\n<p>Việc cấp phát vùng nhớ có kích thước 1 Mb đã gây tràn bộ nhớ phân vùng Stack.</p>\n\n<p>Đây là một số hạn chế của các phương thức cấp phát bộ nhớ <strong>Static memory allocation và Automatic memory allocation</strong>. Để khắc phục hạn chế này, mình giới thiệu đến các bạn một phương thức cấp phát bộ nhớ mới được ngôn ngữ C++ hổ trợ.</p>\n\n<h3>Dynamic memory allocation</h3>\n\n<p><strong>Dynamic memory allocation</strong> là một giải pháp cấp phát bộ nhớ cho chương trình tại thời điểm chương trình đang chạy (run-time). <strong>Dynamic memory allocation</strong> sử dụng phân vùng <strong>Heap</strong> trên bộ nhớ ảo để cấp phát cho chương trình.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như các bạn thấy trong hình trên, phân vùng <strong>Heap</strong> của bộ nhớ ảo có dung lượng bộ nhớ lớn nhất. Do đó, bộ nhớ dùng để cấp phát cho chương trình trên phân vùng Heap chỉ bị giới hạn bởi thiết bị phần cứng (ví dụ là RAM) chứ không phụ thuộc vào hệ điều hành. Trong các máy tính hiện đại ngày nay, dung lượng bộ nhớ của phân vùng <strong>Heap</strong> có thể lên đến đơn vị GB (<code>1 Gigabyte = 1024 Megabytes = 1024 * 1024 Kilobytes</code>).</p>\n\n<h5>Đọc kỹ hướng dẫn sử dụng trước khi dùng</h5>\n\n<p>Kỹ thuật <strong>Dynamic memory allocation</strong> dùng để cấp phát bộ nhớ tại thời điểm run-time. Tại thời điểm này, chúng ta không thể tạo ra tên biến mới, mà chỉ có thể tạo ra vùng nhớ mới. Do đó, cách duy nhất để kiểm soát được những vùng nhớ được cấp phát bằng kỹ thuật <strong>Dynamic memory allocation</strong> là sử dụng con trỏ lưu trữ địa chỉ đầu tiên của vùng nhớ được cấp phát, thông qua con trỏ để quản lý vùng nhớ trên <strong>Heap</strong>.</p>\n\n<p>Vậy, việc thực hiện cấp phát bộ nhớ cần thực hiện qua 2 bước:</p>\n\n<ul>\n<li>Yêu cầu cấp phát vùng nhớ trên <strong>Heap</strong>.</li>\n<li>Lưu trữ địa chỉ của vùng nhớ vừa được cấp phát bằng con trỏ.</li>\n</ul>\n\n<p><strong>Để yêu cầu cấp phát bộ nhớ trên Heap, chúng ta sử dụng new operator.</strong></p>\n\n<p>Vùng nhớ được cấp phát trên Heap sẽ không tự động hủy bởi chương trình khi kết thúc khối lệnh, việc thu hồi vùng nhớ đã cấp phát trên Heap được giao cho lập trình viên tự quản lý. Nếu trong chương trình có yêu cầu cấp phát bộ nhớ trên Heap mà không được thu hồi hợp lý sẽ gây lãng phí tài nguyên hệ thống. Cũng giống như xin nhà nước cấp phát cho một vùng đất để xây dựng nhà máy, đang xây giữa chừng thì bên thầu công trình ăn hết vốn nên dự án xây dựng nhà máy bị hoãn lại, nhưng đất được nhà nước cấp phát không được trả lại cho nhà nước để làm việc khác, thế là lãng phí một vùng đất mà không làm được gì, tài nguyên trên máy tính cũng tương tự như vậy. </p>\n\n<p><strong>Để thu hồi vùng nhớ đã được cấp phát thông qua toán tử new, chúng ta sử dụng toán tử delete.</strong></p>\n\n<h3>Dynamically allocate single variables</h3>\n\n<h5>new operator</h5>\n\n<p>Toán tử new được dùng để xin cấp phát vùng nhớ trên phân vùng Heap của bộ nhớ ảo.</p>\n\n<p>Toán tử new trong chuẩn C++11 được định nghĩa với <strong>3 prototype</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void* operator new (std::size_t size);\nvoid* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) noexcept;\nvoid* operator new (std::size_t size, void* ptr) noexcept;</code></pre>\n\n<p>Các bạn chưa cần phải hiểu những tham số khai báo cho toán tử <strong>new</strong>, mà hiện tại chỉ cần chú ý kiểu trả về của nó (<code>void *</code>). Toán tử new sau khi xin cấp phát vùng nhớ trên <strong>Heap</strong> sẽ trả về một con trỏ chứa địa chỉ của vùng nhớ được cấp phát (nếu cấp phát thành công).</p>\n\n<p>Kiểu trả về của  toán tử <strong>new</strong> là con trỏ kiểu <strong>void</strong>, đây là một con trỏ đặc biệt, chúng ta sẽ tìm hiểu nó trong bài học sau. Nhưng dù nó là con trỏ kiểu gì thì mục đích của nó vẫn là chứa địa chỉ, do đó, chúng ta có thể gán giá trị trả về của toán tử <strong>new</strong> cho một con trỏ khác để quản lý vùng nhớ đã được cấp phát.</p>\n\n<h5>usage of new operator</h5>\n\n<p>Cú pháp sử dụng toán tử <strong>new</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">new &lt;data_type&gt;;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">new int; //allocate 4 bytes on Heap partition to an int variable\nnew double; //allocate 8 bytes on Heap partition to a double variable</code></pre>\n\n<p>Khi chương trình đang chạy, nếu quá trình cấp phát bộ nhớ trên thành công, chúng ta sẽ có địa chỉ của 2 vùng nhớ được trả về. Nhưng như mình đã nói, chúng ta không thể tạo thêm tên biến mới khi chương trình đang chạy, do đó chúng ta cần gán nó cho những con trỏ cùng kiểu để quản lý:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_int = new int;\ndouble *p_double = new double;</code></pre>\n\n<p>Bây giờ, vùng nhớ được cấp phát sẽ được quản lý bởi 2 con trỏ <code>p_int</code> và <code>p_double</code>, 2 vùng nhớ này được hệ điều hành trao quyền sử dụng tạm thời cho chương trình của chúng ta, thông qua con trỏ, chúng ta có thể thay đổi giá trị bên trong vùng nhớ này. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_int = new int;\ncout &lt;&lt; \"Put value into memory area\" &lt;&lt; endl;\ncin &gt;&gt; *p_int;\ncout &lt;&lt; \"Value at \" &lt;&lt; p_int &lt;&lt; \" is \" &lt;&lt; *p_int &lt;&lt; endl;</code></pre>\n\n<p>Chúng ta còn có thể vừa cấp phát bộ nhớ vừa khởi tạo giá trị tại vùng nhớ đó cho một biến đơn:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p1 = new int(5);\nint *p2 = new int { *p1 };</code></pre>\n\n<h5>usage of delete operator</h5>\n\n<p>Khi không muốn sử dụng tiếp vùng nhớ đã được cấp phát cho chương trình trên <strong>Heap</strong>, chúng ta nên trả lại vùng nhớ đó cho hệ điều hành. Thật ra khi chương trình kết thúc, tất cả vùng nhớ của chương trình đều bị hệ điều hành thu hồi, nhưng chúng ta nên giải phóng vùng nhớ không cần thiết càng sớm càng tốt.</p>\n\n<p>Để xóa một vùng nhớ, chúng ta cần có một địa chỉ cụ thể, địa chỉ đó được giữ bởi con trỏ sau khi gán địa chỉ cấp phát cho nó:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new int;\n\n//using memory area at p\n//and then set it free\n\ndelete p;</code></pre>\n\n<p>Lúc này, con trỏ p vẫn còn giữ địa chỉ của vùng nhớ đã được cấp phát trên <strong>Heap</strong>. Nếu may mắn, vùng nhớ đó chưa được hệ điều hành cấp phát cho chương trình khác, chúng ta vẫn có thể dùng con trỏ p để thay đổi giá trị bên trong nó.</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new int\n\ndelete p;\n\n//keep using that memory area\n*p = 10;\ncout &lt;&lt; p &lt;&lt; endl;</code></pre>\n\n<p>Nếu không may mắn, con trỏ p sẽ mang tội danh xâm nhập bất hợp pháp vào vùng nhớ của chương trình khác, và chương trình của chúng ta sẽ bị crash.</p>\n\n<h5>mean of delete operator</h5>\n\n<p>Sử dụng toán tử delete không có nghĩa là <strong>delete</strong> tất cả mọi thứ bên trong vùng nhớ mà con trỏ trỏ đến. Toán tử <strong>new và delete</strong> chỉ mang ý nghĩa về \"quyền sử dụng\" vùng nhớ. Toàn bộ dãy địa chỉ trên bộ nhớ ảo được quản lý bởi một chương trình mang tên \"Hệ điều hành\", và hệ điều hành có quyền trao lại quyền sử dụng một vùng nhớ nào đó (trên Stack hoặc trên Heap...) cho những chương trình đáng tin cậy trên máy tính. </p>\n\n<p>Và toán tử <strong>new</strong> dùng để làm hợp đồng sử dụng vùng nhớ trên <strong>Heap</strong>, các bạn lấy vùng nhớ được cấp phát thông qua hợp đồng (<strong>make by new operator</strong>) để chương trình chạy, vậy khi bạn sử dụng toán tử <strong>delete</strong>, đơn giản là bạn chỉ xé bản hợp đồng đó đi (hoặc đưa lại cho hệ điều hành). Lúc này, Giá trị trên vùng nhớ đó <strong>có thể</strong> vẫn còn giữ nguyên do chưa có chương trình nào can thiệp vào.</p>\n\n<p>Toán tử <strong>delete</strong> không tác động gì đến con trỏ.</p>\n\n<h5>Dangling pointer</h5>\n\n<p>\"Con trỏ bị treo\" thường xảy ra sau khi giải phóng vùng nhớ bằng toán tử <strong>delete</strong>. Sau khi sử dụng toán tử <strong>delete</strong>, vùng nhớ được cấp phát được trả lại cho hệ điều hành quản lý, nhưng con trỏ vẫn còn trỏ vào địa chỉ đó. Sử dụng toán tử <strong>dereference</strong> cho con trỏ tại thời điểm này sẽ gây ra lỗi <strong>undefined behavior</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    int *ptr = new int; // dynamically allocate an integer\n    *ptr = 7; // put a value in that memory location\n \n    delete ptr; // return the memory to the operating system.  ptr is now a dangling pointer.\n \n    std::cout &lt;&lt; *ptr; // Dereferencing a dangling pointer will cause undefined behavior\n    delete ptr; // trying to deallocate the memory again will also lead to undefined behavior.\n \n    return 0;\n}</code></pre>\n\n<p>Còn nhiều trường hợp khác nhau có thể khiến con trỏ bị treo, mình sẽ dành ra một bài học để nói về cách quản lý vùng nhớ và con trỏ khi sử dụng kỹ thuật <strong>Dynamic memory allocation</strong>.</p>\n\n<h5>Điều gì xảy ra khi xin cấp phát vùng nhớ trên Heap thất bại?</h5>\n\n<p>Quá trình cấp phát vùng nhớ trên <strong>Heap</strong> thất bại có thể do có chương trình nào đó đang sử dụng lượng bộ nhớ quá lớn (ví dụ chương trình tạo máy ảo), và chương trình của bạn yêu cầu cung cấp vùng nhớ có kích thước nên hệ điều hành không thế tìm thấy đoạn vùng nhớ nào đủ cho yêu cầu của chương trình của bạn.</p>\n\n<p>Chúng ta cùng xem lại các protoyte của toán tử new:</p>\n\n<p></p><pre><code class=\"lang-auto\">void* operator new (std::size_t size);  // (1)\nvoid* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) noexcept;  // (2)\nvoid* operator new (std::size_t size, void* ptr) noexcept;  // (3)</code></pre>\n\n<p>Mặc định, chúng ta sử dụng toán tử new ở cách khai báo (1), trong trường hợp này, nếu cấp phát vùng nhớ thất bại, toán tử new sẽ ném ra ngoại lệ <code>std::bad_alloc</code>. Nếu ngoại lệ này không được xử lý, chương trình chúng ta sẽ bị kết thúc với lỗi <strong>unhandled exception error</strong>.</p>\n\n<p>Trong một số trường hợp, chúng ta không muốn dính đến ngoại lệ (exception) trong C++, chúng ta nên chọn sử dụng phiên bản toán tử new (2), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new (std::nothrow) int;</code></pre>\n\n<p>Sử dụng cách này, nếu quá trình cấp phát thất bại, toán tử <strong>new</strong> sẽ trả về giá trị <strong>NULL</strong>. Lúc này, chúng ta có thể kiểm tra xem chương trình của chúng ta có xin được vùng nhớ hay không:</p>\n\n<p></p><pre><code class=\"lang-auto\">if (p == NULL)\n{\n    cout &lt;&lt; \"Could not allocate memory on Heap partition\" &lt;&lt; endl;\n    exit(1);\n}\nelse\n{\n    //use that memory area\n    //and then delete it\n    \n    delete p;\n}</code></pre>\n\n<p>Sử dụng cách này sẽ giúp chương trình chúng ta sử dụng con trỏ an toàn hơn khi sử dụng kỹ thuật <strong>Dynamic memory allocation</strong>.</p>\n\n<h3>Dynamically allocate arrays</h3>\n\n<p>Để xin cấp phát và giải phóng vùng nhớ cho mảng một chiều trên <strong>Heap</strong>, chúng ta cũng sử dụng toán tử <strong>new và delete</strong> để xử lý.</p>\n\n<h5>Dynamically allocate arrays</h5>\n\n<p>Đối với việc yêu cầu cấp phát bộ nhớ cho biến đơn trên <strong>Heap</strong>, chúng ta chỉ cần cung cấp kiểu dữ liệu cho toán tử <strong>new</strong>, hệ điều hành sẽ tự tính được kích thước cần cấp phát (tương tự việc sử dụng toán tử sizeof). Nhưng khi cần cấp phát một dãy vùng nhớ liên tục nhau (mảng một chiều), ngoài kiểu dữ liệu chúng ta cần cung cấp thêm số lượng phần tử.</p>\n\n<p></p><pre><code class=\"lang-auto\">new &lt;data_type&gt;[num_of_elements];</code></pre>\n\n<p>Nếu quá trình cấp phát thành công, toán tử <strong>new</strong> sẽ trả về địa chỉ của phần tử đầu tiên của vùng nhớ được cấp phát, và tương tự như cấp phát cho biến đơn, chúng ta cho 1 con trỏ có kiểu dữ liệu phù hợp lưu trữ địa trả về để quản lý vùng nhớ. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_arr = new int[10];\n\n//using this memory area\nfor (int i = 0; i &lt; 10; i++)\n{\n    //Set value for each element\n    cin &gt;&gt; *p_arr[i];\n}</code></pre>\n\n<p>Chúng ta có thể khởi tạo cho vùng nhớ đã được cấp phát tương tự như khởi tạo mảng một chiều thông thường. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int arr[5] = { 1, 2, 3, 4, 5 };\nint *p_arr = new int[5] { 1, 2, 3, 4, 5 }; //no operator = between array-size and initializer list</code></pre>\n\n<p><strong>Lưu ý cách này chỉ sử dụng được trong chuẩn C++11 trở lên.</strong></p>\n\n<p>Trường hợp mảng kí tự luôn là trường hợp đặc biệt của mảng một chiều. Chúng ta không thể sử dụng cách khởi tạo này trong chuẩn C++11:</p>\n\n<p></p><pre><code class=\"lang-auto\">char *c_str = new char [100] { \"Allocated on Heap partition\" };</code></pre>\n\n<p>Nhưng trường hợp này có thể chạy được trên Visual studio 2015 với chuẩn C++14.</p>\n\n<p>Điều khiến cho kỹ thuật <strong>Dynamic memory allocation</strong> khác với <strong>Static memory allocation</strong> là số lượng phần tử có thể được cung cấp trong khi chương trình đang chạy. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int num_of_elements;\ncout &lt;&lt; \"Enter number of elements you want to create: \";\ncin &gt;&gt; num_of_elements;\n\nint *p_arr = new int[num_of_elements];</code></pre>\n\n<p>Chúng ta sử dụng giá trị của biến <code>num_of_elements</code> làm số lượng phần tử cung cấp cho toán tử new, và giá trị này chỉ được xác định sau khi người dùng nhập vào từ bàn phím. Để hạn chế trường hợp người dùng nhập số âm, chúng ta cần kiểm tra trước khi xin cấp phát:</p>\n\n<p></p><pre><code class=\"lang-auto\">int num_of_elements;\ncout &lt;&lt; \"Enter number of elements you want to create: \";\ncin &gt;&gt; num_of_elements;\n\nif(num_of_elements &gt; 0)\n    int *p_arr = new int[num_of_elements];</code></pre>\n\n<h5>dynamically delete arrays</h5>\n\n<p>Đối với dãy vùng nhớ liên tục được cấp phát trên <strong>Heap</strong>, chúng ta cần thêm vào toán tử <code>[ ]</code> để báo với hệ điều hành rằng vùng nhớ đã được cấp phát không dùng cho một biến đơn.</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_arr = new int[10];\n\n//...........\n\ndelete[] p_arr;</code></pre>\n\n<p>Sử dụng toán tử <strong>delete</strong> theo cách giải phóng vùng nhớ biến đơn cho dãy vùng nhớ liên tục có thể gây ra nhiều vấn đề khác nhau cho chương trình (<strong>memory leak, data corruption</strong>, ...).</p>\n\n<h5>resizing dynamic arrays</h5>\n\n<p>Trong nhiều trường hợp, chúng ta cần thay đổi kích thước vùng nhớ đã được cấp phát cho phù hợp với yêu cầu của chương trình. Cách duy nhất là:</p>\n\n<ul>\n<li>Cấp phát lại vùng nhớ mới.</li>\n<li>(Copy dữ liệu từ vùng nhớ cũ sáng vùng nhớ mới nếu cần).</li>\n<li>Giải phóng vùng nhớ cũ.</li>\n<li>Cho con trỏ trỏ đến vùng nhớ mới.</li>\n</ul>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint *p = new int[5];\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\tcin &gt;&gt; *(p + i);\n\t}\n\n\t//re-allocate\n\tint *p_temp = p;\n\tp = new int[10];\n\n\t//copy data\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\t*(p + i) = *(p_temp + i);\n\t}\n\n\t//dealocate old memory area\n\tdelete[] p_temp;\n\n\t//keep using data\n\t//and then delete it\n\n\tdelete[] p;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Do vùng nhớ mới sẽ có địa chỉ khác với vùng nhớ đã cấp phát ban đầu, mình cần sử dụng con trỏ <code>p_temp</code> để giữ lại khả năng truy cập đến vùng nhớ ban đầu. Sau khi copy toàn bộ dữ liệu từ vùng nhớ cũ sang vùng nhớ mới, chúng ta nên giải phóng vùng nhớ cũ ngay để khỏi lãng phí tài nguyên hệ thông.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã tìm hiểu về kỹ thuật <strong>Dynamic memory allocation</strong> trong ngôn ngữ C++. Kỹ thuật này giúp chương trình chúng ta ít bị giới hạn dung lượng bộ nhớ hơn. Nhưng bên cạnh đó, chúng ta cần có kỹ năng về quản lý các vùng nhớ trong chương trình. Sử dụng kỹ thuật <strong>Dynamic memory allocation</strong> không thành thạo là nguyên nhân gây phổ biến gây ra lỗi <strong>memory leak</strong>. Do đó, chúng ta sẽ có một bài học nói về các lỗi thường gặp khi sử dụng <strong>Dynamic memory allocation</strong> và cách kiểm soát các lỗi này.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","rawBody":"\n<h4>Chào các bạn học viên đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong bài học này, mình sẽ tiếp tục giới thiệu đến các bạn một số vấn đề về con trỏ và sử dụng con trỏ để quản lý bộ nhớ ảo trong ngôn ngữ C++.</p>\n\n<p>Như mình đã đề cập trong bài học <a href=\"//daynhauhoc.com/t/pham-vi-cua-bien/29939\">phạm vi của biến</a>, thời gian tồn tại của biến phụ thuộc vào vị trí bạn khai báo biến.</p>\n\n<ul>\n<li>Biến toàn cục (<strong>global variable</strong>) được khai báo bên ngoài khối lệnh, có thể được truy xuất tại bất cứ dòng lệnh nào đặt bên dưới biến đó. Biến toàn cục tồn tại đến khi chương trình bị kết thúc.</li>\n<li>Biến cục bộ (<strong>local variable</strong>) được khai báo bên trong khối lệnh, có thể được truy xuất tại bất cứ dòng lệnh nào đặt bên dưới biến đó và trong cùng khối lệnh. Biến cục bộ bị hủy khi chương trình chạy ra ngoài khối lệnh chứa biến đó.</li>\n</ul>\n\n<p>Tương ứng với 2 kiểu khai báo biến này là 2 cách thức cấp phát bộ nhớ cho chương trình trên bộ nhớ ảo:</p>\n\n<h5>Static memory allocation (cấp phát bộ nhớ tĩnh)</h5>\n\n<p><strong>Static memory allocation</strong> còn được gọi là <strong>Compile-time allocation</strong>, được áp dụng cho biến <strong>static</strong> và biến toàn cục.</p>\n\n<ul>\n<li>Vùng nhớ của các biến này được cấp phát ngay khi chạy chương trình.</li>\n<li>Kích thước của vùng nhớ được cấp phát phải được cung cấp tại thời điểm biên dịch chương trình.</li>\n<li>Đối với việc khai báo mảng một chiều, đây là lý do tại sao số lượng phần tử là hằng số.</li>\n</ul>\n\n<h5>Automatic memory allocation (cấp phát bộ nhớ tự động)</h5>\n\n<p><strong>Automatic memory allocation</strong> được sử dụng để cấp phát vùng nhớ cho các biến cục bộ, tham số của hàm.</p>\n\n<ul>\n<li>Bộ nhớ được cấp phát tại thời điểm chương trình đang chạy, khi chương trình đi vào một khối lệnh.</li>\n<li>Các vùng nhớ được cấp phát sẽ được thu hồi khi chương trình đi ra khỏi một khối lệnh.</li>\n<li>Kích thước vùng cần cấp phát cũng phải được cung cấp rõ ràng.</li>\n</ul>\n\n<h5>Nhược điểm của các phương thức cấp phát bộ nhớ đã học</h5>\n\n<p><strong>Kích thước vùng nhớ cấp phát phải được cung cấp tại thời điểm biên dịch chương trình</strong></p>\n\n<p>Lấy ví dụ, chúng ta cần lưu trữ tên của tất cả sinh viên trong một lớp học. Chúng ta sẽ sử dụng một mảng các string để lưu trữ như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">string name_of_students[50];</code></pre>\n\n<p>Mình hiện tại không biết có bao nhiêu sinh viên trong một lớp học, nên mình chỉ ước tính con số tối đa lượng sinh viên của lớp này là 50 người. Vậy điều gì xảy ra khi lớp học có nhiều hơn 50 sinh viên? Mảng <code>name_of_students</code> sẽ không thể lưu hết tên của tất cả sinh viên được. Bên cạnh đó, nếu số lượng sinh viên của lớp học chỉ có 30 người, mảng <code>name_of_students</code> sẽ thừa ra 20 phần tử không cần sử dụng đến.</p>\n\n<p><strong>Cấp phát và thu hồi vùng nhớ do chương trình quyết định</strong></p>\n\n<p>Trong một số trường hợp, chúng ta cần sử dụng biến toàn cục để có thể truy cập vùng nhớ của biến tại nhiều khối lệnh khác nhau trong chương trình, nhưng thời gian tồn tại của biến toàn cục khá lâu, nên khi sử dụng biến toàn cục sẽ gây ảnh hưởng đáng kể lượng tài nguyên bộ nhớ của máy tính nếu chúng ta cấp phát cho biến toàn cục một vùng nhớ lớn.</p>\n\n<p>Hoặc trong một số trường hợp khác, chúng ta vẫn muốn sử dụng tiếp vùng nhớ cấp phát cho biến bên trong hàm, nhưng biến cục bộ đặt trong khối lệnh (cùng với vùng nhớ nó quản lý) sẽ bị hủy khi hàm kết thúc.</p>\n\n<p><strong>Kích thước bộ nhớ dùng cho Static memory allocation và Automatic memory allocation bị giới hạn</strong></p>\n\n<p>Bộ nhớ ảo được chia thành nhiều phân vùng khác nhau sử dụng cho những loại tài nguyên khác nhau. Trong đó, các phương thức cấp phát bộ nhớ <strong>Static memory allocation</strong> hay <strong>Automatic memory allocation</strong> sẽ sử dụng phân vùng <strong>Stack</strong> để lưu trữ. Chúng ta sẽ có một bài học để nói chi tiết về các phân vùng trên bộ nhớ ảo. Bây giờ các bạn tạm thời hình dung bộ nhớ ảo chúng ta sẽ chia thành các phần như sau:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Phân vùng <strong>Stack</strong> được đặt tại vùng có địa chỉ cao nhất trong dãy bộ nhớ ảo. Dung lượng của phân vùng này khá hạn chế. Tùy vào mỗi hệ điều hành mà dung lượng bộ nhớ của phân vùng <strong>Stack</strong> khác nhau. Đối với Visual studio 2015 chạy trên hệ điều hành Windows, dung lượng bộ nhớ của phân vùng <strong>Stack</strong> là khoảng 1MB (tương đương khoảng 1024 bytes).</p>\n\n<p>Với sự hạn chế về dung lượng bộ nhớ của phân vùng <strong>Stack</strong>, chương trình của chúng ta sẽ phát sinh lỗi <strong>stack overflow</strong> nếu các bạn yêu cầu cấp phát vùng nhớ vượt quá dung lượng của <strong>Stack</strong>. Các bạn có thể chạy thử 2 đoạn chương trình sau để kiểm chứng:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    char ch_array[1024 * 1000];\n\n    system(\"pause\");\n    return 0;\n}</code></pre>\n\n<p>Trong đoạn chương trình trên, mình khai báo một mảng kí tự có tên <code>ch_array</code>, như các bạn biết kiểu char có kích thước 1 byte cho mỗi biến đơn (tương ứng với mỗi phần tử trong mảng kí tự), 1024 bytes sẽ tương ứng với 1Kb (Kilobyte). Do <code>ch_array</code> là biến cục bộ, nó sẽ được cấp phát vùng nhớ trên phân vùng Stack của bộ nhớ ảo. Như vậy, mảng <code>ch_array</code> sẽ được cấp phát 1000 kilobytes trên phân vùng Stack, nhưng con số này vẫn chưa vượt quá giới hạn 1Mb (1 Megabyte = 1024 Kilobytes) nên chương trình vẫn chạy bình thường. Bây giờ các bạn thử lại với đoạn chương trình sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    char ch_array[1024 * 1024];\n\n    system(\"pause\");\n    return 0;\n}</code></pre>\n\n<p>Kích thước vùng nhớ được yêu cầu cấp phát bây giờ là đúng bằng <strong>1 Mb</strong>. Thử chạy chương trình ở chế độ Debug, Visual Studio 2015 trên máy tính mình đưa ra thông báo:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/1.png?raw=true\" width=\"545\" height=\"311\"></p>\n\n<p>Việc cấp phát vùng nhớ có kích thước 1 Mb đã gây tràn bộ nhớ phân vùng Stack.</p>\n\n<p>Đây là một số hạn chế của các phương thức cấp phát bộ nhớ <strong>Static memory allocation và Automatic memory allocation</strong>. Để khắc phục hạn chế này, mình giới thiệu đến các bạn một phương thức cấp phát bộ nhớ mới được ngôn ngữ C++ hổ trợ.</p>\n\n<h3>Dynamic memory allocation</h3>\n\n<p><strong>Dynamic memory allocation</strong> là một giải pháp cấp phát bộ nhớ cho chương trình tại thời điểm chương trình đang chạy (run-time). <strong>Dynamic memory allocation</strong> sử dụng phân vùng <strong>Heap</strong> trên bộ nhớ ảo để cấp phát cho chương trình.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như các bạn thấy trong hình trên, phân vùng <strong>Heap</strong> của bộ nhớ ảo có dung lượng bộ nhớ lớn nhất. Do đó, bộ nhớ dùng để cấp phát cho chương trình trên phân vùng Heap chỉ bị giới hạn bởi thiết bị phần cứng (ví dụ là RAM) chứ không phụ thuộc vào hệ điều hành. Trong các máy tính hiện đại ngày nay, dung lượng bộ nhớ của phân vùng <strong>Heap</strong> có thể lên đến đơn vị GB (<code>1 Gigabyte = 1024 Megabytes = 1024 * 1024 Kilobytes</code>).</p>\n\n<h5>Đọc kỹ hướng dẫn sử dụng trước khi dùng</h5>\n\n<p>Kỹ thuật <strong>Dynamic memory allocation</strong> dùng để cấp phát bộ nhớ tại thời điểm run-time. Tại thời điểm này, chúng ta không thể tạo ra tên biến mới, mà chỉ có thể tạo ra vùng nhớ mới. Do đó, cách duy nhất để kiểm soát được những vùng nhớ được cấp phát bằng kỹ thuật <strong>Dynamic memory allocation</strong> là sử dụng con trỏ lưu trữ địa chỉ đầu tiên của vùng nhớ được cấp phát, thông qua con trỏ để quản lý vùng nhớ trên <strong>Heap</strong>.</p>\n\n<p>Vậy, việc thực hiện cấp phát bộ nhớ cần thực hiện qua 2 bước:</p>\n\n<ul>\n<li>Yêu cầu cấp phát vùng nhớ trên <strong>Heap</strong>.</li>\n<li>Lưu trữ địa chỉ của vùng nhớ vừa được cấp phát bằng con trỏ.</li>\n</ul>\n\n<p><strong>Để yêu cầu cấp phát bộ nhớ trên Heap, chúng ta sử dụng new operator.</strong></p>\n\n<p>Vùng nhớ được cấp phát trên Heap sẽ không tự động hủy bởi chương trình khi kết thúc khối lệnh, việc thu hồi vùng nhớ đã cấp phát trên Heap được giao cho lập trình viên tự quản lý. Nếu trong chương trình có yêu cầu cấp phát bộ nhớ trên Heap mà không được thu hồi hợp lý sẽ gây lãng phí tài nguyên hệ thống. Cũng giống như xin nhà nước cấp phát cho một vùng đất để xây dựng nhà máy, đang xây giữa chừng thì bên thầu công trình ăn hết vốn nên dự án xây dựng nhà máy bị hoãn lại, nhưng đất được nhà nước cấp phát không được trả lại cho nhà nước để làm việc khác, thế là lãng phí một vùng đất mà không làm được gì, tài nguyên trên máy tính cũng tương tự như vậy. </p>\n\n<p><strong>Để thu hồi vùng nhớ đã được cấp phát thông qua toán tử new, chúng ta sử dụng toán tử delete.</strong></p>\n\n<h3>Dynamically allocate single variables</h3>\n\n<h5>new operator</h5>\n\n<p>Toán tử new được dùng để xin cấp phát vùng nhớ trên phân vùng Heap của bộ nhớ ảo.</p>\n\n<p>Toán tử new trong chuẩn C++11 được định nghĩa với <strong>3 prototype</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void* operator new (std::size_t size);\nvoid* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) noexcept;\nvoid* operator new (std::size_t size, void* ptr) noexcept;</code></pre>\n\n<p>Các bạn chưa cần phải hiểu những tham số khai báo cho toán tử <strong>new</strong>, mà hiện tại chỉ cần chú ý kiểu trả về của nó (<code>void *</code>). Toán tử new sau khi xin cấp phát vùng nhớ trên <strong>Heap</strong> sẽ trả về một con trỏ chứa địa chỉ của vùng nhớ được cấp phát (nếu cấp phát thành công).</p>\n\n<p>Kiểu trả về của  toán tử <strong>new</strong> là con trỏ kiểu <strong>void</strong>, đây là một con trỏ đặc biệt, chúng ta sẽ tìm hiểu nó trong bài học sau. Nhưng dù nó là con trỏ kiểu gì thì mục đích của nó vẫn là chứa địa chỉ, do đó, chúng ta có thể gán giá trị trả về của toán tử <strong>new</strong> cho một con trỏ khác để quản lý vùng nhớ đã được cấp phát.</p>\n\n<h5>usage of new operator</h5>\n\n<p>Cú pháp sử dụng toán tử <strong>new</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">new &lt;data_type&gt;;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">new int; //allocate 4 bytes on Heap partition to an int variable\nnew double; //allocate 8 bytes on Heap partition to a double variable</code></pre>\n\n<p>Khi chương trình đang chạy, nếu quá trình cấp phát bộ nhớ trên thành công, chúng ta sẽ có địa chỉ của 2 vùng nhớ được trả về. Nhưng như mình đã nói, chúng ta không thể tạo thêm tên biến mới khi chương trình đang chạy, do đó chúng ta cần gán nó cho những con trỏ cùng kiểu để quản lý:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_int = new int;\ndouble *p_double = new double;</code></pre>\n\n<p>Bây giờ, vùng nhớ được cấp phát sẽ được quản lý bởi 2 con trỏ <code>p_int</code> và <code>p_double</code>, 2 vùng nhớ này được hệ điều hành trao quyền sử dụng tạm thời cho chương trình của chúng ta, thông qua con trỏ, chúng ta có thể thay đổi giá trị bên trong vùng nhớ này. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_int = new int;\ncout &lt;&lt; \"Put value into memory area\" &lt;&lt; endl;\ncin &gt;&gt; *p_int;\ncout &lt;&lt; \"Value at \" &lt;&lt; p_int &lt;&lt; \" is \" &lt;&lt; *p_int &lt;&lt; endl;</code></pre>\n\n<p>Chúng ta còn có thể vừa cấp phát bộ nhớ vừa khởi tạo giá trị tại vùng nhớ đó cho một biến đơn:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p1 = new int(5);\nint *p2 = new int { *p1 };</code></pre>\n\n<h5>usage of delete operator</h5>\n\n<p>Khi không muốn sử dụng tiếp vùng nhớ đã được cấp phát cho chương trình trên <strong>Heap</strong>, chúng ta nên trả lại vùng nhớ đó cho hệ điều hành. Thật ra khi chương trình kết thúc, tất cả vùng nhớ của chương trình đều bị hệ điều hành thu hồi, nhưng chúng ta nên giải phóng vùng nhớ không cần thiết càng sớm càng tốt.</p>\n\n<p>Để xóa một vùng nhớ, chúng ta cần có một địa chỉ cụ thể, địa chỉ đó được giữ bởi con trỏ sau khi gán địa chỉ cấp phát cho nó:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new int;\n\n//using memory area at p\n//and then set it free\n\ndelete p;</code></pre>\n\n<p>Lúc này, con trỏ p vẫn còn giữ địa chỉ của vùng nhớ đã được cấp phát trên <strong>Heap</strong>. Nếu may mắn, vùng nhớ đó chưa được hệ điều hành cấp phát cho chương trình khác, chúng ta vẫn có thể dùng con trỏ p để thay đổi giá trị bên trong nó.</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new int\n\ndelete p;\n\n//keep using that memory area\n*p = 10;\ncout &lt;&lt; p &lt;&lt; endl;</code></pre>\n\n<p>Nếu không may mắn, con trỏ p sẽ mang tội danh xâm nhập bất hợp pháp vào vùng nhớ của chương trình khác, và chương trình của chúng ta sẽ bị crash.</p>\n\n<h5>mean of delete operator</h5>\n\n<p>Sử dụng toán tử delete không có nghĩa là <strong>delete</strong> tất cả mọi thứ bên trong vùng nhớ mà con trỏ trỏ đến. Toán tử <strong>new và delete</strong> chỉ mang ý nghĩa về \"quyền sử dụng\" vùng nhớ. Toàn bộ dãy địa chỉ trên bộ nhớ ảo được quản lý bởi một chương trình mang tên \"Hệ điều hành\", và hệ điều hành có quyền trao lại quyền sử dụng một vùng nhớ nào đó (trên Stack hoặc trên Heap...) cho những chương trình đáng tin cậy trên máy tính. </p>\n\n<p>Và toán tử <strong>new</strong> dùng để làm hợp đồng sử dụng vùng nhớ trên <strong>Heap</strong>, các bạn lấy vùng nhớ được cấp phát thông qua hợp đồng (<strong>make by new operator</strong>) để chương trình chạy, vậy khi bạn sử dụng toán tử <strong>delete</strong>, đơn giản là bạn chỉ xé bản hợp đồng đó đi (hoặc đưa lại cho hệ điều hành). Lúc này, Giá trị trên vùng nhớ đó <strong>có thể</strong> vẫn còn giữ nguyên do chưa có chương trình nào can thiệp vào.</p>\n\n<p>Toán tử <strong>delete</strong> không tác động gì đến con trỏ.</p>\n\n<h5>Dangling pointer</h5>\n\n<p>\"Con trỏ bị treo\" thường xảy ra sau khi giải phóng vùng nhớ bằng toán tử <strong>delete</strong>. Sau khi sử dụng toán tử <strong>delete</strong>, vùng nhớ được cấp phát được trả lại cho hệ điều hành quản lý, nhưng con trỏ vẫn còn trỏ vào địa chỉ đó. Sử dụng toán tử <strong>dereference</strong> cho con trỏ tại thời điểm này sẽ gây ra lỗi <strong>undefined behavior</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    int *ptr = new int; // dynamically allocate an integer\n    *ptr = 7; // put a value in that memory location\n \n    delete ptr; // return the memory to the operating system.  ptr is now a dangling pointer.\n \n    std::cout &lt;&lt; *ptr; // Dereferencing a dangling pointer will cause undefined behavior\n    delete ptr; // trying to deallocate the memory again will also lead to undefined behavior.\n \n    return 0;\n}</code></pre>\n\n<p>Còn nhiều trường hợp khác nhau có thể khiến con trỏ bị treo, mình sẽ dành ra một bài học để nói về cách quản lý vùng nhớ và con trỏ khi sử dụng kỹ thuật <strong>Dynamic memory allocation</strong>.</p>\n\n<h5>Điều gì xảy ra khi xin cấp phát vùng nhớ trên Heap thất bại?</h5>\n\n<p>Quá trình cấp phát vùng nhớ trên <strong>Heap</strong> thất bại có thể do có chương trình nào đó đang sử dụng lượng bộ nhớ quá lớn (ví dụ chương trình tạo máy ảo), và chương trình của bạn yêu cầu cung cấp vùng nhớ có kích thước nên hệ điều hành không thế tìm thấy đoạn vùng nhớ nào đủ cho yêu cầu của chương trình của bạn.</p>\n\n<p>Chúng ta cùng xem lại các protoyte của toán tử new:</p>\n\n<p></p><pre><code class=\"lang-auto\">void* operator new (std::size_t size);  // (1)\nvoid* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) noexcept;  // (2)\nvoid* operator new (std::size_t size, void* ptr) noexcept;  // (3)</code></pre>\n\n<p>Mặc định, chúng ta sử dụng toán tử new ở cách khai báo (1), trong trường hợp này, nếu cấp phát vùng nhớ thất bại, toán tử new sẽ ném ra ngoại lệ <code>std::bad_alloc</code>. Nếu ngoại lệ này không được xử lý, chương trình chúng ta sẽ bị kết thúc với lỗi <strong>unhandled exception error</strong>.</p>\n\n<p>Trong một số trường hợp, chúng ta không muốn dính đến ngoại lệ (exception) trong C++, chúng ta nên chọn sử dụng phiên bản toán tử new (2), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new (std::nothrow) int;</code></pre>\n\n<p>Sử dụng cách này, nếu quá trình cấp phát thất bại, toán tử <strong>new</strong> sẽ trả về giá trị <strong>NULL</strong>. Lúc này, chúng ta có thể kiểm tra xem chương trình của chúng ta có xin được vùng nhớ hay không:</p>\n\n<p></p><pre><code class=\"lang-auto\">if (p == NULL)\n{\n    cout &lt;&lt; \"Could not allocate memory on Heap partition\" &lt;&lt; endl;\n    exit(1);\n}\nelse\n{\n    //use that memory area\n    //and then delete it\n    \n    delete p;\n}</code></pre>\n\n<p>Sử dụng cách này sẽ giúp chương trình chúng ta sử dụng con trỏ an toàn hơn khi sử dụng kỹ thuật <strong>Dynamic memory allocation</strong>.</p>\n\n<h3>Dynamically allocate arrays</h3>\n\n<p>Để xin cấp phát và giải phóng vùng nhớ cho mảng một chiều trên <strong>Heap</strong>, chúng ta cũng sử dụng toán tử <strong>new và delete</strong> để xử lý.</p>\n\n<h5>Dynamically allocate arrays</h5>\n\n<p>Đối với việc yêu cầu cấp phát bộ nhớ cho biến đơn trên <strong>Heap</strong>, chúng ta chỉ cần cung cấp kiểu dữ liệu cho toán tử <strong>new</strong>, hệ điều hành sẽ tự tính được kích thước cần cấp phát (tương tự việc sử dụng toán tử sizeof). Nhưng khi cần cấp phát một dãy vùng nhớ liên tục nhau (mảng một chiều), ngoài kiểu dữ liệu chúng ta cần cung cấp thêm số lượng phần tử.</p>\n\n<p></p><pre><code class=\"lang-auto\">new &lt;data_type&gt;[num_of_elements];</code></pre>\n\n<p>Nếu quá trình cấp phát thành công, toán tử <strong>new</strong> sẽ trả về địa chỉ của phần tử đầu tiên của vùng nhớ được cấp phát, và tương tự như cấp phát cho biến đơn, chúng ta cho 1 con trỏ có kiểu dữ liệu phù hợp lưu trữ địa trả về để quản lý vùng nhớ. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_arr = new int[10];\n\n//using this memory area\nfor (int i = 0; i &lt; 10; i++)\n{\n    //Set value for each element\n    cin &gt;&gt; *p_arr[i];\n}</code></pre>\n\n<p>Chúng ta có thể khởi tạo cho vùng nhớ đã được cấp phát tương tự như khởi tạo mảng một chiều thông thường. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int arr[5] = { 1, 2, 3, 4, 5 };\nint *p_arr = new int[5] { 1, 2, 3, 4, 5 }; //no operator = between array-size and initializer list</code></pre>\n\n<p><strong>Lưu ý cách này chỉ sử dụng được trong chuẩn C++11 trở lên.</strong></p>\n\n<p>Trường hợp mảng kí tự luôn là trường hợp đặc biệt của mảng một chiều. Chúng ta không thể sử dụng cách khởi tạo này trong chuẩn C++11:</p>\n\n<p></p><pre><code class=\"lang-auto\">char *c_str = new char [100] { \"Allocated on Heap partition\" };</code></pre>\n\n<p>Nhưng trường hợp này có thể chạy được trên Visual studio 2015 với chuẩn C++14.</p>\n\n<p>Điều khiến cho kỹ thuật <strong>Dynamic memory allocation</strong> khác với <strong>Static memory allocation</strong> là số lượng phần tử có thể được cung cấp trong khi chương trình đang chạy. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int num_of_elements;\ncout &lt;&lt; \"Enter number of elements you want to create: \";\ncin &gt;&gt; num_of_elements;\n\nint *p_arr = new int[num_of_elements];</code></pre>\n\n<p>Chúng ta sử dụng giá trị của biến <code>num_of_elements</code> làm số lượng phần tử cung cấp cho toán tử new, và giá trị này chỉ được xác định sau khi người dùng nhập vào từ bàn phím. Để hạn chế trường hợp người dùng nhập số âm, chúng ta cần kiểm tra trước khi xin cấp phát:</p>\n\n<p></p><pre><code class=\"lang-auto\">int num_of_elements;\ncout &lt;&lt; \"Enter number of elements you want to create: \";\ncin &gt;&gt; num_of_elements;\n\nif(num_of_elements &gt; 0)\n    int *p_arr = new int[num_of_elements];</code></pre>\n\n<h5>dynamically delete arrays</h5>\n\n<p>Đối với dãy vùng nhớ liên tục được cấp phát trên <strong>Heap</strong>, chúng ta cần thêm vào toán tử <code>[ ]</code> để báo với hệ điều hành rằng vùng nhớ đã được cấp phát không dùng cho một biến đơn.</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_arr = new int[10];\n\n//...........\n\ndelete[] p_arr;</code></pre>\n\n<p>Sử dụng toán tử <strong>delete</strong> theo cách giải phóng vùng nhớ biến đơn cho dãy vùng nhớ liên tục có thể gây ra nhiều vấn đề khác nhau cho chương trình (<strong>memory leak, data corruption</strong>, ...).</p>\n\n<h5>resizing dynamic arrays</h5>\n\n<p>Trong nhiều trường hợp, chúng ta cần thay đổi kích thước vùng nhớ đã được cấp phát cho phù hợp với yêu cầu của chương trình. Cách duy nhất là:</p>\n\n<ul>\n<li>Cấp phát lại vùng nhớ mới.</li>\n<li>(Copy dữ liệu từ vùng nhớ cũ sáng vùng nhớ mới nếu cần).</li>\n<li>Giải phóng vùng nhớ cũ.</li>\n<li>Cho con trỏ trỏ đến vùng nhớ mới.</li>\n</ul>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint *p = new int[5];\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\tcin &gt;&gt; *(p + i);\n\t}\n\n\t//re-allocate\n\tint *p_temp = p;\n\tp = new int[10];\n\n\t//copy data\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\t*(p + i) = *(p_temp + i);\n\t}\n\n\t//dealocate old memory area\n\tdelete[] p_temp;\n\n\t//keep using data\n\t//and then delete it\n\n\tdelete[] p;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Do vùng nhớ mới sẽ có địa chỉ khác với vùng nhớ đã cấp phát ban đầu, mình cần sử dụng con trỏ <code>p_temp</code> để giữ lại khả năng truy cập đến vùng nhớ ban đầu. Sau khi copy toàn bộ dữ liệu từ vùng nhớ cũ sang vùng nhớ mới, chúng ta nên giải phóng vùng nhớ cũ ngay để khỏi lãng phí tài nguyên hệ thông.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã tìm hiểu về kỹ thuật <strong>Dynamic memory allocation</strong> trong ngôn ngữ C++. Kỹ thuật này giúp chương trình chúng ta ít bị giới hạn dung lượng bộ nhớ hơn. Nhưng bên cạnh đó, chúng ta cần có kỹ năng về quản lý các vùng nhớ trong chương trình. Sử dụng kỹ thuật <strong>Dynamic memory allocation</strong> không thành thạo là nguyên nhân gây phổ biến gây ra lỗi <strong>memory leak</strong>. Do đó, chúng ta sẽ có một bài học nói về các lỗi thường gặp khi sử dụng <strong>Dynamic memory allocation</strong> và cách kiểm soát các lỗi này.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","raw":"---json\n{\"title\":\"8.4 Cấp phát bộ nhớ động\",\"route\":\"8/4-cap-phat-bo-nho-dong\",\"id\":31145}\n---\n\n<h4>Chào các bạn học viên đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong bài học này, mình sẽ tiếp tục giới thiệu đến các bạn một số vấn đề về con trỏ và sử dụng con trỏ để quản lý bộ nhớ ảo trong ngôn ngữ C++.</p>\n\n<p>Như mình đã đề cập trong bài học <a href=\"//daynhauhoc.com/t/pham-vi-cua-bien/29939\">phạm vi của biến</a>, thời gian tồn tại của biến phụ thuộc vào vị trí bạn khai báo biến.</p>\n\n<ul>\n<li>Biến toàn cục (<strong>global variable</strong>) được khai báo bên ngoài khối lệnh, có thể được truy xuất tại bất cứ dòng lệnh nào đặt bên dưới biến đó. Biến toàn cục tồn tại đến khi chương trình bị kết thúc.</li>\n<li>Biến cục bộ (<strong>local variable</strong>) được khai báo bên trong khối lệnh, có thể được truy xuất tại bất cứ dòng lệnh nào đặt bên dưới biến đó và trong cùng khối lệnh. Biến cục bộ bị hủy khi chương trình chạy ra ngoài khối lệnh chứa biến đó.</li>\n</ul>\n\n<p>Tương ứng với 2 kiểu khai báo biến này là 2 cách thức cấp phát bộ nhớ cho chương trình trên bộ nhớ ảo:</p>\n\n<h5>Static memory allocation (cấp phát bộ nhớ tĩnh)</h5>\n\n<p><strong>Static memory allocation</strong> còn được gọi là <strong>Compile-time allocation</strong>, được áp dụng cho biến <strong>static</strong> và biến toàn cục.</p>\n\n<ul>\n<li>Vùng nhớ của các biến này được cấp phát ngay khi chạy chương trình.</li>\n<li>Kích thước của vùng nhớ được cấp phát phải được cung cấp tại thời điểm biên dịch chương trình.</li>\n<li>Đối với việc khai báo mảng một chiều, đây là lý do tại sao số lượng phần tử là hằng số.</li>\n</ul>\n\n<h5>Automatic memory allocation (cấp phát bộ nhớ tự động)</h5>\n\n<p><strong>Automatic memory allocation</strong> được sử dụng để cấp phát vùng nhớ cho các biến cục bộ, tham số của hàm.</p>\n\n<ul>\n<li>Bộ nhớ được cấp phát tại thời điểm chương trình đang chạy, khi chương trình đi vào một khối lệnh.</li>\n<li>Các vùng nhớ được cấp phát sẽ được thu hồi khi chương trình đi ra khỏi một khối lệnh.</li>\n<li>Kích thước vùng cần cấp phát cũng phải được cung cấp rõ ràng.</li>\n</ul>\n\n<h5>Nhược điểm của các phương thức cấp phát bộ nhớ đã học</h5>\n\n<p><strong>Kích thước vùng nhớ cấp phát phải được cung cấp tại thời điểm biên dịch chương trình</strong></p>\n\n<p>Lấy ví dụ, chúng ta cần lưu trữ tên của tất cả sinh viên trong một lớp học. Chúng ta sẽ sử dụng một mảng các string để lưu trữ như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">string name_of_students[50];</code></pre>\n\n<p>Mình hiện tại không biết có bao nhiêu sinh viên trong một lớp học, nên mình chỉ ước tính con số tối đa lượng sinh viên của lớp này là 50 người. Vậy điều gì xảy ra khi lớp học có nhiều hơn 50 sinh viên? Mảng <code>name_of_students</code> sẽ không thể lưu hết tên của tất cả sinh viên được. Bên cạnh đó, nếu số lượng sinh viên của lớp học chỉ có 30 người, mảng <code>name_of_students</code> sẽ thừa ra 20 phần tử không cần sử dụng đến.</p>\n\n<p><strong>Cấp phát và thu hồi vùng nhớ do chương trình quyết định</strong></p>\n\n<p>Trong một số trường hợp, chúng ta cần sử dụng biến toàn cục để có thể truy cập vùng nhớ của biến tại nhiều khối lệnh khác nhau trong chương trình, nhưng thời gian tồn tại của biến toàn cục khá lâu, nên khi sử dụng biến toàn cục sẽ gây ảnh hưởng đáng kể lượng tài nguyên bộ nhớ của máy tính nếu chúng ta cấp phát cho biến toàn cục một vùng nhớ lớn.</p>\n\n<p>Hoặc trong một số trường hợp khác, chúng ta vẫn muốn sử dụng tiếp vùng nhớ cấp phát cho biến bên trong hàm, nhưng biến cục bộ đặt trong khối lệnh (cùng với vùng nhớ nó quản lý) sẽ bị hủy khi hàm kết thúc.</p>\n\n<p><strong>Kích thước bộ nhớ dùng cho Static memory allocation và Automatic memory allocation bị giới hạn</strong></p>\n\n<p>Bộ nhớ ảo được chia thành nhiều phân vùng khác nhau sử dụng cho những loại tài nguyên khác nhau. Trong đó, các phương thức cấp phát bộ nhớ <strong>Static memory allocation</strong> hay <strong>Automatic memory allocation</strong> sẽ sử dụng phân vùng <strong>Stack</strong> để lưu trữ. Chúng ta sẽ có một bài học để nói chi tiết về các phân vùng trên bộ nhớ ảo. Bây giờ các bạn tạm thời hình dung bộ nhớ ảo chúng ta sẽ chia thành các phần như sau:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Phân vùng <strong>Stack</strong> được đặt tại vùng có địa chỉ cao nhất trong dãy bộ nhớ ảo. Dung lượng của phân vùng này khá hạn chế. Tùy vào mỗi hệ điều hành mà dung lượng bộ nhớ của phân vùng <strong>Stack</strong> khác nhau. Đối với Visual studio 2015 chạy trên hệ điều hành Windows, dung lượng bộ nhớ của phân vùng <strong>Stack</strong> là khoảng 1MB (tương đương khoảng 1024 bytes).</p>\n\n<p>Với sự hạn chế về dung lượng bộ nhớ của phân vùng <strong>Stack</strong>, chương trình của chúng ta sẽ phát sinh lỗi <strong>stack overflow</strong> nếu các bạn yêu cầu cấp phát vùng nhớ vượt quá dung lượng của <strong>Stack</strong>. Các bạn có thể chạy thử 2 đoạn chương trình sau để kiểm chứng:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    char ch_array[1024 * 1000];\n\n    system(\"pause\");\n    return 0;\n}</code></pre>\n\n<p>Trong đoạn chương trình trên, mình khai báo một mảng kí tự có tên <code>ch_array</code>, như các bạn biết kiểu char có kích thước 1 byte cho mỗi biến đơn (tương ứng với mỗi phần tử trong mảng kí tự), 1024 bytes sẽ tương ứng với 1Kb (Kilobyte). Do <code>ch_array</code> là biến cục bộ, nó sẽ được cấp phát vùng nhớ trên phân vùng Stack của bộ nhớ ảo. Như vậy, mảng <code>ch_array</code> sẽ được cấp phát 1000 kilobytes trên phân vùng Stack, nhưng con số này vẫn chưa vượt quá giới hạn 1Mb (1 Megabyte = 1024 Kilobytes) nên chương trình vẫn chạy bình thường. Bây giờ các bạn thử lại với đoạn chương trình sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    char ch_array[1024 * 1024];\n\n    system(\"pause\");\n    return 0;\n}</code></pre>\n\n<p>Kích thước vùng nhớ được yêu cầu cấp phát bây giờ là đúng bằng <strong>1 Mb</strong>. Thử chạy chương trình ở chế độ Debug, Visual Studio 2015 trên máy tính mình đưa ra thông báo:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/1.png?raw=true\" width=\"545\" height=\"311\"></p>\n\n<p>Việc cấp phát vùng nhớ có kích thước 1 Mb đã gây tràn bộ nhớ phân vùng Stack.</p>\n\n<p>Đây là một số hạn chế của các phương thức cấp phát bộ nhớ <strong>Static memory allocation và Automatic memory allocation</strong>. Để khắc phục hạn chế này, mình giới thiệu đến các bạn một phương thức cấp phát bộ nhớ mới được ngôn ngữ C++ hổ trợ.</p>\n\n<h3>Dynamic memory allocation</h3>\n\n<p><strong>Dynamic memory allocation</strong> là một giải pháp cấp phát bộ nhớ cho chương trình tại thời điểm chương trình đang chạy (run-time). <strong>Dynamic memory allocation</strong> sử dụng phân vùng <strong>Heap</strong> trên bộ nhớ ảo để cấp phát cho chương trình.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-4-cap-phat-dong/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như các bạn thấy trong hình trên, phân vùng <strong>Heap</strong> của bộ nhớ ảo có dung lượng bộ nhớ lớn nhất. Do đó, bộ nhớ dùng để cấp phát cho chương trình trên phân vùng Heap chỉ bị giới hạn bởi thiết bị phần cứng (ví dụ là RAM) chứ không phụ thuộc vào hệ điều hành. Trong các máy tính hiện đại ngày nay, dung lượng bộ nhớ của phân vùng <strong>Heap</strong> có thể lên đến đơn vị GB (<code>1 Gigabyte = 1024 Megabytes = 1024 * 1024 Kilobytes</code>).</p>\n\n<h5>Đọc kỹ hướng dẫn sử dụng trước khi dùng</h5>\n\n<p>Kỹ thuật <strong>Dynamic memory allocation</strong> dùng để cấp phát bộ nhớ tại thời điểm run-time. Tại thời điểm này, chúng ta không thể tạo ra tên biến mới, mà chỉ có thể tạo ra vùng nhớ mới. Do đó, cách duy nhất để kiểm soát được những vùng nhớ được cấp phát bằng kỹ thuật <strong>Dynamic memory allocation</strong> là sử dụng con trỏ lưu trữ địa chỉ đầu tiên của vùng nhớ được cấp phát, thông qua con trỏ để quản lý vùng nhớ trên <strong>Heap</strong>.</p>\n\n<p>Vậy, việc thực hiện cấp phát bộ nhớ cần thực hiện qua 2 bước:</p>\n\n<ul>\n<li>Yêu cầu cấp phát vùng nhớ trên <strong>Heap</strong>.</li>\n<li>Lưu trữ địa chỉ của vùng nhớ vừa được cấp phát bằng con trỏ.</li>\n</ul>\n\n<p><strong>Để yêu cầu cấp phát bộ nhớ trên Heap, chúng ta sử dụng new operator.</strong></p>\n\n<p>Vùng nhớ được cấp phát trên Heap sẽ không tự động hủy bởi chương trình khi kết thúc khối lệnh, việc thu hồi vùng nhớ đã cấp phát trên Heap được giao cho lập trình viên tự quản lý. Nếu trong chương trình có yêu cầu cấp phát bộ nhớ trên Heap mà không được thu hồi hợp lý sẽ gây lãng phí tài nguyên hệ thống. Cũng giống như xin nhà nước cấp phát cho một vùng đất để xây dựng nhà máy, đang xây giữa chừng thì bên thầu công trình ăn hết vốn nên dự án xây dựng nhà máy bị hoãn lại, nhưng đất được nhà nước cấp phát không được trả lại cho nhà nước để làm việc khác, thế là lãng phí một vùng đất mà không làm được gì, tài nguyên trên máy tính cũng tương tự như vậy. </p>\n\n<p><strong>Để thu hồi vùng nhớ đã được cấp phát thông qua toán tử new, chúng ta sử dụng toán tử delete.</strong></p>\n\n<h3>Dynamically allocate single variables</h3>\n\n<h5>new operator</h5>\n\n<p>Toán tử new được dùng để xin cấp phát vùng nhớ trên phân vùng Heap của bộ nhớ ảo.</p>\n\n<p>Toán tử new trong chuẩn C++11 được định nghĩa với <strong>3 prototype</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void* operator new (std::size_t size);\nvoid* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) noexcept;\nvoid* operator new (std::size_t size, void* ptr) noexcept;</code></pre>\n\n<p>Các bạn chưa cần phải hiểu những tham số khai báo cho toán tử <strong>new</strong>, mà hiện tại chỉ cần chú ý kiểu trả về của nó (<code>void *</code>). Toán tử new sau khi xin cấp phát vùng nhớ trên <strong>Heap</strong> sẽ trả về một con trỏ chứa địa chỉ của vùng nhớ được cấp phát (nếu cấp phát thành công).</p>\n\n<p>Kiểu trả về của  toán tử <strong>new</strong> là con trỏ kiểu <strong>void</strong>, đây là một con trỏ đặc biệt, chúng ta sẽ tìm hiểu nó trong bài học sau. Nhưng dù nó là con trỏ kiểu gì thì mục đích của nó vẫn là chứa địa chỉ, do đó, chúng ta có thể gán giá trị trả về của toán tử <strong>new</strong> cho một con trỏ khác để quản lý vùng nhớ đã được cấp phát.</p>\n\n<h5>usage of new operator</h5>\n\n<p>Cú pháp sử dụng toán tử <strong>new</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">new &lt;data_type&gt;;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">new int; //allocate 4 bytes on Heap partition to an int variable\nnew double; //allocate 8 bytes on Heap partition to a double variable</code></pre>\n\n<p>Khi chương trình đang chạy, nếu quá trình cấp phát bộ nhớ trên thành công, chúng ta sẽ có địa chỉ của 2 vùng nhớ được trả về. Nhưng như mình đã nói, chúng ta không thể tạo thêm tên biến mới khi chương trình đang chạy, do đó chúng ta cần gán nó cho những con trỏ cùng kiểu để quản lý:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_int = new int;\ndouble *p_double = new double;</code></pre>\n\n<p>Bây giờ, vùng nhớ được cấp phát sẽ được quản lý bởi 2 con trỏ <code>p_int</code> và <code>p_double</code>, 2 vùng nhớ này được hệ điều hành trao quyền sử dụng tạm thời cho chương trình của chúng ta, thông qua con trỏ, chúng ta có thể thay đổi giá trị bên trong vùng nhớ này. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_int = new int;\ncout &lt;&lt; \"Put value into memory area\" &lt;&lt; endl;\ncin &gt;&gt; *p_int;\ncout &lt;&lt; \"Value at \" &lt;&lt; p_int &lt;&lt; \" is \" &lt;&lt; *p_int &lt;&lt; endl;</code></pre>\n\n<p>Chúng ta còn có thể vừa cấp phát bộ nhớ vừa khởi tạo giá trị tại vùng nhớ đó cho một biến đơn:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p1 = new int(5);\nint *p2 = new int { *p1 };</code></pre>\n\n<h5>usage of delete operator</h5>\n\n<p>Khi không muốn sử dụng tiếp vùng nhớ đã được cấp phát cho chương trình trên <strong>Heap</strong>, chúng ta nên trả lại vùng nhớ đó cho hệ điều hành. Thật ra khi chương trình kết thúc, tất cả vùng nhớ của chương trình đều bị hệ điều hành thu hồi, nhưng chúng ta nên giải phóng vùng nhớ không cần thiết càng sớm càng tốt.</p>\n\n<p>Để xóa một vùng nhớ, chúng ta cần có một địa chỉ cụ thể, địa chỉ đó được giữ bởi con trỏ sau khi gán địa chỉ cấp phát cho nó:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new int;\n\n//using memory area at p\n//and then set it free\n\ndelete p;</code></pre>\n\n<p>Lúc này, con trỏ p vẫn còn giữ địa chỉ của vùng nhớ đã được cấp phát trên <strong>Heap</strong>. Nếu may mắn, vùng nhớ đó chưa được hệ điều hành cấp phát cho chương trình khác, chúng ta vẫn có thể dùng con trỏ p để thay đổi giá trị bên trong nó.</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new int\n\ndelete p;\n\n//keep using that memory area\n*p = 10;\ncout &lt;&lt; p &lt;&lt; endl;</code></pre>\n\n<p>Nếu không may mắn, con trỏ p sẽ mang tội danh xâm nhập bất hợp pháp vào vùng nhớ của chương trình khác, và chương trình của chúng ta sẽ bị crash.</p>\n\n<h5>mean of delete operator</h5>\n\n<p>Sử dụng toán tử delete không có nghĩa là <strong>delete</strong> tất cả mọi thứ bên trong vùng nhớ mà con trỏ trỏ đến. Toán tử <strong>new và delete</strong> chỉ mang ý nghĩa về \"quyền sử dụng\" vùng nhớ. Toàn bộ dãy địa chỉ trên bộ nhớ ảo được quản lý bởi một chương trình mang tên \"Hệ điều hành\", và hệ điều hành có quyền trao lại quyền sử dụng một vùng nhớ nào đó (trên Stack hoặc trên Heap...) cho những chương trình đáng tin cậy trên máy tính. </p>\n\n<p>Và toán tử <strong>new</strong> dùng để làm hợp đồng sử dụng vùng nhớ trên <strong>Heap</strong>, các bạn lấy vùng nhớ được cấp phát thông qua hợp đồng (<strong>make by new operator</strong>) để chương trình chạy, vậy khi bạn sử dụng toán tử <strong>delete</strong>, đơn giản là bạn chỉ xé bản hợp đồng đó đi (hoặc đưa lại cho hệ điều hành). Lúc này, Giá trị trên vùng nhớ đó <strong>có thể</strong> vẫn còn giữ nguyên do chưa có chương trình nào can thiệp vào.</p>\n\n<p>Toán tử <strong>delete</strong> không tác động gì đến con trỏ.</p>\n\n<h5>Dangling pointer</h5>\n\n<p>\"Con trỏ bị treo\" thường xảy ra sau khi giải phóng vùng nhớ bằng toán tử <strong>delete</strong>. Sau khi sử dụng toán tử <strong>delete</strong>, vùng nhớ được cấp phát được trả lại cho hệ điều hành quản lý, nhưng con trỏ vẫn còn trỏ vào địa chỉ đó. Sử dụng toán tử <strong>dereference</strong> cho con trỏ tại thời điểm này sẽ gây ra lỗi <strong>undefined behavior</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n    int *ptr = new int; // dynamically allocate an integer\n    *ptr = 7; // put a value in that memory location\n \n    delete ptr; // return the memory to the operating system.  ptr is now a dangling pointer.\n \n    std::cout &lt;&lt; *ptr; // Dereferencing a dangling pointer will cause undefined behavior\n    delete ptr; // trying to deallocate the memory again will also lead to undefined behavior.\n \n    return 0;\n}</code></pre>\n\n<p>Còn nhiều trường hợp khác nhau có thể khiến con trỏ bị treo, mình sẽ dành ra một bài học để nói về cách quản lý vùng nhớ và con trỏ khi sử dụng kỹ thuật <strong>Dynamic memory allocation</strong>.</p>\n\n<h5>Điều gì xảy ra khi xin cấp phát vùng nhớ trên Heap thất bại?</h5>\n\n<p>Quá trình cấp phát vùng nhớ trên <strong>Heap</strong> thất bại có thể do có chương trình nào đó đang sử dụng lượng bộ nhớ quá lớn (ví dụ chương trình tạo máy ảo), và chương trình của bạn yêu cầu cung cấp vùng nhớ có kích thước nên hệ điều hành không thế tìm thấy đoạn vùng nhớ nào đủ cho yêu cầu của chương trình của bạn.</p>\n\n<p>Chúng ta cùng xem lại các protoyte của toán tử new:</p>\n\n<p></p><pre><code class=\"lang-auto\">void* operator new (std::size_t size);  // (1)\nvoid* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) noexcept;  // (2)\nvoid* operator new (std::size_t size, void* ptr) noexcept;  // (3)</code></pre>\n\n<p>Mặc định, chúng ta sử dụng toán tử new ở cách khai báo (1), trong trường hợp này, nếu cấp phát vùng nhớ thất bại, toán tử new sẽ ném ra ngoại lệ <code>std::bad_alloc</code>. Nếu ngoại lệ này không được xử lý, chương trình chúng ta sẽ bị kết thúc với lỗi <strong>unhandled exception error</strong>.</p>\n\n<p>Trong một số trường hợp, chúng ta không muốn dính đến ngoại lệ (exception) trong C++, chúng ta nên chọn sử dụng phiên bản toán tử new (2), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p = new (std::nothrow) int;</code></pre>\n\n<p>Sử dụng cách này, nếu quá trình cấp phát thất bại, toán tử <strong>new</strong> sẽ trả về giá trị <strong>NULL</strong>. Lúc này, chúng ta có thể kiểm tra xem chương trình của chúng ta có xin được vùng nhớ hay không:</p>\n\n<p></p><pre><code class=\"lang-auto\">if (p == NULL)\n{\n    cout &lt;&lt; \"Could not allocate memory on Heap partition\" &lt;&lt; endl;\n    exit(1);\n}\nelse\n{\n    //use that memory area\n    //and then delete it\n    \n    delete p;\n}</code></pre>\n\n<p>Sử dụng cách này sẽ giúp chương trình chúng ta sử dụng con trỏ an toàn hơn khi sử dụng kỹ thuật <strong>Dynamic memory allocation</strong>.</p>\n\n<h3>Dynamically allocate arrays</h3>\n\n<p>Để xin cấp phát và giải phóng vùng nhớ cho mảng một chiều trên <strong>Heap</strong>, chúng ta cũng sử dụng toán tử <strong>new và delete</strong> để xử lý.</p>\n\n<h5>Dynamically allocate arrays</h5>\n\n<p>Đối với việc yêu cầu cấp phát bộ nhớ cho biến đơn trên <strong>Heap</strong>, chúng ta chỉ cần cung cấp kiểu dữ liệu cho toán tử <strong>new</strong>, hệ điều hành sẽ tự tính được kích thước cần cấp phát (tương tự việc sử dụng toán tử sizeof). Nhưng khi cần cấp phát một dãy vùng nhớ liên tục nhau (mảng một chiều), ngoài kiểu dữ liệu chúng ta cần cung cấp thêm số lượng phần tử.</p>\n\n<p></p><pre><code class=\"lang-auto\">new &lt;data_type&gt;[num_of_elements];</code></pre>\n\n<p>Nếu quá trình cấp phát thành công, toán tử <strong>new</strong> sẽ trả về địa chỉ của phần tử đầu tiên của vùng nhớ được cấp phát, và tương tự như cấp phát cho biến đơn, chúng ta cho 1 con trỏ có kiểu dữ liệu phù hợp lưu trữ địa trả về để quản lý vùng nhớ. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_arr = new int[10];\n\n//using this memory area\nfor (int i = 0; i &lt; 10; i++)\n{\n    //Set value for each element\n    cin &gt;&gt; *p_arr[i];\n}</code></pre>\n\n<p>Chúng ta có thể khởi tạo cho vùng nhớ đã được cấp phát tương tự như khởi tạo mảng một chiều thông thường. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int arr[5] = { 1, 2, 3, 4, 5 };\nint *p_arr = new int[5] { 1, 2, 3, 4, 5 }; //no operator = between array-size and initializer list</code></pre>\n\n<p><strong>Lưu ý cách này chỉ sử dụng được trong chuẩn C++11 trở lên.</strong></p>\n\n<p>Trường hợp mảng kí tự luôn là trường hợp đặc biệt của mảng một chiều. Chúng ta không thể sử dụng cách khởi tạo này trong chuẩn C++11:</p>\n\n<p></p><pre><code class=\"lang-auto\">char *c_str = new char [100] { \"Allocated on Heap partition\" };</code></pre>\n\n<p>Nhưng trường hợp này có thể chạy được trên Visual studio 2015 với chuẩn C++14.</p>\n\n<p>Điều khiến cho kỹ thuật <strong>Dynamic memory allocation</strong> khác với <strong>Static memory allocation</strong> là số lượng phần tử có thể được cung cấp trong khi chương trình đang chạy. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int num_of_elements;\ncout &lt;&lt; \"Enter number of elements you want to create: \";\ncin &gt;&gt; num_of_elements;\n\nint *p_arr = new int[num_of_elements];</code></pre>\n\n<p>Chúng ta sử dụng giá trị của biến <code>num_of_elements</code> làm số lượng phần tử cung cấp cho toán tử new, và giá trị này chỉ được xác định sau khi người dùng nhập vào từ bàn phím. Để hạn chế trường hợp người dùng nhập số âm, chúng ta cần kiểm tra trước khi xin cấp phát:</p>\n\n<p></p><pre><code class=\"lang-auto\">int num_of_elements;\ncout &lt;&lt; \"Enter number of elements you want to create: \";\ncin &gt;&gt; num_of_elements;\n\nif(num_of_elements &gt; 0)\n    int *p_arr = new int[num_of_elements];</code></pre>\n\n<h5>dynamically delete arrays</h5>\n\n<p>Đối với dãy vùng nhớ liên tục được cấp phát trên <strong>Heap</strong>, chúng ta cần thêm vào toán tử <code>[ ]</code> để báo với hệ điều hành rằng vùng nhớ đã được cấp phát không dùng cho một biến đơn.</p>\n\n<p></p><pre><code class=\"lang-auto\">int *p_arr = new int[10];\n\n//...........\n\ndelete[] p_arr;</code></pre>\n\n<p>Sử dụng toán tử <strong>delete</strong> theo cách giải phóng vùng nhớ biến đơn cho dãy vùng nhớ liên tục có thể gây ra nhiều vấn đề khác nhau cho chương trình (<strong>memory leak, data corruption</strong>, ...).</p>\n\n<h5>resizing dynamic arrays</h5>\n\n<p>Trong nhiều trường hợp, chúng ta cần thay đổi kích thước vùng nhớ đã được cấp phát cho phù hợp với yêu cầu của chương trình. Cách duy nhất là:</p>\n\n<ul>\n<li>Cấp phát lại vùng nhớ mới.</li>\n<li>(Copy dữ liệu từ vùng nhớ cũ sáng vùng nhớ mới nếu cần).</li>\n<li>Giải phóng vùng nhớ cũ.</li>\n<li>Cho con trỏ trỏ đến vùng nhớ mới.</li>\n</ul>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint *p = new int[5];\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\tcin &gt;&gt; *(p + i);\n\t}\n\n\t//re-allocate\n\tint *p_temp = p;\n\tp = new int[10];\n\n\t//copy data\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\t*(p + i) = *(p_temp + i);\n\t}\n\n\t//dealocate old memory area\n\tdelete[] p_temp;\n\n\t//keep using data\n\t//and then delete it\n\n\tdelete[] p;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Do vùng nhớ mới sẽ có địa chỉ khác với vùng nhớ đã cấp phát ban đầu, mình cần sử dụng con trỏ <code>p_temp</code> để giữ lại khả năng truy cập đến vùng nhớ ban đầu. Sau khi copy toàn bộ dữ liệu từ vùng nhớ cũ sang vùng nhớ mới, chúng ta nên giải phóng vùng nhớ cũ ngay để khỏi lãng phí tài nguyên hệ thông.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã tìm hiểu về kỹ thuật <strong>Dynamic memory allocation</strong> trong ngôn ngữ C++. Kỹ thuật này giúp chương trình chúng ta ít bị giới hạn dung lượng bộ nhớ hơn. Nhưng bên cạnh đó, chúng ta cần có kỹ năng về quản lý các vùng nhớ trong chương trình. Sử dụng kỹ thuật <strong>Dynamic memory allocation</strong> không thành thạo là nguyên nhân gây phổ biến gây ra lỗi <strong>memory leak</strong>. Do đó, chúng ta sẽ có một bài học nói về các lỗi thường gặp khi sử dụng <strong>Dynamic memory allocation</strong> và cách kiểm soát các lỗi này.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.14fbb3a6a96c448608a270d296eba25e.json"}