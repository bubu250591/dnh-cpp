<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/phenomic.browser.b39d9c9c1b4fa1a6c1f1.css" /><meta data-react-helmet="true" property="og:site_name" content="dnh-cpp"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="8.8 Con trỏ và hàm"/><meta data-react-helmet="true" property="og:url" content="/8/8-con-tr-va-ham/"/><meta data-react-helmet="true" property="og:description" content="int main()	 { 	int iValue = 10; 	foo(&amp;iValue); } int main() { 	int iValue = 5; 	cout &amp;lt;&amp;lt; &quot;Value = &quot; &amp;lt;&amp;lt; iValue &amp;lt;&amp;lt; endl…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="8.8 Con trỏ và hàm"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="int main()	 { 	int iValue = 10; 	foo(&amp;iValue); } int main() { 	int iValue = 5; 	cout &amp;lt;&amp;lt; &quot;Value = &quot; &amp;lt;&amp;lt; iValue &amp;lt;&amp;lt; endl…"/><meta data-react-helmet="true" name="description" content="int main()	 { 	int iValue = 10; 	foo(&amp;iValue); } int main() { 	int iValue = 5; 	cout &amp;lt;&amp;lt; &quot;Value = &quot; &amp;lt;&amp;lt; iValue &amp;lt;&amp;lt; endl…"/><title data-react-helmet="true">8.8 Con trỏ và hàm</title><link data-react-helmet="true" rel="icon" type="image/png" sizes="144x144" href="//daynhauhoc.s3.amazonaws.com/36ee34de6c73f268424fceaef858c5428d8fb2a976.ico"/><link data-react-helmet="true" rel="icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/><link data-react-helmet="true" rel="apple-touch-icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/></head><body><div id="phenomic"><div class="_2lE56" data-reactroot="" data-reactid="1" data-react-checksum="1823292969"><!-- react-empty: 2 --><div class="_1Ih7a _1GU64" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><div class="_1G2C6 _3fTO1" data-reactid="7"><div class="aCd9j" data-reactid="8"><a href="https://github.com/daynhauhoc/cppcoban" target="_blank" data-hint="Fork on Github" class="hint--bottom-left _2dICi" data-reactid="9"><span class="SVGInline" data-reactid="10"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span></a><a href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank" data-hint="Share on Facebook" class="hint--bottom-left _2dICi" data-reactid="11"><span class="SVGInline" data-reactid="12"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="430.113px" height="430.114px" viewBox="0 0 430.113 430.114" style="enable-background:new 0 0 430.113 430.114;"
	 xml:space="preserve">
<g>
	<path id="Facebook" d="M158.081,83.3c0,10.839,0,59.218,0,59.218h-43.385v72.412h43.385v215.183h89.122V214.936h59.805
		c0,0,5.601-34.721,8.316-72.685c-7.784,0-67.784,0-67.784,0s0-42.127,0-49.511c0-7.4,9.717-17.354,19.321-17.354
		c9.586,0,29.818,0,48.557,0c0-9.859,0-43.924,0-75.385c-25.016,0-53.476,0-66.021,0C155.878-0.004,158.081,72.48,158.081,83.3z"/>
</g>
</svg></span></a></div></div><article class="markdown-body" data-reactid="13"><h1 data-reactid="14">8.8 Con trỏ và hàm</h1><div data-reactid="15"><div class="phenomic-BodyContainer" data-reactid="16">
<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>

<h3>Con trỏ và tham số của hàm</h3>

<p>Chúng ta đã tìm hiểu về 2 kiểu tham số của hàm:</p>

<ul>
<li><p>Hàm có tham số nhận giá trị: giá trị truyền vào hàm có thể là giá trị của biến, một hằng số hoặc một biểu thức toán học...</p></li>
<li><p>Hàm có tham số kiểu tham chiếu: giá trị truyền vào cho hàm là tên biến, và tham số của hàm sẽ tham chiếu trực tiếp đến vùng nhớ của biến đó.</p></li>
</ul>

<p>Chúng ta còn có thêm một kiểu truyền dữ liệu vào cho hàm nữa, đó là truyền địa chỉ vào hàm (<strong>Pass arguments by address</strong>). Do đó, kiểu tham số của hàm có thể nhận giá trị là địa chỉ phải là con trỏ.</p>

<p></p><pre><code class="lang-auto">void foo(int *iPtr)
{
	cout &lt;&lt; "Int value at " &lt;&lt; iPtr &lt;&lt; " is " &lt;&lt; *iPtr &lt;&lt; endl;
}

int main()	
{
	int iValue = 10;
	foo(&amp;iValue);
	
	system("pause");
	return 0;
}</code></pre>

<p>Trong đoạn chương trình trên, sau khi truyền địa chỉ của biến <code>iValue</code> vào hàm <code>foo</code>, tham số <code>iPtr</code> bây giờ sẽ giữ địa chỉ của biến <code>iValue</code>, và chúng ta có thể sử dụng toán tử dereference cho con trỏ <code>iPtr</code>. Kết quả in ra màn hình trên máy tính của mình là:</p>

<p></p><pre><code class="lang-auto">Int value at 0xBFBA144C is 10</code></pre>

<p>Nếu vùng nhớ tại địa chỉ được sử dụng làm đối số cho hàm không phải là hằng, chúng ta có thể thay đổi giá trị của vùng nhớ đó ngay bên trong hàm thông qua toán tử <strong>dereference</strong>:</p>

<p></p><pre><code class="lang-auto">void changeValue(int *iPtr)
{
	*iPtr = 10;
}

int main()
{
	int iValue = 5;
	cout &lt;&lt; "Value = " &lt;&lt; iValue &lt;&lt; endl;
	
	changeValue(&amp;iValue);
	cout &lt;&lt; "Value = " &lt;&lt; iValue &lt;&lt; endl;
	
	system("pause");
	return 0;
}</code></pre>

<p>Kết quả in ra: </p>

<p></p><pre><code class="lang-auto">Value = 5
Value = 10</code></pre>

<p>Như vậy, chúng ta có thể hoán vị giá trị của 2 số nguyên thông qua hàm như sau:</p>

<p></p><pre><code class="lang-auto">void swapIntValue(int *ptr1, int *ptr2)
{
	int temp = *ptr1;
	*ptr1 = *ptr2;
	*ptr2 = temp;
}

int main()
{
	int value1 = 2;
	int value2 = 5;
	
	cout &lt;&lt; "Before swap: " &lt;&lt; value1 &lt;&lt; " " &lt;&lt; value2 &lt;&lt; endl;
	swapIntValue(&amp;value1, &amp;value2);
	cout &lt;&lt; "After swap : " &lt;&lt; value1 &lt;&lt; " " &lt;&lt; value2 &lt;&lt; endl;
	
	system("pause");
	return 0;
}</code></pre>

<p>Kết quả:</p>

<p></p><pre><code class="lang-auto">Before swap: 2 5
After swap : 5 2</code></pre>

<p>Như các bạn thấy, con trỏ khi làm tham số cho hàm cũng có khả năng thay đổi giá trị của vùng nhớ không phải hằng như con trỏ thông thường thông qua toán tử <strong>dereference</strong>.</p>

<p>Chúng ta còn có thể truyền địa chỉ của mảng một chiều vào cho tham số kiểu con trỏ của hàm. Ví dụ:</p>

<p></p><pre><code class="lang-auto">void printArray(int *arr, int length)
{
	for (int i = 0; i &lt; length; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

int main()
{
	int iArr[] = { 3, 2, 5, 1, 7, 10, 32 };
	printArray(iArr, sizeof(iArr) / sizeof(int));
	
	system("pause");
	return 0;
}</code></pre>

<p>Lưu ý, chúng ta không thể biết chính xác kích thước của mảng một chiều thông qua con trỏ, do đó, chúng ta cần tính toán trước kích thước của mảng trước khi truyền vào cho hàm.</p>

<h5>Sử dụng Pointer to const để làm tham số cho hàm</h5>

<p>Như các bạn đã biết, <strong>Pointer to const</strong> là loại con trỏ chỉ có chức năng để đọc (<code>read-only</code>). Do đó, sử dụng <strong>Pointer to const</strong> làm tham số cho hàm sẽ đảm bảo rằng giá trị tại vùng nhớ được truyền vào cho hàm sẽ không bị thay đổi.</p>

<p></p><pre><code class="lang-auto">void printArray(const int *arr, int length)
{
	for (int i = 0; i &lt; length; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

int main()
{
	int arr[] = {};
	int length = sizeof(arr) / sizeof(int);
	
	printArray(arr, length);
	
	system("pause");
	return 0;
}</code></pre>

<p>Lúc này, chúng ta có thể đảm bảo rằng giá trị của các phần tử trong mảng <code>arr</code> sẽ không bị thay đổi bởi hàm <code>printArray</code>.</p>

<h5>Tham số của hàm là tham chiếu vào con trỏ</h5>

<p>Khi chúng ta truyền đối số cho hàm là một địa chỉ, cái địa chỉ này cũng chỉ là bản copy của địa chỉ ban đầu. Về bản chất, truyền địa chỉ vào hàm là truyền đối số là giá trị (<strong>pass by value</strong>). Địa chỉ của đối số sẽ được copy và gán lại cho tham số con trỏ của hàm. Nếu bên trong hàm có câu lệnh thay đổi địa chỉ được truyền vào, chúng chỉ thay đổi bản sao của địa chỉ gốc. Để dễ hình dung hơn, chúng ta xem xét ví dụ sau:</p>

<p></p><pre><code class="lang-auto">void setToNull(int *ptr)	
{
	ptr = NULL; // (4)
}  // (5)

int main()
{
	int value = 5;
	int *pValue = &amp;value; // (1)
	
	cout &lt;&lt; "pValue point to " &lt;&lt; pValue &lt;&lt; endl; // (2)
	setToNull(pValue); // (3)
	cout &lt;&lt; "pValue point to " &lt;&lt; pValue &lt;&lt; endl; // (6)
	
	system("pause");
	return 0;
}</code></pre>

<p>Có 6 bước để nói về đoạn chương trình trên:</p>

<p>(1) Gán địa chỉ của biến value cho con trỏ pValue.<br>(2) In ra địa chỉ mà con trỏ pValue đang nắm giữ.<br>(3) Truyền giá trị của con trỏ đang nắm giữ cho hàm setToNull<br>(4) Sau khi con trỏ ptr trong hàm setToNull nhận được giá trị đầu vào, con trỏ ptr này được gán lại giá trị NULL.<br>(5) Ra khỏi phạm vi của hàm setToNull, con trỏ ptr bị hủy.<br>(6) In ra lại giá trị của con trỏ pValue. Lúc này, chúng ta có thể thấy giá trị của pValue không hề thay đổi, nó vẫn còn trỏ đến địa chỉ của biến value.</p>

<p>Như vậy, giá trị địa chỉ được truyền vào hàm được nắm giữ bởi tham số con trỏ của hàm, từ đó chúng ta có thể sử dụng toán tử <strong>dereference</strong> để thao tác với vùng nhớ tại địa chỉ đó. Chúng ta cũng có thể cho tham số của hàm trỏ đến địa chỉ khác, nhưng không ảnh hưởng gì đến con trỏ gốc.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true" class="lightbox" title="0.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true" width="690" height="396"><div class="meta">
<span class="filename">0.png?raw=true</span><span class="informations">959x551</span><span class="expand"></span>
</div></a></div></p>

<p>Trong một số trường hợp cụ thể, chúng ta muốn thay đổi địa chỉ của con trỏ đối số đang trỏ đến, chúng ta có thể sử dụng tham chiếu cho con trỏ đối số. Xét đoạn chương trình bên dưới:</p>

<p></p><pre><code class="lang-auto">void setToNull(int *&amp;ptr)	
{
	ptr = NULL;
}

int main()
{
	int value = 5;
	int *pValue = &amp;value;
	
	cout &lt;&lt; "pValue point to " &lt;&lt; pValue &lt;&lt; endl;
	setToNull(pValue);
	if(pValue == NULL)
		cout &lt;&lt; "pValue point to NULL" &lt;&lt; endl;
	else
		cout &lt;&lt; "pValue point to " &lt;&lt; pValue &lt;&lt; endl;
	
	return 0;
}</code></pre>

<p>Kết quả của đoạn chương trình này cho thấy con trỏ <code>pValue</code> sau khi truyền vào hàm <code>setToNull</code> đã được gán giá trị NULL. Do tham số con trỏ của hàm <code>setToNull</code> là một tham chiếu kiểu <code>(int *)</code>, nó sẽ tham chiếu đến đối số được truyền vào, trong trường hợp này, tham số tham chiếu con trỏ ptr có cùng địa chỉ với <code>pValue</code>, việc thay đổi giá trị mà ptr nắm giữ cũng làm thay đổi giá trị của <code>pValue</code>.</p>

<h3>Con trỏ và kiểu trả về của hàm</h3>

<p>Chúng ta đã cùng tìm hiểu 2 kiểu giá trị trả về của hàm có kiểu trả về:</p>

<ul>
<li>Hàm trả về giá trị.</li>
<li>Hàm trả về tham chiếu.</li>
</ul>

<p>Bây giờ, chúng ta sẽ cùng tìm hiểu một số vấn đề về kiểu giá trị trả về của hàm là địa chỉ (<strong>return by address</strong>).</p>

<p>Khi nói về việc trả về địa chỉ từ hàm, chúng ta hiểu rằng đó là địa chỉ của những biến hoạt động bên trong hàm. Địa chỉ này sẽ được trả về cho lời gọi hàm, và địa chỉ này thường được tiếp tục sử dụng bằng cách gán nó lại cho 1 con trỏ. Do đó, kiểu trả về của hàm cũng phải là kiểu con trỏ.</p>

<p>Ví dụ:</p>

<p></p><pre><code class="lang-auto">int * createAnInteger(int value = 0)
{
	int myInt = value;
	return &amp;myInt;
}

int main()
{
	int *pInt = createAnInteger(10);
	cout &lt;&lt; *pInt &lt;&lt; endl;
	
	return 0;
}</code></pre>

<p>Sau khi nhìn vào kết quả, chúng ta thấy có vẻ chương trình đã cho ra kết quả như mong muốn:</p>

<p></p><pre><code class="lang-auto">10</code></pre>

<p>Nhưng thực chất, đoạn chương trình trên đã gây ra lỗi nghiêm trọng. Lý do là biến <code>myInt</code> được khai báo bên trong hàm là biến cục bộ, được cấp phát bằng kỹ thuật <strong>Automatic memory allocation</strong>, và vùng nhớ được cấp phát cho biến myInt được lưu trữ trên phân vùng <strong>Stack</strong> của bộ nhớ ảo. Do đó, ngay sau khi ra khỏi hàm, vùng nhớ của biến myInt đã bị hệ điều hành thu hồi, nhưng địa chỉ của biến myInt trước đó đã được trả về cho lời gọi hàm, nên con trỏ pInt trong hàm main được gán một địa chỉ của một vùng nhớ không thuộc quyền quản lý của chương trình hiện hành nữa.</p>

<p>Như mình đã nói, nếu không may, một chương trình khác yêu cầu cấp phát vùng nhớ ngay tại địa chỉ của biến <code>myInt</code> lúc chưa bị hủy, nội dung bên trong vùng nhớ này sẽ bị các chương trình khác thay đổi, dẫn đến việc sử dụng toán tử <strong>dereference</strong> đến vùng nhớ đó không cho ra kết quả như ban đầu nữa. Các bạn có thể chạy đoạn chương trình sau để kiểm chứng:</p>

<p></p><pre><code class="lang-auto">int * createAnInteger(int value = 0)
{
	int myInt = value;
	return &amp;myInt;
}

int main()
{
	int *pInt = createAnInteger(10);
	cout &lt;&lt; "Print immediately:         " &lt;&lt; *pInt &lt;&lt; endl;
	_sleep(1000);
	cout &lt;&lt; "After a fews seconds:   " &lt;&lt; *pInt &lt;&lt; endl;

	system("pause");
	return 0;
}</code></pre>

<p>Kết quả trên máy tính của mình:</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true" class="lightbox" title="1.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true" width="690" height="332"><div class="meta">
<span class="filename">1.png?raw=true</span><span class="informations">796x384</span><span class="expand"></span>
</div></a></div></p>

<p>Như các bạn thấy, chỉ sau thời điểm vùng nhớ của biến <code>myInt</code> bị hủy mới có 1 giây mà đã có chương trình khác sử dụng vùng nhớ đó, làm cho giá trị in ra màn hình console không còn như ban đầu nữa. Và nếu không may hơn nữa, nếu chương trình khác sử dụng cơ chế đồng bộ của kỹ thuật multithreading lên vùng nhớ này, việc dereference vào vùng nhớ đó cũng có thể gây crash chương trình.</p>

<p>Nguyên nhân của những hệ quả mà mình vừa kể ra đều là do vùng nhớ được cấp phát trên Stack thông qua kỹ thuật <strong>Automatic memory allocation</strong> sẽ bị thu hồi tự động bởi hệ điều hành. Để giải quyết vấn đề này, chúng ta cần sử dụng phân vùng Heap để có thể tự quản lý thời điểm giải phóng vùng nhớ để trả lại cho hệ điều hành quản lý.</p>

<p></p><pre><code class="lang-auto">int * createAnInteger(int value = 0)
{
	return new int(value);
}

int main()
{
	int *pInt = createAnInteger(10);
	
	cout &lt;&lt; "Print immediately:   " &lt;&lt; *pInt &lt;&lt; endl;
	_sleep(5000);
	cout &lt;&lt; "After a few seconds: " &lt;&lt; *pInt &lt;&lt; endl;
	
	system("pause");
	return 0;
}</code></pre>

<p>Kết quả lúc này đã được đảm bảo do chúng ta biết rằng vùng nhớ cấp phát trên Heap chỉ bị hệ điều hành thu hồi khi toàn bộ chương trình kết thúc.</p>

<hr>

<h3>Tổng kết</h3>

<p>Trong bài học này, chúng ta đã biết cách truyền tham số là địa chỉ (hoặc con trỏ) vào cho hàm, và trả về địa chỉ cho lời gọi hàm. Bên cạnh đó, chúng ta cũng đã biết được một số vấn đề phát sinh khi sử dụng các kỹ thuật này. Vẫn còn nhiều vấn đề cần phải nói khi sử dụng con trỏ, chúng ta sẽ cùng tiếp tục tìm hiểu trong các bài học tiếp theo.</p>

<h3>Bài tập cơ bản</h3>

<p>Xét đoạn chương trình của ví dụ trên.</p>

<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;
using namespace std;

int * createAnInteger(int value = 0)
{
	return new int(value);
}

int main()
{
	int *pInt = createAnInteger(10);
	
	cout &lt;&lt; "Print immediately:   " &lt;&lt; *pInt &lt;&lt; endl;
	_sleep(5000);
	cout &lt;&lt; "After a few seconds: " &lt;&lt; *pInt &lt;&lt; endl;
	
	system("pause");
	return 0;
}</code></pre>

<p>Đoạn chương trình trên cho ra kết quả đúng, giá trị được in ra khi sử dụng toán tử dereference để truy xuất không bị thay đổi theo thời gian, nhưng nó lại phát sinh một vấn đề khác. Đó là vấn đề gì?</p>

<hr>

<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>

<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>

<p><a title="DayNhauHoc" class="onebox" target="_blank">www.daynhauhoc.com</a></p>
</div></div></article><div id="discourse-comments" data-reactid="17"></div></div></div></div><div class="_30zqN _1M-6l _7YJ7M" data-reactid="18"><div style="position:relative;overflow:hidden;width:100%;height:100%;" data-reactid="19"><div style="position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;-webkit-overflow-scrolling:touch;margin-right:0;margin-bottom:0;" data-reactid="20"><ul style="list-style:none;background-color:transparent;margin:0;padding:0;color:#242a31;font-family:lucida grande ,tahoma,verdana,arial,sans-serif;font-size:14px;" data-reactid="21"><li style="position:relative;" data-reactid="22"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="23"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="24"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="25"><svg height="14" width="14" data-reactid="26"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="27"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="28"><div style="line-height:24px;vertical-align:middle;font-size:1.5em;font-weight:300;font-family:Source Sans Pro,sans-serif;margin-bottom:1em;" data-reactid="29">Khóa học C++</div></div></div><span data-reactid="30"><ul style="list-style:none;padding-left:19px;" data-reactid="31"><li style="position:relative;" data-reactid="32"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="33"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="34"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="35"><svg height="14" width="14" data-reactid="36"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="37"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="38"><div style="line-height:24px;vertical-align:middle;" data-reactid="39">Giới thiệu tổng quan khóa học</div></div></div><span data-reactid="40"></span></li><li style="position:relative;" data-reactid="41"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="42"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="43"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="44"><svg height="14" width="14" data-reactid="45"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="46"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="47"><div style="line-height:24px;vertical-align:middle;" data-reactid="48">C++ cơ bản</div></div></div><span data-reactid="49"></span></li><li style="position:relative;" data-reactid="50"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="51"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="52"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="53"><svg height="14" width="14" data-reactid="54"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="55"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="56"><div style="line-height:24px;vertical-align:middle;" data-reactid="57">Cấu trúc rẽ nhánh</div></div></div><span data-reactid="58"></span></li><li style="position:relative;" data-reactid="59"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="60"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="61"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="62"><svg height="14" width="14" data-reactid="63"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="64"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="65"><div style="line-height:24px;vertical-align:middle;" data-reactid="66">Cấu trúc vòng lặp</div></div></div><span data-reactid="67"></span></li><li style="position:relative;" data-reactid="68"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="69"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="70"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="71"><svg height="14" width="14" data-reactid="72"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="73"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="74"><div style="line-height:24px;vertical-align:middle;" data-reactid="75">Nâng cao về biến, kiểu dữ liệu</div></div></div><span data-reactid="76"></span></li><li style="position:relative;" data-reactid="77"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="78"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="79"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="80"><svg height="14" width="14" data-reactid="81"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="82"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="83"><div style="line-height:24px;vertical-align:middle;" data-reactid="84">Kiểu dữ liệu mảng</div></div></div><span data-reactid="85"></span></li><li style="position:relative;" data-reactid="86"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="87"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="88"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="89"><svg height="14" width="14" data-reactid="90"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="91"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="92"><div style="line-height:24px;vertical-align:middle;" data-reactid="93">Kiểu chuỗi kí tự</div></div></div><span data-reactid="94"></span></li><li style="position:relative;" data-reactid="95"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="96"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="97"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="98"><svg height="14" width="14" data-reactid="99"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="100"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="101"><div style="line-height:24px;vertical-align:middle;" data-reactid="102">Cơ bản về Function</div></div></div><span data-reactid="103"></span></li><li style="position:relative;" data-reactid="104"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="105"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="106"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="107"><svg height="14" width="14" data-reactid="108"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="109"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="110"><div style="line-height:24px;vertical-align:middle;" data-reactid="111">Con trỏ</div></div></div><span data-reactid="112"></span></li><li style="position:relative;" data-reactid="113"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="114"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="115"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="116"><svg height="14" width="14" data-reactid="117"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="118"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="119"><div style="line-height:24px;vertical-align:middle;" data-reactid="120">Kiểu dữ liệu tự định nghĩa</div></div></div><span data-reactid="121"></span></li><li style="position:relative;" data-reactid="122"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="123"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="124"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="125"><svg height="14" width="14" data-reactid="126"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="127"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="128"><div style="line-height:24px;vertical-align:middle;" data-reactid="129">Nhập, xuất (Input &amp; Output)</div></div></div><span data-reactid="130"></span></li><li style="position:relative;" data-reactid="131"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="132"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="133"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="134"><svg height="14" width="14" data-reactid="135"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="136"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="137"><div style="line-height:24px;vertical-align:middle;" data-reactid="138">Một số thư viện thường dùng trong STL</div></div></div><span data-reactid="139"></span></li><li style="position:relative;" data-reactid="140"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="141"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="142"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="143"><svg height="14" width="14" data-reactid="144"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="145"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="146"><div style="line-height:24px;vertical-align:middle;" data-reactid="147">Auto pointer</div></div></div><span data-reactid="148"></span></li><li style="position:relative;" data-reactid="149"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="150"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="151"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="152"><svg height="14" width="14" data-reactid="153"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="154"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="155"><div style="line-height:24px;vertical-align:middle;" data-reactid="156">Quản lý mã nguồn</div></div></div><span data-reactid="157"></span></li><li style="position:relative;" data-reactid="158"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="159"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="160"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="161"><svg height="14" width="14" data-reactid="162"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="163"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="164"><div style="line-height:24px;vertical-align:middle;" data-reactid="165">Một số feature trong C++11, C++14</div></div></div><span data-reactid="166"></span></li></ul></span></li></ul></div><div style="position:absolute;height:6px;display:none;right:2px;bottom:2px;left:2px;border-radius:3px;" data-reactid="167"><div style="position:relative;display:block;height:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="168"></div></div><div style="position:absolute;width:6px;display:none;right:2px;bottom:2px;top:2px;border-radius:3px;" data-reactid="169"><div style="position:relative;display:block;width:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="170"></div></div></div></div><div class="_3eRtW _1tTpi" data-reactid="171"><span class="SVGInline" data-reactid="172"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 396.667 396.667" style="enable-background:new 0 0 396.667 396.667;" xml:space="preserve">
<g>
	<g>
		<path d="M17,87.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17C0,80.183,7.65,87.833,17,87.833z"/>
		<path d="M17,215.333h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,215.333,17,215.333z"/>
		<path d="M17,342.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,342.833,17,342.833z"/>
	</g>
</g>
</svg></span></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"title":"Cài đặt Code::blocks để lập trình C++ trên Ubuntu/Linux","route":"0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux","id":24563,"description":"int main() {   std::cout &lt;&lt; \"Hello World!\"; }","__filename":"generated/24563.md","__url":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/","__resourceUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html","__dataUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html.3ad2186767d90d121ec4cf565f5c1dd8.json"},{"title":"Cài đặt Xcode để lập trình C++ trên Mac OS X","route":"0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x","id":24606,"description":"int main() {     std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;     return 0; }","__filename":"generated/24606.md","__url":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/","__resourceUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html","__dataUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html.8c393057c45fd132c8e63270c6b51de9.json"},{"title":"Cài đặt Visual Studio 2015 để lập trình C++ trên Windows","route":"0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows","id":24768,"description":"","__filename":"generated/24768.md","__url":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/","__resourceUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html","__dataUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html.ee5116c3f1d988558f587037fbca2366.json"},{"title":"0.0 Giới thiệu về series tutorial","route":"0/0-gioi-thieu-ve-series-tutorial","id":29402,"description":"Tóm tắt về bản thân  Minh tên Lê Trần Đạt, 28 tuổi, là lập trình viên lập trình nhúng, ngoài làm việc mình thích dạy học online và viết. Tự…","__filename":"generated/29402.md","__url":"/0/0-gioi-thieu-ve-series-tutorial/","__resourceUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html","__dataUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html.078c42a7bcb638e7a6288e3b5eca8db0.json"},{"title":"0.1 Giới thiệu về ngôn ngữ lập trình","route":"0/1-gioi-thieu-ve-ngon-ngu-lap-trinh","id":29425,"description":"","__filename":"generated/29425.md","__url":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/","__resourceUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html","__dataUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html.9809f133b2b8d62313a69257668cb67b.json"},{"title":"0.2 Giới thiệu về ngôn ngữ lập trình C++","route":"0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c","id":29448,"description":"","__filename":"generated/29448.md","__url":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/","__resourceUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html","__dataUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html.c812ae7d3909d89717f7e886ac243ab3.json"},{"title":"0.3 Các công đoạn phát triển của một chương trình C++","route":"0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c","id":29449,"description":"","__filename":"generated/29449.md","__url":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/","__resourceUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html.f0b19108e622a8c6734cb0d5743e5745.json"},{"title":"0.4 Giới thiệu môi trường phát triển ứng dụng C++","route":"0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c","id":29503,"description":"","__filename":"generated/29503.md","__url":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/","__resourceUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html","__dataUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html.2c25af91e3aa61d907d4da959782452c.json"},{"title":"1.0 Viết chương trình đầu tiên","route":"1/0-viet-chuong-trinh-dau-tien","id":29504,"description":"Các bạn sẽ thấy nhiều hàm main có cách khai báo khác nhau. Nhưng với việc bạn là người mới bắt đầu học…","__filename":"generated/29504.md","__url":"/1/0-viet-chuong-trinh-dau-tien/","__resourceUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html","__dataUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html.a512d65564a3c061c7f754360a019b46.json"},{"title":"1.1 Cấu trúc cơ bản của một chương trình C++","route":"1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c","id":29527,"description":"\\#include &lt;iostream> using namespace std; int main()\t{ \t// We write some code inside main function. } } / We can put…","__filename":"generated/29527.md","__url":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/","__resourceUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html.8df49c7894cffb0fcf8925108166f28e.json"},{"title":"1.10 Độ ưu tiên của các toán tử","route":"1/10-do-uu-tien-cua-cac-toan-tu","id":29574,"description":"","__filename":"generated/29574.md","__url":"/1/10-do-uu-tien-cua-cac-toan-tu/","__resourceUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html","__dataUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html.7a47c8f2c1a6101a3700bbc2c0ee315e.json"},{"title":"1.2 Lệnh, khối lệnh, từ khóa","route":"1/2-lenh-khoi-lenh-tu-khoa","id":29575,"description":"Những dòng lệnh bên trong thân hàm main. (Có thể có hoặc không) Những dòng comment. (Có thể có hoặc không) Tích hợp thư viện và không gian…","__filename":"generated/29575.md","__url":"/1/2-lenh-khoi-lenh-tu-khoa/","__resourceUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html","__dataUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html.7475fb0565b3dc36b5f6c2b16530378c.json"},{"title":"1.3 Sử dụng các lệnh liên quan đến xuất dữ liệu","route":"1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu","id":29796,"description":"","__filename":"generated/29796.md","__url":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/","__resourceUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html","__dataUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html.736841fb7471e11813ab50bf85285809.json"},{"title":"1.4 Biến và các kiểu dữ liệu trong C++","route":"1/4-bien-va-cac-kieu-du-lieu-trong-c","id":29935,"description":"float valueFloat = 5.394; // (2) Xin hệ điều hành thêm một vùng nhớ để chứa 1 số thực string myName = \"Minh Vu\"; // (3) Biến này chứa được…","__filename":"generated/29935.md","__url":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/","__resourceUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html","__dataUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html.13c577638c6f91eda9b5863c77255544.json"},{"title":"1.5 Nhập và xuất dữ liệu","route":"1/5-nhap-va-xuat-du-lieu","id":29936,"description":"","__filename":"generated/29936.md","__url":"/1/5-nhap-va-xuat-du-lieu/","__resourceUrl":"/1/5-nhap-va-xuat-du-lieu/index.html","__dataUrl":"/1/5-nhap-va-xuat-du-lieu/index.html.ef6e11684dfcb7f6b992aba2c8e21426.json"},{"title":"1.6 Hằng số","route":"1/6-hang-so","id":29938,"description":"","__filename":"generated/29938.md","__url":"/1/6-hang-so/","__resourceUrl":"/1/6-hang-so/index.html","__dataUrl":"/1/6-hang-so/index.html.f3ddc6bdde6d54a411e4b79e348d0572.json"},{"title":"1.7 Phạm vi của biến","route":"1/7-pham-vi-cua-bien","id":29939,"description":"int value = 1; int main()\t{ }","__filename":"generated/29939.md","__url":"/1/7-pham-vi-cua-bien/","__resourceUrl":"/1/7-pham-vi-cua-bien/index.html","__dataUrl":"/1/7-pham-vi-cua-bien/index.html.7b8e3af7da9532eb3642eb19b7367ed9.json"},{"title":"1.8 Các phép toán cơ bản","route":"1/8-cac-phep-toan-co-ban","id":29944,"description":"int another_variable = 3; variable = another_variable \\* 2; variable = variable + 1; //tăng giá trị biến variable lên…","__filename":"generated/29944.md","__url":"/1/8-cac-phep-toan-co-ban/","__resourceUrl":"/1/8-cac-phep-toan-co-ban/index.html","__dataUrl":"/1/8-cac-phep-toan-co-ban/index.html.e7174a44027feba3c434a4373886310e.json"},{"title":"1.9 Toán tử tăng giảm","route":"1/9-toan-tu-tang-giam","id":29945,"description":"","__filename":"generated/29945.md","__url":"/1/9-toan-tu-tang-giam/","__resourceUrl":"/1/9-toan-tu-tang-giam/index.html","__dataUrl":"/1/9-toan-tu-tang-giam/index.html.17809ba92bb7526bb6d72300ea06de47.json"},{"title":"2.0 Boolean","route":"2/0-boolean","id":29992,"description":"int a = 2, b = 4; a \\* 3 != b; //đúng int main() { \tcout &lt;&lt; true &lt;&lt; endl; \tcout &lt;&lt; false &lt;&lt; endl; } int main…","__filename":"generated/29992.md","__url":"/2/0-boolean/","__resourceUrl":"/2/0-boolean/index.html","__dataUrl":"/2/0-boolean/index.html.62f9a66039eff1016579fc6484f79273.json"},{"title":"2.1 Giới thiệu một số cấu trúc điều khiển","route":"2/1-gioi-thieu-mot-so-cau-truc-dieu-khien","id":30007,"description":"int main() { \tcout &lt;&lt; \"This line is printed out.\" &lt;&lt; endl; \texit(-1); //Terminate and return -1 to operating system.  \tcout &lt…","__filename":"generated/30007.md","__url":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/","__resourceUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html","__dataUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html.1d4fd6576fff1c9f6ebbde9296cb7ccf.json"},{"title":"2.2 if statements","route":"2/2-if-statements","id":30008,"description":"} } if(value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; } if (value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl…","__filename":"generated/30008.md","__url":"/2/2-if-statements/","__resourceUrl":"/2/2-if-statements/index.html","__dataUrl":"/2/2-if-statements/index.html.5fc7b6ae8899008a02ec037a2bf0194c.json"},{"title":"2.3 switch case statements","route":"2/3-switch-case-statements","id":30009,"description":"} }","__filename":"generated/30009.md","__url":"/2/3-switch-case-statements/","__resourceUrl":"/2/3-switch-case-statements/index.html","__dataUrl":"/2/3-switch-case-statements/index.html.51348d4d78f70d37586bb9c11de9341f.json"},{"title":"3.0 Vòng lặp while","route":"3/0-vong-lap-while","id":30011,"description":"} while (score &lt; 4) { \tcount++; \tcout &lt;&lt; \"Learn C++ programming language...\" &lt;&lt; endl; \tcout &lt;&lt; \"Enter your final score…","__filename":"generated/30011.md","__url":"/3/0-vong-lap-while/","__resourceUrl":"/3/0-vong-lap-while/index.html","__dataUrl":"/3/0-vong-lap-while/index.html.ca3b73cc92989d89c9963bb13aeaa718.json"},{"title":"3.1 Vòng lặp do-while","route":"3/1-vong-lap-do-while","id":30012,"description":"} const int ID = 123; const int password = 123456; int main() { \t//................. }","__filename":"generated/30012.md","__url":"/3/1-vong-lap-do-while/","__resourceUrl":"/3/1-vong-lap-do-while/index.html","__dataUrl":"/3/1-vong-lap-do-while/index.html.9652947ce2cac76fc244291dfe0e7da9.json"},{"title":"3.2 Vòng lặp for","route":"3/2-vong-lap-for","id":30013,"description":"}","__filename":"generated/30013.md","__url":"/3/2-vong-lap-for/","__resourceUrl":"/3/2-vong-lap-for/index.html","__dataUrl":"/3/2-vong-lap-for/index.html.91200558d1e346b99f3bfe6615546b0d.json"},{"title":"3.3 từ khóa break và continue","route":"3/3-tu-khoa-break-va-continue","id":30014,"description":"} } }","__filename":"generated/30014.md","__url":"/3/3-tu-khoa-break-va-continue/","__resourceUrl":"/3/3-tu-khoa-break-va-continue/index.html","__dataUrl":"/3/3-tu-khoa-break-va-continue/index.html.ce5d9d1bafbf829b21faafe2d437e44f.json"},{"title":"4.0 Sử dụng thư viện cstdint","route":"4/0-su-dung-thu-vien-cstdint","id":30016,"description":"int main()\t{ } //in ra kết quả là giá trị lớn nhất của 5 số vừa nhập //in ra kết quả là giá trị nhỏ nhất của 5 số vừa nhập int main…","__filename":"generated/30016.md","__url":"/4/0-su-dung-thu-vien-cstdint/","__resourceUrl":"/4/0-su-dung-thu-vien-cstdint/index.html","__dataUrl":"/4/0-su-dung-thu-vien-cstdint/index.html.a2801fa4ada10c23f504f07e4ee78b63.json"},{"title":"4.1 Kiểu kí tự","route":"4/1-kieu-ki-tu","id":30018,"description":"//check if there is any character exist in stdin file object if (!cin.eof())\t{ \tcout &lt;&lt; \"There are some character more in stdin file…","__filename":"generated/30018.md","__url":"/4/1-kieu-ki-tu/","__resourceUrl":"/4/1-kieu-ki-tu/index.html","__dataUrl":"/4/1-kieu-ki-tu/index.html.3d3eff45a05d59492b7b40b7e7817293.json"},{"title":"4.2 Ép kiểu dữ liệu","route":"4/2-ep-kieu-du-lieu","id":30019,"description":"","__filename":"generated/30019.md","__url":"/4/2-ep-kieu-du-lieu/","__resourceUrl":"/4/2-ep-kieu-du-lieu/index.html","__dataUrl":"/4/2-ep-kieu-du-lieu/index.html.2ce390588cf4f5b31eb1090272f305c3.json"},{"title":"4.3 auto và decltype","route":"4/3-auto-va-decltype","id":30020,"description":"// compare the type of n with type int32_t if (typeid(int32_t) == typeid(n)) \tcout &lt;&lt; \"n is an object of type int32_t\" &lt;&lt; endl…","__filename":"generated/30020.md","__url":"/4/3-auto-va-decltype/","__resourceUrl":"/4/3-auto-va-decltype/index.html","__dataUrl":"/4/3-auto-va-decltype/index.html.0d8f1c6d9c4f8f1eff25628a38272254.json"},{"title":"4.4 Địa chỉ của biến","route":"4/4-dia-chi-cua-bien","id":30022,"description":"cout &lt;&lt; \"Value of var: \" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; \"Value of var_reference: \" &lt;&lt; var_reference &lt;&lt; endl…","__filename":"generated/30022.md","__url":"/4/4-dia-chi-cua-bien/","__resourceUrl":"/4/4-dia-chi-cua-bien/index.html","__dataUrl":"/4/4-dia-chi-cua-bien/index.html.7700a863d95ebd2c72f590db3ae556c8.json"},{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","id":30080,"description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt…","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.2bdadf3c58a38e337057a0de9d3374f6.json"},{"title":"5.1 Các thao tác cơ bản với mảng một chiều","route":"5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu","id":30082,"description":"int32_t arr[ARRAY_SIZE];\t int32_t arr_clone[ARRAY_SIZE]; } } int main() { \tchar ch_array\\[] = { 'L', 'e', 'T', 'r', 'a', 'n', 'D', 'a…","__filename":"generated/30082.md","__url":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/","__resourceUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html","__dataUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html.c358cb5702d7e0848c1d0fcafea76326.json"},{"title":"5.2 Thư viện array trong STL","route":"5/2-thu-vien-array-trong-stl","id":30083,"description":"//Access to all of elements of arr object for (int32_t index = 0; index &lt;= arr.size() - 1; index++) { \tcout &lt;&lt; arr[index] &lt;&lt…","__filename":"generated/30083.md","__url":"/5/2-thu-vien-array-trong-stl/","__resourceUrl":"/5/2-thu-vien-array-trong-stl/index.html","__dataUrl":"/5/2-thu-vien-array-trong-stl/index.html.f6855e3cf847058a20cddbfbd1924e9a.json"},{"title":"5.3 Mảng hai chiều","route":"5/3-mang-hai-chieu","id":30085,"description":"for(int row = 0; row &lt; 3; row++) { \tfor(int col = 0; col &lt; 4; col++) \t{ \t\tcout &lt;&lt; board[row][col] &lt;&lt; \" \"; \t} \tcout &lt;&lt…","__filename":"generated/30085.md","__url":"/5/3-mang-hai-chieu/","__resourceUrl":"/5/3-mang-hai-chieu/index.html","__dataUrl":"/5/3-mang-hai-chieu/index.html.20eabc78d6c5ccd506f5e0a0d9bc1987.json"},{"title":"5.4 Các thao tác cơ bản với mảng hai chiều","route":"5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu","id":30086,"description":"} }","__filename":"generated/30086.md","__url":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/","__resourceUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html","__dataUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html.d255b4de5fe60dec619e7ce656009b5a.json"},{"title":"6.0 Mảng kí tự","route":"6/0-mang-ki-tu","id":30090,"description":"cout &lt;&lt; \"Enter your full name: \"; cin >> full_name; cout &lt;&lt; \"Your full name is \" &lt;&lt; full_name &lt;&lt; endl; cout &lt…","__filename":"generated/30090.md","__url":"/6/0-mang-ki-tu/","__resourceUrl":"/6/0-mang-ki-tu/index.html","__dataUrl":"/6/0-mang-ki-tu/index.html.c07e54b9b2919b7ae2f406f37d0fbed3.json"},{"title":"6.1 Các thao tác cơ bản với mảng kí tự","route":"6/1-cac-thao-tac-co-ban-voi-mang-ki-tu","id":30091,"description":"memset(foo, '-', 7); cout &lt;&lt; foo &lt;&lt; endl; \\-------every programmer should know memset! strcpy(str_destination, str_source…","__filename":"generated/30091.md","__url":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/","__resourceUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html","__dataUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html.f0846f159064ae244ee4452151734f0f.json"},{"title":"6.2 Thư viện string trong C++","route":"6/2-thu-vien-string-trong-c","id":30092,"description":"//......... string my_string; string temp_string(\"What the hell is going on?\"); string one_more = temp_string; string it_just_began(temp…","__filename":"generated/30092.md","__url":"/6/2-thu-vien-string-trong-c/","__resourceUrl":"/6/2-thu-vien-string-trong-c/index.html","__dataUrl":"/6/2-thu-vien-string-trong-c/index.html.c5528a05ca23fbe3ff253526b42ee2f6.json"},{"title":"7.0 Làm quen với khái niệm function","route":"7/0-lam-quen-voi-khai-niem-function","id":30132,"description":"if(strlen(str1) == strlen(str2))\t{ \t//do something } void introduce() { \tcout &lt;&lt; \"Hello!\" &lt;&lt; endl; \tcout &lt;&lt; \"I'm a…","__filename":"generated/30132.md","__url":"/7/0-lam-quen-voi-khai-niem-function/","__resourceUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html","__dataUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html.6701f9806c1a33418b356bcbfebc4392.json"},{"title":"7.1 Thiết kế chương trình dựa trên khái niệm function","route":"7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function","id":30133,"description":"} } float subtraction(float value1, float value2) { \treturn value1 - value2; } float multiplication(float value1, float value2) { \treturn…","__filename":"generated/30133.md","__url":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/","__resourceUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html","__dataUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html.0dd052d16304cb05be843573b6ec0e45.json"},{"title":"7.2 Truyền đối số cho hàm là giá trị hoặc tham chiếu","route":"7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu","id":30319,"description":"} } int main() { \tint argument; \tcout &lt;&lt; \"Address of argument: \" &lt;&lt; &argument &lt;&lt; endl; \tprintAddressOfParameter(argument…","__filename":"generated/30319.md","__url":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html.3219ee44dcef6a14dae07111a5c0abf3.json"},{"title":"7.3 Hàm trả về giá trị hoặc tham chiếu","route":"7/3-ham-tra-ve-gia-tri-hoac-tham-chieu","id":30381,"description":"// .............. // function call int result = doubleValue(10); // ................ // function call int & myRef = returnReference(); for…","__filename":"generated/30381.md","__url":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html.4288591cda8969c5c9199b250877f786.json"},{"title":"7.4 Tham số mặc định, tham số hằng","route":"7/4-tham-so-mac-dinh-tham-so-hang","id":30382,"description":"int main() { \tstring non_const_msg = \"This is non-const message\"; \tconst string const_msg = \"This is const message\"; } int main() { }","__filename":"generated/30382.md","__url":"/7/4-tham-so-mac-dinh-tham-so-hang/","__resourceUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html","__dataUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html.b234bc219b3b3db4f46f8d654d7af624.json"},{"title":"7.5 Function overloading","route":"7/5-function-overloading","id":30477,"description":"float addFloat(float f1, float f2) { \treturn f1 + f2; } float add(float f1, float f2) { \treturn f1 + f2; } print(0); print('a'); print…","__filename":"generated/30477.md","__url":"/7/5-function-overloading/","__resourceUrl":"/7/5-function-overloading/index.html","__dataUrl":"/7/5-function-overloading/index.html.5657ec584a875acb4601350f19853ed3.json"},{"title":"8.0 Con trỏ","route":"8/0-con-tr","id":30541,"description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt…","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.a46c66f365403503c34cafdc9863cfa3.json"},{"title":"8.1 Toán tử tăng, giảm dùng cho con trỏ","route":"8/1-toan-tu-tang-giam-dung-cho-con-tr","id":30699,"description":"cout &lt;&lt; \"Before decreased: \" &lt;&lt; ptr &lt;&lt; endl; ptr--; cout &lt;&lt; \" After decreased: \" &lt;&lt; ptr &lt;&lt; endl; cout…","__filename":"generated/30699.md","__url":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/","__resourceUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html","__dataUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html.cce9500249671524aec88406806baa9e.json"},{"title":"8.2 Con trỏ và mảng một chiều","route":"8/2-con-tr-va-mang-mot-chieu","id":30788,"description":"//show address of the first element of arr cout &lt;&lt; &arr[0] &lt;&lt; endl; //show address of the first element of arr cout &lt;&lt…","__filename":"generated/30788.md","__url":"/8/2-con-tr-va-mang-mot-chieu/","__resourceUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html","__dataUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html.3c8778e4780dd872224eef1cc8f11097.json"},{"title":"8.3 Con trỏ và mảng kí tự","route":"8/3-con-tr-va-mang-ki-tu","id":30876,"description":"p_name[1] = 'E'; cout &lt;&lt; my_name &lt;&lt; endl; cout &lt;&lt; p_name &lt;&lt; endl; } \"Le Tran Dat\"[1] = 'E'; //this line will make…","__filename":"generated/30876.md","__url":"/8/3-con-tr-va-mang-ki-tu/","__resourceUrl":"/8/3-con-tr-va-mang-ki-tu/index.html","__dataUrl":"/8/3-con-tr-va-mang-ki-tu/index.html.dc406539fbe2db6bafb4f3a63ad20fbc.json"},{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","id":31145,"description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt…","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.e0fca4aed8a1bfd6079218b8f9cd5649.json"},{"title":"8.5 Con trỏ và hằng","route":"8/5-con-tr-va-hang","id":31355,"description":"int value1 = 5; ptr = &value1; int value2 = 10; ptr = &value2; &ptr = 10; //compile error int otherValue = 10; ptr = &otherValue…","__filename":"generated/31355.md","__url":"/8/5-con-tr-va-hang/","__resourceUrl":"/8/5-con-tr-va-hang/index.html","__dataUrl":"/8/5-con-tr-va-hang/index.html.9717e378d7312e77dd0af404f3ce878a.json"},{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","id":31625,"description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int…","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.95810b485beb7091df5fbe0cdad166a6.json"},{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","id":31810,"description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl…","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.807439d811fbe3c25a6fe7de6f440dcd.json"},{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","id":31959,"description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue…","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.95b3e8ea543c2c88ac5aed6fae7dd5bc.json"},{"title":"8.10 Phân loại các vùng nhớ (stack & heap ...)","route":"8/10-phan-loai-cac-vung-nho-stack-va-heap","id":32101,"description":"","__filename":"generated/32101.md","__url":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/","__resourceUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html","__dataUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html.f3d953ab58d5d6d7caa9a6825ab85eff.json"},{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","id":32133,"description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int…","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.9b5398e8d66b8730b73fe13cf4859166.json"},{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","id":32159,"description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i…","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/8/7-con-tr-tr-den-con-tr/index.html.9e711455792370d4585f9b6422ec5c75.json"},{"title":"9.0 Kiểu liệt kê (enum)","route":"9/0-kieu-liet-ke-enum","id":32760,"description":"enum Color { \tRED, \tGREEN, \tBLUE, \tWHITE }; enum Animal { \tCAT, \tDOG, \tHORSE, \tMONKEY, \tCHICKEN }; } int iValue = LETTER_A; cout &lt;&lt…","__filename":"generated/32760.md","__url":"/9/0-kieu-liet-ke-enum/","__resourceUrl":"/9/0-kieu-liet-ke-enum/index.html","__dataUrl":"/9/0-kieu-liet-ke-enum/index.html.5bcab9708527435f7e4986ca2293f162.json"},{"title":"9.1 Structs","route":"9/1-structs","id":33291,"description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent…","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.218b89a947ee10e7345fd63f614e71bf.json"},{"title":"9.2 Structs and pointer","route":"9/2-structs-and-pointer","id":33521,"description":"int main() { \tBankAccount myAccount = { 123456789, 50 }; // $50 \tBankAccount \\*pAccount = &myAccount;  } int main() { \tBankAccount…","__filename":"generated/33521.md","__url":"/9/2-structs-and-pointer/","__resourceUrl":"/9/2-structs-and-pointer/index.html","__dataUrl":"/9/2-structs-and-pointer/index.html.3dac4346cb7783e552949ccfe8b270fd.json"},{"title":"Khóa học C++","description":"","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.6be0918faeb891a3ade9da07ef33c29b.json"}];window.__INITIAL_STATE__ = {"pages":{"/8/8-con-tr-va-ham/":{"head":{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","id":31810,"description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl…"},"body":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<h3>Con trỏ và tham số của hàm</h3>\n\n<p>Chúng ta đã tìm hiểu về 2 kiểu tham số của hàm:</p>\n\n<ul>\n<li><p>Hàm có tham số nhận giá trị: giá trị truyền vào hàm có thể là giá trị của biến, một hằng số hoặc một biểu thức toán học...</p></li>\n<li><p>Hàm có tham số kiểu tham chiếu: giá trị truyền vào cho hàm là tên biến, và tham số của hàm sẽ tham chiếu trực tiếp đến vùng nhớ của biến đó.</p></li>\n</ul>\n\n<p>Chúng ta còn có thêm một kiểu truyền dữ liệu vào cho hàm nữa, đó là truyền địa chỉ vào hàm (<strong>Pass arguments by address</strong>). Do đó, kiểu tham số của hàm có thể nhận giá trị là địa chỉ phải là con trỏ.</p>\n\n<p></p><pre><code class=\"lang-auto\">void foo(int *iPtr)\n{\n\tcout &lt;&lt; \"Int value at \" &lt;&lt; iPtr &lt;&lt; \" is \" &lt;&lt; *iPtr &lt;&lt; endl;\n}\n\nint main()\t\n{\n\tint iValue = 10;\n\tfoo(&amp;iValue);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Trong đoạn chương trình trên, sau khi truyền địa chỉ của biến <code>iValue</code> vào hàm <code>foo</code>, tham số <code>iPtr</code> bây giờ sẽ giữ địa chỉ của biến <code>iValue</code>, và chúng ta có thể sử dụng toán tử dereference cho con trỏ <code>iPtr</code>. Kết quả in ra màn hình trên máy tính của mình là:</p>\n\n<p></p><pre><code class=\"lang-auto\">Int value at 0xBFBA144C is 10</code></pre>\n\n<p>Nếu vùng nhớ tại địa chỉ được sử dụng làm đối số cho hàm không phải là hằng, chúng ta có thể thay đổi giá trị của vùng nhớ đó ngay bên trong hàm thông qua toán tử <strong>dereference</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">void changeValue(int *iPtr)\n{\n\t*iPtr = 10;\n}\n\nint main()\n{\n\tint iValue = 5;\n\tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl;\n\t\n\tchangeValue(&amp;iValue);\n\tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả in ra: </p>\n\n<p></p><pre><code class=\"lang-auto\">Value = 5\nValue = 10</code></pre>\n\n<p>Như vậy, chúng ta có thể hoán vị giá trị của 2 số nguyên thông qua hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapIntValue(int *ptr1, int *ptr2)\n{\n\tint temp = *ptr1;\n\t*ptr1 = *ptr2;\n\t*ptr2 = temp;\n}\n\nint main()\n{\n\tint value1 = 2;\n\tint value2 = 5;\n\t\n\tcout &lt;&lt; \"Before swap: \" &lt;&lt; value1 &lt;&lt; \" \" &lt;&lt; value2 &lt;&lt; endl;\n\tswapIntValue(&amp;value1, &amp;value2);\n\tcout &lt;&lt; \"After swap : \" &lt;&lt; value1 &lt;&lt; \" \" &lt;&lt; value2 &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before swap: 2 5\nAfter swap : 5 2</code></pre>\n\n<p>Như các bạn thấy, con trỏ khi làm tham số cho hàm cũng có khả năng thay đổi giá trị của vùng nhớ không phải hằng như con trỏ thông thường thông qua toán tử <strong>dereference</strong>.</p>\n\n<p>Chúng ta còn có thể truyền địa chỉ của mảng một chiều vào cho tham số kiểu con trỏ của hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void printArray(int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint iArr[] = { 3, 2, 5, 1, 7, 10, 32 };\n\tprintArray(iArr, sizeof(iArr) / sizeof(int));\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, chúng ta không thể biết chính xác kích thước của mảng một chiều thông qua con trỏ, do đó, chúng ta cần tính toán trước kích thước của mảng trước khi truyền vào cho hàm.</p>\n\n<h5>Sử dụng Pointer to const để làm tham số cho hàm</h5>\n\n<p>Như các bạn đã biết, <strong>Pointer to const</strong> là loại con trỏ chỉ có chức năng để đọc (<code>read-only</code>). Do đó, sử dụng <strong>Pointer to const</strong> làm tham số cho hàm sẽ đảm bảo rằng giá trị tại vùng nhớ được truyền vào cho hàm sẽ không bị thay đổi.</p>\n\n<p></p><pre><code class=\"lang-auto\">void printArray(const int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint arr[] = {};\n\tint length = sizeof(arr) / sizeof(int);\n\t\n\tprintArray(arr, length);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lúc này, chúng ta có thể đảm bảo rằng giá trị của các phần tử trong mảng <code>arr</code> sẽ không bị thay đổi bởi hàm <code>printArray</code>.</p>\n\n<h5>Tham số của hàm là tham chiếu vào con trỏ</h5>\n\n<p>Khi chúng ta truyền đối số cho hàm là một địa chỉ, cái địa chỉ này cũng chỉ là bản copy của địa chỉ ban đầu. Về bản chất, truyền địa chỉ vào hàm là truyền đối số là giá trị (<strong>pass by value</strong>). Địa chỉ của đối số sẽ được copy và gán lại cho tham số con trỏ của hàm. Nếu bên trong hàm có câu lệnh thay đổi địa chỉ được truyền vào, chúng chỉ thay đổi bản sao của địa chỉ gốc. Để dễ hình dung hơn, chúng ta xem xét ví dụ sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *ptr)\t\n{\n\tptr = NULL; // (4)\n}  // (5)\n\nint main()\n{\n\tint value = 5;\n\tint *pValue = &amp;value; // (1)\n\t\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl; // (2)\n\tsetToNull(pValue); // (3)\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl; // (6)\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Có 6 bước để nói về đoạn chương trình trên:</p>\n\n<p>(1) Gán địa chỉ của biến value cho con trỏ pValue.<br>(2) In ra địa chỉ mà con trỏ pValue đang nắm giữ.<br>(3) Truyền giá trị của con trỏ đang nắm giữ cho hàm setToNull<br>(4) Sau khi con trỏ ptr trong hàm setToNull nhận được giá trị đầu vào, con trỏ ptr này được gán lại giá trị NULL.<br>(5) Ra khỏi phạm vi của hàm setToNull, con trỏ ptr bị hủy.<br>(6) In ra lại giá trị của con trỏ pValue. Lúc này, chúng ta có thể thấy giá trị của pValue không hề thay đổi, nó vẫn còn trỏ đến địa chỉ của biến value.</p>\n\n<p>Như vậy, giá trị địa chỉ được truyền vào hàm được nắm giữ bởi tham số con trỏ của hàm, từ đó chúng ta có thể sử dụng toán tử <strong>dereference</strong> để thao tác với vùng nhớ tại địa chỉ đó. Chúng ta cũng có thể cho tham số của hàm trỏ đến địa chỉ khác, nhưng không ảnh hưởng gì đến con trỏ gốc.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" width=\"690\" height=\"396\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">959x551</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Trong một số trường hợp cụ thể, chúng ta muốn thay đổi địa chỉ của con trỏ đối số đang trỏ đến, chúng ta có thể sử dụng tham chiếu cho con trỏ đối số. Xét đoạn chương trình bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *&amp;ptr)\t\n{\n\tptr = NULL;\n}\n\nint main()\n{\n\tint value = 5;\n\tint *pValue = &amp;value;\n\t\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl;\n\tsetToNull(pValue);\n\tif(pValue == NULL)\n\t\tcout &lt;&lt; \"pValue point to NULL\" &lt;&lt; endl;\n\telse\n\t\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả của đoạn chương trình này cho thấy con trỏ <code>pValue</code> sau khi truyền vào hàm <code>setToNull</code> đã được gán giá trị NULL. Do tham số con trỏ của hàm <code>setToNull</code> là một tham chiếu kiểu <code>(int *)</code>, nó sẽ tham chiếu đến đối số được truyền vào, trong trường hợp này, tham số tham chiếu con trỏ ptr có cùng địa chỉ với <code>pValue</code>, việc thay đổi giá trị mà ptr nắm giữ cũng làm thay đổi giá trị của <code>pValue</code>.</p>\n\n<h3>Con trỏ và kiểu trả về của hàm</h3>\n\n<p>Chúng ta đã cùng tìm hiểu 2 kiểu giá trị trả về của hàm có kiểu trả về:</p>\n\n<ul>\n<li>Hàm trả về giá trị.</li>\n<li>Hàm trả về tham chiếu.</li>\n</ul>\n\n<p>Bây giờ, chúng ta sẽ cùng tìm hiểu một số vấn đề về kiểu giá trị trả về của hàm là địa chỉ (<strong>return by address</strong>).</p>\n\n<p>Khi nói về việc trả về địa chỉ từ hàm, chúng ta hiểu rằng đó là địa chỉ của những biến hoạt động bên trong hàm. Địa chỉ này sẽ được trả về cho lời gọi hàm, và địa chỉ này thường được tiếp tục sử dụng bằng cách gán nó lại cho 1 con trỏ. Do đó, kiểu trả về của hàm cũng phải là kiểu con trỏ.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\tcout &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Sau khi nhìn vào kết quả, chúng ta thấy có vẻ chương trình đã cho ra kết quả như mong muốn:</p>\n\n<p></p><pre><code class=\"lang-auto\">10</code></pre>\n\n<p>Nhưng thực chất, đoạn chương trình trên đã gây ra lỗi nghiêm trọng. Lý do là biến <code>myInt</code> được khai báo bên trong hàm là biến cục bộ, được cấp phát bằng kỹ thuật <strong>Automatic memory allocation</strong>, và vùng nhớ được cấp phát cho biến myInt được lưu trữ trên phân vùng <strong>Stack</strong> của bộ nhớ ảo. Do đó, ngay sau khi ra khỏi hàm, vùng nhớ của biến myInt đã bị hệ điều hành thu hồi, nhưng địa chỉ của biến myInt trước đó đã được trả về cho lời gọi hàm, nên con trỏ pInt trong hàm main được gán một địa chỉ của một vùng nhớ không thuộc quyền quản lý của chương trình hiện hành nữa.</p>\n\n<p>Như mình đã nói, nếu không may, một chương trình khác yêu cầu cấp phát vùng nhớ ngay tại địa chỉ của biến <code>myInt</code> lúc chưa bị hủy, nội dung bên trong vùng nhớ này sẽ bị các chương trình khác thay đổi, dẫn đến việc sử dụng toán tử <strong>dereference</strong> đến vùng nhớ đó không cho ra kết quả như ban đầu nữa. Các bạn có thể chạy đoạn chương trình sau để kiểm chứng:</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\tcout &lt;&lt; \"Print immediately:         \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(1000);\n\tcout &lt;&lt; \"After a fews seconds:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả trên máy tính của mình:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" width=\"690\" height=\"332\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">796x384</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như các bạn thấy, chỉ sau thời điểm vùng nhớ của biến <code>myInt</code> bị hủy mới có 1 giây mà đã có chương trình khác sử dụng vùng nhớ đó, làm cho giá trị in ra màn hình console không còn như ban đầu nữa. Và nếu không may hơn nữa, nếu chương trình khác sử dụng cơ chế đồng bộ của kỹ thuật multithreading lên vùng nhớ này, việc dereference vào vùng nhớ đó cũng có thể gây crash chương trình.</p>\n\n<p>Nguyên nhân của những hệ quả mà mình vừa kể ra đều là do vùng nhớ được cấp phát trên Stack thông qua kỹ thuật <strong>Automatic memory allocation</strong> sẽ bị thu hồi tự động bởi hệ điều hành. Để giải quyết vấn đề này, chúng ta cần sử dụng phân vùng Heap để có thể tự quản lý thời điểm giải phóng vùng nhớ để trả lại cho hệ điều hành quản lý.</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\treturn new int(value);\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\t\n\tcout &lt;&lt; \"Print immediately:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(5000);\n\tcout &lt;&lt; \"After a few seconds: \" &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả lúc này đã được đảm bảo do chúng ta biết rằng vùng nhớ cấp phát trên Heap chỉ bị hệ điều hành thu hồi khi toàn bộ chương trình kết thúc.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã biết cách truyền tham số là địa chỉ (hoặc con trỏ) vào cho hàm, và trả về địa chỉ cho lời gọi hàm. Bên cạnh đó, chúng ta cũng đã biết được một số vấn đề phát sinh khi sử dụng các kỹ thuật này. Vẫn còn nhiều vấn đề cần phải nói khi sử dụng con trỏ, chúng ta sẽ cùng tiếp tục tìm hiểu trong các bài học tiếp theo.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>Xét đoạn chương trình của ví dụ trên.</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\nusing namespace std;\n\nint * createAnInteger(int value = 0)\n{\n\treturn new int(value);\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\t\n\tcout &lt;&lt; \"Print immediately:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(5000);\n\tcout &lt;&lt; \"After a few seconds: \" &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Đoạn chương trình trên cho ra kết quả đúng, giá trị được in ra khi sử dụng toán tử dereference để truy xuất không bị thay đổi theo thời gian, nhưng nó lại phát sinh một vấn đề khác. Đó là vấn đề gì?</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","rawBody":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<h3>Con trỏ và tham số của hàm</h3>\n\n<p>Chúng ta đã tìm hiểu về 2 kiểu tham số của hàm:</p>\n\n<ul>\n<li><p>Hàm có tham số nhận giá trị: giá trị truyền vào hàm có thể là giá trị của biến, một hằng số hoặc một biểu thức toán học...</p></li>\n<li><p>Hàm có tham số kiểu tham chiếu: giá trị truyền vào cho hàm là tên biến, và tham số của hàm sẽ tham chiếu trực tiếp đến vùng nhớ của biến đó.</p></li>\n</ul>\n\n<p>Chúng ta còn có thêm một kiểu truyền dữ liệu vào cho hàm nữa, đó là truyền địa chỉ vào hàm (<strong>Pass arguments by address</strong>). Do đó, kiểu tham số của hàm có thể nhận giá trị là địa chỉ phải là con trỏ.</p>\n\n<p></p><pre><code class=\"lang-auto\">void foo(int *iPtr)\n{\n\tcout &lt;&lt; \"Int value at \" &lt;&lt; iPtr &lt;&lt; \" is \" &lt;&lt; *iPtr &lt;&lt; endl;\n}\n\nint main()\t\n{\n\tint iValue = 10;\n\tfoo(&amp;iValue);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Trong đoạn chương trình trên, sau khi truyền địa chỉ của biến <code>iValue</code> vào hàm <code>foo</code>, tham số <code>iPtr</code> bây giờ sẽ giữ địa chỉ của biến <code>iValue</code>, và chúng ta có thể sử dụng toán tử dereference cho con trỏ <code>iPtr</code>. Kết quả in ra màn hình trên máy tính của mình là:</p>\n\n<p></p><pre><code class=\"lang-auto\">Int value at 0xBFBA144C is 10</code></pre>\n\n<p>Nếu vùng nhớ tại địa chỉ được sử dụng làm đối số cho hàm không phải là hằng, chúng ta có thể thay đổi giá trị của vùng nhớ đó ngay bên trong hàm thông qua toán tử <strong>dereference</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">void changeValue(int *iPtr)\n{\n\t*iPtr = 10;\n}\n\nint main()\n{\n\tint iValue = 5;\n\tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl;\n\t\n\tchangeValue(&amp;iValue);\n\tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả in ra: </p>\n\n<p></p><pre><code class=\"lang-auto\">Value = 5\nValue = 10</code></pre>\n\n<p>Như vậy, chúng ta có thể hoán vị giá trị của 2 số nguyên thông qua hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapIntValue(int *ptr1, int *ptr2)\n{\n\tint temp = *ptr1;\n\t*ptr1 = *ptr2;\n\t*ptr2 = temp;\n}\n\nint main()\n{\n\tint value1 = 2;\n\tint value2 = 5;\n\t\n\tcout &lt;&lt; \"Before swap: \" &lt;&lt; value1 &lt;&lt; \" \" &lt;&lt; value2 &lt;&lt; endl;\n\tswapIntValue(&amp;value1, &amp;value2);\n\tcout &lt;&lt; \"After swap : \" &lt;&lt; value1 &lt;&lt; \" \" &lt;&lt; value2 &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before swap: 2 5\nAfter swap : 5 2</code></pre>\n\n<p>Như các bạn thấy, con trỏ khi làm tham số cho hàm cũng có khả năng thay đổi giá trị của vùng nhớ không phải hằng như con trỏ thông thường thông qua toán tử <strong>dereference</strong>.</p>\n\n<p>Chúng ta còn có thể truyền địa chỉ của mảng một chiều vào cho tham số kiểu con trỏ của hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void printArray(int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint iArr[] = { 3, 2, 5, 1, 7, 10, 32 };\n\tprintArray(iArr, sizeof(iArr) / sizeof(int));\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, chúng ta không thể biết chính xác kích thước của mảng một chiều thông qua con trỏ, do đó, chúng ta cần tính toán trước kích thước của mảng trước khi truyền vào cho hàm.</p>\n\n<h5>Sử dụng Pointer to const để làm tham số cho hàm</h5>\n\n<p>Như các bạn đã biết, <strong>Pointer to const</strong> là loại con trỏ chỉ có chức năng để đọc (<code>read-only</code>). Do đó, sử dụng <strong>Pointer to const</strong> làm tham số cho hàm sẽ đảm bảo rằng giá trị tại vùng nhớ được truyền vào cho hàm sẽ không bị thay đổi.</p>\n\n<p></p><pre><code class=\"lang-auto\">void printArray(const int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint arr[] = {};\n\tint length = sizeof(arr) / sizeof(int);\n\t\n\tprintArray(arr, length);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lúc này, chúng ta có thể đảm bảo rằng giá trị của các phần tử trong mảng <code>arr</code> sẽ không bị thay đổi bởi hàm <code>printArray</code>.</p>\n\n<h5>Tham số của hàm là tham chiếu vào con trỏ</h5>\n\n<p>Khi chúng ta truyền đối số cho hàm là một địa chỉ, cái địa chỉ này cũng chỉ là bản copy của địa chỉ ban đầu. Về bản chất, truyền địa chỉ vào hàm là truyền đối số là giá trị (<strong>pass by value</strong>). Địa chỉ của đối số sẽ được copy và gán lại cho tham số con trỏ của hàm. Nếu bên trong hàm có câu lệnh thay đổi địa chỉ được truyền vào, chúng chỉ thay đổi bản sao của địa chỉ gốc. Để dễ hình dung hơn, chúng ta xem xét ví dụ sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *ptr)\t\n{\n\tptr = NULL; // (4)\n}  // (5)\n\nint main()\n{\n\tint value = 5;\n\tint *pValue = &amp;value; // (1)\n\t\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl; // (2)\n\tsetToNull(pValue); // (3)\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl; // (6)\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Có 6 bước để nói về đoạn chương trình trên:</p>\n\n<p>(1) Gán địa chỉ của biến value cho con trỏ pValue.<br>(2) In ra địa chỉ mà con trỏ pValue đang nắm giữ.<br>(3) Truyền giá trị của con trỏ đang nắm giữ cho hàm setToNull<br>(4) Sau khi con trỏ ptr trong hàm setToNull nhận được giá trị đầu vào, con trỏ ptr này được gán lại giá trị NULL.<br>(5) Ra khỏi phạm vi của hàm setToNull, con trỏ ptr bị hủy.<br>(6) In ra lại giá trị của con trỏ pValue. Lúc này, chúng ta có thể thấy giá trị của pValue không hề thay đổi, nó vẫn còn trỏ đến địa chỉ của biến value.</p>\n\n<p>Như vậy, giá trị địa chỉ được truyền vào hàm được nắm giữ bởi tham số con trỏ của hàm, từ đó chúng ta có thể sử dụng toán tử <strong>dereference</strong> để thao tác với vùng nhớ tại địa chỉ đó. Chúng ta cũng có thể cho tham số của hàm trỏ đến địa chỉ khác, nhưng không ảnh hưởng gì đến con trỏ gốc.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" width=\"690\" height=\"396\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">959x551</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Trong một số trường hợp cụ thể, chúng ta muốn thay đổi địa chỉ của con trỏ đối số đang trỏ đến, chúng ta có thể sử dụng tham chiếu cho con trỏ đối số. Xét đoạn chương trình bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *&amp;ptr)\t\n{\n\tptr = NULL;\n}\n\nint main()\n{\n\tint value = 5;\n\tint *pValue = &amp;value;\n\t\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl;\n\tsetToNull(pValue);\n\tif(pValue == NULL)\n\t\tcout &lt;&lt; \"pValue point to NULL\" &lt;&lt; endl;\n\telse\n\t\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả của đoạn chương trình này cho thấy con trỏ <code>pValue</code> sau khi truyền vào hàm <code>setToNull</code> đã được gán giá trị NULL. Do tham số con trỏ của hàm <code>setToNull</code> là một tham chiếu kiểu <code>(int *)</code>, nó sẽ tham chiếu đến đối số được truyền vào, trong trường hợp này, tham số tham chiếu con trỏ ptr có cùng địa chỉ với <code>pValue</code>, việc thay đổi giá trị mà ptr nắm giữ cũng làm thay đổi giá trị của <code>pValue</code>.</p>\n\n<h3>Con trỏ và kiểu trả về của hàm</h3>\n\n<p>Chúng ta đã cùng tìm hiểu 2 kiểu giá trị trả về của hàm có kiểu trả về:</p>\n\n<ul>\n<li>Hàm trả về giá trị.</li>\n<li>Hàm trả về tham chiếu.</li>\n</ul>\n\n<p>Bây giờ, chúng ta sẽ cùng tìm hiểu một số vấn đề về kiểu giá trị trả về của hàm là địa chỉ (<strong>return by address</strong>).</p>\n\n<p>Khi nói về việc trả về địa chỉ từ hàm, chúng ta hiểu rằng đó là địa chỉ của những biến hoạt động bên trong hàm. Địa chỉ này sẽ được trả về cho lời gọi hàm, và địa chỉ này thường được tiếp tục sử dụng bằng cách gán nó lại cho 1 con trỏ. Do đó, kiểu trả về của hàm cũng phải là kiểu con trỏ.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\tcout &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Sau khi nhìn vào kết quả, chúng ta thấy có vẻ chương trình đã cho ra kết quả như mong muốn:</p>\n\n<p></p><pre><code class=\"lang-auto\">10</code></pre>\n\n<p>Nhưng thực chất, đoạn chương trình trên đã gây ra lỗi nghiêm trọng. Lý do là biến <code>myInt</code> được khai báo bên trong hàm là biến cục bộ, được cấp phát bằng kỹ thuật <strong>Automatic memory allocation</strong>, và vùng nhớ được cấp phát cho biến myInt được lưu trữ trên phân vùng <strong>Stack</strong> của bộ nhớ ảo. Do đó, ngay sau khi ra khỏi hàm, vùng nhớ của biến myInt đã bị hệ điều hành thu hồi, nhưng địa chỉ của biến myInt trước đó đã được trả về cho lời gọi hàm, nên con trỏ pInt trong hàm main được gán một địa chỉ của một vùng nhớ không thuộc quyền quản lý của chương trình hiện hành nữa.</p>\n\n<p>Như mình đã nói, nếu không may, một chương trình khác yêu cầu cấp phát vùng nhớ ngay tại địa chỉ của biến <code>myInt</code> lúc chưa bị hủy, nội dung bên trong vùng nhớ này sẽ bị các chương trình khác thay đổi, dẫn đến việc sử dụng toán tử <strong>dereference</strong> đến vùng nhớ đó không cho ra kết quả như ban đầu nữa. Các bạn có thể chạy đoạn chương trình sau để kiểm chứng:</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\tcout &lt;&lt; \"Print immediately:         \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(1000);\n\tcout &lt;&lt; \"After a fews seconds:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả trên máy tính của mình:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" width=\"690\" height=\"332\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">796x384</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như các bạn thấy, chỉ sau thời điểm vùng nhớ của biến <code>myInt</code> bị hủy mới có 1 giây mà đã có chương trình khác sử dụng vùng nhớ đó, làm cho giá trị in ra màn hình console không còn như ban đầu nữa. Và nếu không may hơn nữa, nếu chương trình khác sử dụng cơ chế đồng bộ của kỹ thuật multithreading lên vùng nhớ này, việc dereference vào vùng nhớ đó cũng có thể gây crash chương trình.</p>\n\n<p>Nguyên nhân của những hệ quả mà mình vừa kể ra đều là do vùng nhớ được cấp phát trên Stack thông qua kỹ thuật <strong>Automatic memory allocation</strong> sẽ bị thu hồi tự động bởi hệ điều hành. Để giải quyết vấn đề này, chúng ta cần sử dụng phân vùng Heap để có thể tự quản lý thời điểm giải phóng vùng nhớ để trả lại cho hệ điều hành quản lý.</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\treturn new int(value);\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\t\n\tcout &lt;&lt; \"Print immediately:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(5000);\n\tcout &lt;&lt; \"After a few seconds: \" &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả lúc này đã được đảm bảo do chúng ta biết rằng vùng nhớ cấp phát trên Heap chỉ bị hệ điều hành thu hồi khi toàn bộ chương trình kết thúc.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã biết cách truyền tham số là địa chỉ (hoặc con trỏ) vào cho hàm, và trả về địa chỉ cho lời gọi hàm. Bên cạnh đó, chúng ta cũng đã biết được một số vấn đề phát sinh khi sử dụng các kỹ thuật này. Vẫn còn nhiều vấn đề cần phải nói khi sử dụng con trỏ, chúng ta sẽ cùng tiếp tục tìm hiểu trong các bài học tiếp theo.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>Xét đoạn chương trình của ví dụ trên.</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\nusing namespace std;\n\nint * createAnInteger(int value = 0)\n{\n\treturn new int(value);\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\t\n\tcout &lt;&lt; \"Print immediately:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(5000);\n\tcout &lt;&lt; \"After a few seconds: \" &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Đoạn chương trình trên cho ra kết quả đúng, giá trị được in ra khi sử dụng toán tử dereference để truy xuất không bị thay đổi theo thời gian, nhưng nó lại phát sinh một vấn đề khác. Đó là vấn đề gì?</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","raw":"---json\n{\"title\":\"8.8 Con trỏ và hàm\",\"route\":\"8/8-con-tr-va-ham\",\"id\":31810}\n---\n\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<h3>Con trỏ và tham số của hàm</h3>\n\n<p>Chúng ta đã tìm hiểu về 2 kiểu tham số của hàm:</p>\n\n<ul>\n<li><p>Hàm có tham số nhận giá trị: giá trị truyền vào hàm có thể là giá trị của biến, một hằng số hoặc một biểu thức toán học...</p></li>\n<li><p>Hàm có tham số kiểu tham chiếu: giá trị truyền vào cho hàm là tên biến, và tham số của hàm sẽ tham chiếu trực tiếp đến vùng nhớ của biến đó.</p></li>\n</ul>\n\n<p>Chúng ta còn có thêm một kiểu truyền dữ liệu vào cho hàm nữa, đó là truyền địa chỉ vào hàm (<strong>Pass arguments by address</strong>). Do đó, kiểu tham số của hàm có thể nhận giá trị là địa chỉ phải là con trỏ.</p>\n\n<p></p><pre><code class=\"lang-auto\">void foo(int *iPtr)\n{\n\tcout &lt;&lt; \"Int value at \" &lt;&lt; iPtr &lt;&lt; \" is \" &lt;&lt; *iPtr &lt;&lt; endl;\n}\n\nint main()\t\n{\n\tint iValue = 10;\n\tfoo(&amp;iValue);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Trong đoạn chương trình trên, sau khi truyền địa chỉ của biến <code>iValue</code> vào hàm <code>foo</code>, tham số <code>iPtr</code> bây giờ sẽ giữ địa chỉ của biến <code>iValue</code>, và chúng ta có thể sử dụng toán tử dereference cho con trỏ <code>iPtr</code>. Kết quả in ra màn hình trên máy tính của mình là:</p>\n\n<p></p><pre><code class=\"lang-auto\">Int value at 0xBFBA144C is 10</code></pre>\n\n<p>Nếu vùng nhớ tại địa chỉ được sử dụng làm đối số cho hàm không phải là hằng, chúng ta có thể thay đổi giá trị của vùng nhớ đó ngay bên trong hàm thông qua toán tử <strong>dereference</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">void changeValue(int *iPtr)\n{\n\t*iPtr = 10;\n}\n\nint main()\n{\n\tint iValue = 5;\n\tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl;\n\t\n\tchangeValue(&amp;iValue);\n\tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả in ra: </p>\n\n<p></p><pre><code class=\"lang-auto\">Value = 5\nValue = 10</code></pre>\n\n<p>Như vậy, chúng ta có thể hoán vị giá trị của 2 số nguyên thông qua hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapIntValue(int *ptr1, int *ptr2)\n{\n\tint temp = *ptr1;\n\t*ptr1 = *ptr2;\n\t*ptr2 = temp;\n}\n\nint main()\n{\n\tint value1 = 2;\n\tint value2 = 5;\n\t\n\tcout &lt;&lt; \"Before swap: \" &lt;&lt; value1 &lt;&lt; \" \" &lt;&lt; value2 &lt;&lt; endl;\n\tswapIntValue(&amp;value1, &amp;value2);\n\tcout &lt;&lt; \"After swap : \" &lt;&lt; value1 &lt;&lt; \" \" &lt;&lt; value2 &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before swap: 2 5\nAfter swap : 5 2</code></pre>\n\n<p>Như các bạn thấy, con trỏ khi làm tham số cho hàm cũng có khả năng thay đổi giá trị của vùng nhớ không phải hằng như con trỏ thông thường thông qua toán tử <strong>dereference</strong>.</p>\n\n<p>Chúng ta còn có thể truyền địa chỉ của mảng một chiều vào cho tham số kiểu con trỏ của hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void printArray(int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint iArr[] = { 3, 2, 5, 1, 7, 10, 32 };\n\tprintArray(iArr, sizeof(iArr) / sizeof(int));\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, chúng ta không thể biết chính xác kích thước của mảng một chiều thông qua con trỏ, do đó, chúng ta cần tính toán trước kích thước của mảng trước khi truyền vào cho hàm.</p>\n\n<h5>Sử dụng Pointer to const để làm tham số cho hàm</h5>\n\n<p>Như các bạn đã biết, <strong>Pointer to const</strong> là loại con trỏ chỉ có chức năng để đọc (<code>read-only</code>). Do đó, sử dụng <strong>Pointer to const</strong> làm tham số cho hàm sẽ đảm bảo rằng giá trị tại vùng nhớ được truyền vào cho hàm sẽ không bị thay đổi.</p>\n\n<p></p><pre><code class=\"lang-auto\">void printArray(const int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nint main()\n{\n\tint arr[] = {};\n\tint length = sizeof(arr) / sizeof(int);\n\t\n\tprintArray(arr, length);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lúc này, chúng ta có thể đảm bảo rằng giá trị của các phần tử trong mảng <code>arr</code> sẽ không bị thay đổi bởi hàm <code>printArray</code>.</p>\n\n<h5>Tham số của hàm là tham chiếu vào con trỏ</h5>\n\n<p>Khi chúng ta truyền đối số cho hàm là một địa chỉ, cái địa chỉ này cũng chỉ là bản copy của địa chỉ ban đầu. Về bản chất, truyền địa chỉ vào hàm là truyền đối số là giá trị (<strong>pass by value</strong>). Địa chỉ của đối số sẽ được copy và gán lại cho tham số con trỏ của hàm. Nếu bên trong hàm có câu lệnh thay đổi địa chỉ được truyền vào, chúng chỉ thay đổi bản sao của địa chỉ gốc. Để dễ hình dung hơn, chúng ta xem xét ví dụ sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *ptr)\t\n{\n\tptr = NULL; // (4)\n}  // (5)\n\nint main()\n{\n\tint value = 5;\n\tint *pValue = &amp;value; // (1)\n\t\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl; // (2)\n\tsetToNull(pValue); // (3)\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl; // (6)\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Có 6 bước để nói về đoạn chương trình trên:</p>\n\n<p>(1) Gán địa chỉ của biến value cho con trỏ pValue.<br>(2) In ra địa chỉ mà con trỏ pValue đang nắm giữ.<br>(3) Truyền giá trị của con trỏ đang nắm giữ cho hàm setToNull<br>(4) Sau khi con trỏ ptr trong hàm setToNull nhận được giá trị đầu vào, con trỏ ptr này được gán lại giá trị NULL.<br>(5) Ra khỏi phạm vi của hàm setToNull, con trỏ ptr bị hủy.<br>(6) In ra lại giá trị của con trỏ pValue. Lúc này, chúng ta có thể thấy giá trị của pValue không hề thay đổi, nó vẫn còn trỏ đến địa chỉ của biến value.</p>\n\n<p>Như vậy, giá trị địa chỉ được truyền vào hàm được nắm giữ bởi tham số con trỏ của hàm, từ đó chúng ta có thể sử dụng toán tử <strong>dereference</strong> để thao tác với vùng nhớ tại địa chỉ đó. Chúng ta cũng có thể cho tham số của hàm trỏ đến địa chỉ khác, nhưng không ảnh hưởng gì đến con trỏ gốc.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" width=\"690\" height=\"396\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">959x551</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Trong một số trường hợp cụ thể, chúng ta muốn thay đổi địa chỉ của con trỏ đối số đang trỏ đến, chúng ta có thể sử dụng tham chiếu cho con trỏ đối số. Xét đoạn chương trình bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *&amp;ptr)\t\n{\n\tptr = NULL;\n}\n\nint main()\n{\n\tint value = 5;\n\tint *pValue = &amp;value;\n\t\n\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl;\n\tsetToNull(pValue);\n\tif(pValue == NULL)\n\t\tcout &lt;&lt; \"pValue point to NULL\" &lt;&lt; endl;\n\telse\n\t\tcout &lt;&lt; \"pValue point to \" &lt;&lt; pValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả của đoạn chương trình này cho thấy con trỏ <code>pValue</code> sau khi truyền vào hàm <code>setToNull</code> đã được gán giá trị NULL. Do tham số con trỏ của hàm <code>setToNull</code> là một tham chiếu kiểu <code>(int *)</code>, nó sẽ tham chiếu đến đối số được truyền vào, trong trường hợp này, tham số tham chiếu con trỏ ptr có cùng địa chỉ với <code>pValue</code>, việc thay đổi giá trị mà ptr nắm giữ cũng làm thay đổi giá trị của <code>pValue</code>.</p>\n\n<h3>Con trỏ và kiểu trả về của hàm</h3>\n\n<p>Chúng ta đã cùng tìm hiểu 2 kiểu giá trị trả về của hàm có kiểu trả về:</p>\n\n<ul>\n<li>Hàm trả về giá trị.</li>\n<li>Hàm trả về tham chiếu.</li>\n</ul>\n\n<p>Bây giờ, chúng ta sẽ cùng tìm hiểu một số vấn đề về kiểu giá trị trả về của hàm là địa chỉ (<strong>return by address</strong>).</p>\n\n<p>Khi nói về việc trả về địa chỉ từ hàm, chúng ta hiểu rằng đó là địa chỉ của những biến hoạt động bên trong hàm. Địa chỉ này sẽ được trả về cho lời gọi hàm, và địa chỉ này thường được tiếp tục sử dụng bằng cách gán nó lại cho 1 con trỏ. Do đó, kiểu trả về của hàm cũng phải là kiểu con trỏ.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\tcout &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Sau khi nhìn vào kết quả, chúng ta thấy có vẻ chương trình đã cho ra kết quả như mong muốn:</p>\n\n<p></p><pre><code class=\"lang-auto\">10</code></pre>\n\n<p>Nhưng thực chất, đoạn chương trình trên đã gây ra lỗi nghiêm trọng. Lý do là biến <code>myInt</code> được khai báo bên trong hàm là biến cục bộ, được cấp phát bằng kỹ thuật <strong>Automatic memory allocation</strong>, và vùng nhớ được cấp phát cho biến myInt được lưu trữ trên phân vùng <strong>Stack</strong> của bộ nhớ ảo. Do đó, ngay sau khi ra khỏi hàm, vùng nhớ của biến myInt đã bị hệ điều hành thu hồi, nhưng địa chỉ của biến myInt trước đó đã được trả về cho lời gọi hàm, nên con trỏ pInt trong hàm main được gán một địa chỉ của một vùng nhớ không thuộc quyền quản lý của chương trình hiện hành nữa.</p>\n\n<p>Như mình đã nói, nếu không may, một chương trình khác yêu cầu cấp phát vùng nhớ ngay tại địa chỉ của biến <code>myInt</code> lúc chưa bị hủy, nội dung bên trong vùng nhớ này sẽ bị các chương trình khác thay đổi, dẫn đến việc sử dụng toán tử <strong>dereference</strong> đến vùng nhớ đó không cho ra kết quả như ban đầu nữa. Các bạn có thể chạy đoạn chương trình sau để kiểm chứng:</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\tcout &lt;&lt; \"Print immediately:         \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(1000);\n\tcout &lt;&lt; \"After a fews seconds:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả trên máy tính của mình:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" width=\"690\" height=\"332\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">796x384</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như các bạn thấy, chỉ sau thời điểm vùng nhớ của biến <code>myInt</code> bị hủy mới có 1 giây mà đã có chương trình khác sử dụng vùng nhớ đó, làm cho giá trị in ra màn hình console không còn như ban đầu nữa. Và nếu không may hơn nữa, nếu chương trình khác sử dụng cơ chế đồng bộ của kỹ thuật multithreading lên vùng nhớ này, việc dereference vào vùng nhớ đó cũng có thể gây crash chương trình.</p>\n\n<p>Nguyên nhân của những hệ quả mà mình vừa kể ra đều là do vùng nhớ được cấp phát trên Stack thông qua kỹ thuật <strong>Automatic memory allocation</strong> sẽ bị thu hồi tự động bởi hệ điều hành. Để giải quyết vấn đề này, chúng ta cần sử dụng phân vùng Heap để có thể tự quản lý thời điểm giải phóng vùng nhớ để trả lại cho hệ điều hành quản lý.</p>\n\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\treturn new int(value);\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\t\n\tcout &lt;&lt; \"Print immediately:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(5000);\n\tcout &lt;&lt; \"After a few seconds: \" &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả lúc này đã được đảm bảo do chúng ta biết rằng vùng nhớ cấp phát trên Heap chỉ bị hệ điều hành thu hồi khi toàn bộ chương trình kết thúc.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã biết cách truyền tham số là địa chỉ (hoặc con trỏ) vào cho hàm, và trả về địa chỉ cho lời gọi hàm. Bên cạnh đó, chúng ta cũng đã biết được một số vấn đề phát sinh khi sử dụng các kỹ thuật này. Vẫn còn nhiều vấn đề cần phải nói khi sử dụng con trỏ, chúng ta sẽ cùng tiếp tục tìm hiểu trong các bài học tiếp theo.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>Xét đoạn chương trình của ví dụ trên.</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\nusing namespace std;\n\nint * createAnInteger(int value = 0)\n{\n\treturn new int(value);\n}\n\nint main()\n{\n\tint *pInt = createAnInteger(10);\n\t\n\tcout &lt;&lt; \"Print immediately:   \" &lt;&lt; *pInt &lt;&lt; endl;\n\t_sleep(5000);\n\tcout &lt;&lt; \"After a few seconds: \" &lt;&lt; *pInt &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Đoạn chương trình trên cho ra kết quả đúng, giá trị được in ra khi sử dụng toán tử dereference để truy xuất không bị thay đổi theo thời gian, nhưng nó lại phát sinh một vấn đề khác. Đó là vấn đề gì?</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.807439d811fbe3c25a6fe7de6f440dcd.json"}}}</script><script src="/phenomic.browser.b39d9c9c1b4fa1a6c1f1.js"></script></body></html>