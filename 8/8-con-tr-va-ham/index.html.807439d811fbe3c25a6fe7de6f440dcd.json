{"head":{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","id":31810,"description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl; }…"},"body":"<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n<h3>Con trỏ và tham số của hàm</h3>\n<p>Chúng ta đã tìm hiểu về 2 kiểu tham số của hàm:</p>\n<ul>\n<li><p>Hàm có tham số nhận giá trị: giá trị truyền vào hàm có thể là giá trị của biến, một hằng số hoặc một biểu thức toán học...</p></li>\n<li><p>Hàm có tham số kiểu tham chiếu: giá trị truyền vào cho hàm là tên biến, và tham số của hàm sẽ tham chiếu trực tiếp đến vùng nhớ của biến đó.</p></li>\n</ul>\n<p>Chúng ta còn có thêm một kiểu truyền dữ liệu vào cho hàm nữa, đó là truyền địa chỉ vào hàm (<strong>Pass arguments by address</strong>). Do đó, kiểu tham số của hàm có thể nhận giá trị là địa chỉ phải là con trỏ.</p>\n<p></p><pre><code class=\"lang-auto\">void foo(int *iPtr)\n{\n\tcout &lt;&lt; \"Int value at \" &lt;&lt; iPtr &lt;&lt; \" is \" &lt;&lt; *iPtr &lt;&lt; endl;\n}\n<p>int main()\n{\nint iValue = 10;\nfoo(&#x26;iValue);\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Trong đoạn chương trình trên, sau khi truyền địa chỉ của biến <code>iValue</code> vào hàm <code>foo</code>, tham số <code>iPtr</code> bây giờ sẽ giữ địa chỉ của biến <code>iValue</code>, và chúng ta có thể sử dụng toán tử dereference cho con trỏ <code>iPtr</code>. Kết quả in ra màn hình trên máy tính của mình là:</p>\n<p></p><pre><code class=\"lang-auto\">Int value at 0xBFBA144C is 10</code></pre>\n<p>Nếu vùng nhớ tại địa chỉ được sử dụng làm đối số cho hàm không phải là hằng, chúng ta có thể thay đổi giá trị của vùng nhớ đó ngay bên trong hàm thông qua toán tử <strong>dereference</strong>:</p>\n<p></p><pre><code class=\"lang-auto\">void changeValue(int *iPtr)\n{\n\t*iPtr = 10;\n}\n<p>int main()\n{\nint iValue = 5;\ncout &#x3C;&#x3C; \"Value = \" &#x3C;&#x3C; iValue &#x3C;&#x3C; endl;\n\nchangeValue(&#x26;iValue);\ncout &#x3C;&#x3C; \"Value = \" &#x3C;&#x3C; iValue &#x3C;&#x3C; endl;\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Kết quả in ra: </p>\n<p></p><pre><code class=\"lang-auto\">Value = 5\nValue = 10</code></pre>\n<p>Như vậy, chúng ta có thể hoán vị giá trị của 2 số nguyên thông qua hàm như sau:</p>\n<p></p><pre><code class=\"lang-auto\">void swapIntValue(int *ptr1, int *ptr2)\n{\n\tint temp = *ptr1;\n\t*ptr1 = *ptr2;\n\t*ptr2 = temp;\n}\n<p>int main()\n{\nint value1 = 2;\nint value2 = 5;\n\ncout &#x3C;&#x3C; \"Before swap: \" &#x3C;&#x3C; value1 &#x3C;&#x3C; \" \" &#x3C;&#x3C; value2 &#x3C;&#x3C; endl;\nswapIntValue(&#x26;value1, &#x26;value2);\ncout &#x3C;&#x3C; \"After swap : \" &#x3C;&#x3C; value1 &#x3C;&#x3C; \" \" &#x3C;&#x3C; value2 &#x3C;&#x3C; endl;\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Kết quả:</p>\n<p></p><pre><code class=\"lang-auto\">Before swap: 2 5\nAfter swap : 5 2</code></pre>\n<p>Như các bạn thấy, con trỏ khi làm tham số cho hàm cũng có khả năng thay đổi giá trị của vùng nhớ không phải hằng như con trỏ thông thường thông qua toán tử <strong>dereference</strong>.</p>\n<p>Chúng ta còn có thể truyền địa chỉ của mảng một chiều vào cho tham số kiểu con trỏ của hàm. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">void printArray(int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n<p>int main()\n{\nint iArr[] = { 3, 2, 5, 1, 7, 10, 32 };\nprintArray(iArr, sizeof(iArr) / sizeof(int));\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Lưu ý, chúng ta không thể biết chính xác kích thước của mảng một chiều thông qua con trỏ, do đó, chúng ta cần tính toán trước kích thước của mảng trước khi truyền vào cho hàm.</p>\n<h5>Sử dụng Pointer to const để làm tham số cho hàm</h5>\n<p>Như các bạn đã biết, <strong>Pointer to const</strong> là loại con trỏ chỉ có chức năng để đọc (<code>read-only</code>). Do đó, sử dụng <strong>Pointer to const</strong> làm tham số cho hàm sẽ đảm bảo rằng giá trị tại vùng nhớ được truyền vào cho hàm sẽ không bị thay đổi.</p>\n<p></p><pre><code class=\"lang-auto\">void printArray(const int *arr, int length)\n{\n\tfor (int i = 0; i &lt; length; i++)\n\t{\n\t\tcout &lt;&lt; arr[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n<p>int main()\n{\nint arr[] = {};\nint length = sizeof(arr) / sizeof(int);\n\nprintArray(arr, length);\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Lúc này, chúng ta có thể đảm bảo rằng giá trị của các phần tử trong mảng <code>arr</code> sẽ không bị thay đổi bởi hàm <code>printArray</code>.</p>\n<h5>Tham số của hàm là tham chiếu vào con trỏ</h5>\n<p>Khi chúng ta truyền đối số cho hàm là một địa chỉ, cái địa chỉ này cũng chỉ là bản copy của địa chỉ ban đầu. Về bản chất, truyền địa chỉ vào hàm là truyền đối số là giá trị (<strong>pass by value</strong>). Địa chỉ của đối số sẽ được copy và gán lại cho tham số con trỏ của hàm. Nếu bên trong hàm có câu lệnh thay đổi địa chỉ được truyền vào, chúng chỉ thay đổi bản sao của địa chỉ gốc. Để dễ hình dung hơn, chúng ta xem xét ví dụ sau:</p>\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *ptr)\t\n{\n\tptr = NULL; // (4)\n}  // (5)\n<p>int main()\n{\nint value = 5;\nint *pValue = &#x26;value; // (1)\n\ncout &#x3C;&#x3C; \"pValue point to \" &#x3C;&#x3C; pValue &#x3C;&#x3C; endl; // (2)\nsetToNull(pValue); // (3)\ncout &#x3C;&#x3C; \"pValue point to \" &#x3C;&#x3C; pValue &#x3C;&#x3C; endl; // (6)\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Có 6 bước để nói về đoạn chương trình trên:</p>\n<p>(1) Gán địa chỉ của biến value cho con trỏ pValue.<br>(2) In ra địa chỉ mà con trỏ pValue đang nắm giữ.<br>(3) Truyền giá trị của con trỏ đang nắm giữ cho hàm setToNull<br>(4) Sau khi con trỏ ptr trong hàm setToNull nhận được giá trị đầu vào, con trỏ ptr này được gán lại giá trị NULL.<br>(5) Ra khỏi phạm vi của hàm setToNull, con trỏ ptr bị hủy.<br>(6) In ra lại giá trị của con trỏ pValue. Lúc này, chúng ta có thể thấy giá trị của pValue không hề thay đổi, nó vẫn còn trỏ đến địa chỉ của biến value.</p>\n<p>Như vậy, giá trị địa chỉ được truyền vào hàm được nắm giữ bởi tham số con trỏ của hàm, từ đó chúng ta có thể sử dụng toán tử <strong>dereference</strong> để thao tác với vùng nhớ tại địa chỉ đó. Chúng ta cũng có thể cho tham số của hàm trỏ đến địa chỉ khác, nhưng không ảnh hưởng gì đến con trỏ gốc.</p>\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/0.png?raw=true\" width=\"690\" height=\"396\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">959x551</span><span class=\"expand\"></span>\n</div></a></div></p>\n<p>Trong một số trường hợp cụ thể, chúng ta muốn thay đổi địa chỉ của con trỏ đối số đang trỏ đến, chúng ta có thể sử dụng tham chiếu cho con trỏ đối số. Xét đoạn chương trình bên dưới:</p>\n<p></p><pre><code class=\"lang-auto\">void setToNull(int *&amp;ptr)\t\n{\n\tptr = NULL;\n}\n<p>int main()\n{\nint value = 5;\nint *pValue = &#x26;value;\n\ncout &#x3C;&#x3C; \"pValue point to \" &#x3C;&#x3C; pValue &#x3C;&#x3C; endl;\nsetToNull(pValue);\nif(pValue == NULL)\ncout &#x3C;&#x3C; \"pValue point to NULL\" &#x3C;&#x3C; endl;\nelse\ncout &#x3C;&#x3C; \"pValue point to \" &#x3C;&#x3C; pValue &#x3C;&#x3C; endl;\n\nreturn 0;\n}</code></pre></p>\n<p>Kết quả của đoạn chương trình này cho thấy con trỏ <code>pValue</code> sau khi truyền vào hàm <code>setToNull</code> đã được gán giá trị NULL. Do tham số con trỏ của hàm <code>setToNull</code> là một tham chiếu kiểu <code>(int *)</code>, nó sẽ tham chiếu đến đối số được truyền vào, trong trường hợp này, tham số tham chiếu con trỏ ptr có cùng địa chỉ với <code>pValue</code>, việc thay đổi giá trị mà ptr nắm giữ cũng làm thay đổi giá trị của <code>pValue</code>.</p>\n<h3>Con trỏ và kiểu trả về của hàm</h3>\n<p>Chúng ta đã cùng tìm hiểu 2 kiểu giá trị trả về của hàm có kiểu trả về:</p>\n<ul>\n<li>Hàm trả về giá trị.</li>\n<li>Hàm trả về tham chiếu.</li>\n</ul>\n<p>Bây giờ, chúng ta sẽ cùng tìm hiểu một số vấn đề về kiểu giá trị trả về của hàm là địa chỉ (<strong>return by address</strong>).</p>\n<p>Khi nói về việc trả về địa chỉ từ hàm, chúng ta hiểu rằng đó là địa chỉ của những biến hoạt động bên trong hàm. Địa chỉ này sẽ được trả về cho lời gọi hàm, và địa chỉ này thường được tiếp tục sử dụng bằng cách gán nó lại cho 1 con trỏ. Do đó, kiểu trả về của hàm cũng phải là kiểu con trỏ.</p>\n<p>Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n<p>int main()\n{\nint <em>pInt = createAnInteger(10);\ncout &#x3C;&#x3C; </em>pInt &#x3C;&#x3C; endl;\n\nreturn 0;\n}</code></pre></p>\n<p>Sau khi nhìn vào kết quả, chúng ta thấy có vẻ chương trình đã cho ra kết quả như mong muốn:</p>\n<p></p><pre><code class=\"lang-auto\">10</code></pre>\n<p>Nhưng thực chất, đoạn chương trình trên đã gây ra lỗi nghiêm trọng. Lý do là biến <code>myInt</code> được khai báo bên trong hàm là biến cục bộ, được cấp phát bằng kỹ thuật <strong>Automatic memory allocation</strong>, và vùng nhớ được cấp phát cho biến myInt được lưu trữ trên phân vùng <strong>Stack</strong> của bộ nhớ ảo. Do đó, ngay sau khi ra khỏi hàm, vùng nhớ của biến myInt đã bị hệ điều hành thu hồi, nhưng địa chỉ của biến myInt trước đó đã được trả về cho lời gọi hàm, nên con trỏ pInt trong hàm main được gán một địa chỉ của một vùng nhớ không thuộc quyền quản lý của chương trình hiện hành nữa.</p>\n<p>Như mình đã nói, nếu không may, một chương trình khác yêu cầu cấp phát vùng nhớ ngay tại địa chỉ của biến <code>myInt</code> lúc chưa bị hủy, nội dung bên trong vùng nhớ này sẽ bị các chương trình khác thay đổi, dẫn đến việc sử dụng toán tử <strong>dereference</strong> đến vùng nhớ đó không cho ra kết quả như ban đầu nữa. Các bạn có thể chạy đoạn chương trình sau để kiểm chứng:</p>\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\tint myInt = value;\n\treturn &amp;myInt;\n}\n<p>int main()\n{\nint <em>pInt = createAnInteger(10);\ncout &#x3C;&#x3C; \"Print immediately:         \" &#x3C;&#x3C; </em>pInt &#x3C;&#x3C; endl;\n_sleep(1000);\ncout &#x3C;&#x3C; \"After a fews seconds:   \" &#x3C;&#x3C; *pInt &#x3C;&#x3C; endl;</p>\n<pre><code>system(\"pause\");\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Kết quả trên máy tính của mình:</p>\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-8-con-tro-va-ham/1.png?raw=true\" width=\"690\" height=\"332\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">796x384</span><span class=\"expand\"></span>\n</div></a></div></p>\n<p>Như các bạn thấy, chỉ sau thời điểm vùng nhớ của biến <code>myInt</code> bị hủy mới có 1 giây mà đã có chương trình khác sử dụng vùng nhớ đó, làm cho giá trị in ra màn hình console không còn như ban đầu nữa. Và nếu không may hơn nữa, nếu chương trình khác sử dụng cơ chế đồng bộ của kỹ thuật multithreading lên vùng nhớ này, việc dereference vào vùng nhớ đó cũng có thể gây crash chương trình.</p>\n<p>Nguyên nhân của những hệ quả mà mình vừa kể ra đều là do vùng nhớ được cấp phát trên Stack thông qua kỹ thuật <strong>Automatic memory allocation</strong> sẽ bị thu hồi tự động bởi hệ điều hành. Để giải quyết vấn đề này, chúng ta cần sử dụng phân vùng Heap để có thể tự quản lý thời điểm giải phóng vùng nhớ để trả lại cho hệ điều hành quản lý.</p>\n<p></p><pre><code class=\"lang-auto\">int * createAnInteger(int value = 0)\n{\n\treturn new int(value);\n}\n<p>int main()\n{\nint <em>pInt = createAnInteger(10);\n\ncout &#x3C;&#x3C; \"Print immediately:   \" &#x3C;&#x3C; </em>pInt &#x3C;&#x3C; endl;\n_sleep(5000);\ncout &#x3C;&#x3C; \"After a few seconds: \" &#x3C;&#x3C; *pInt &#x3C;&#x3C; endl;\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Kết quả lúc này đã được đảm bảo do chúng ta biết rằng vùng nhớ cấp phát trên Heap chỉ bị hệ điều hành thu hồi khi toàn bộ chương trình kết thúc.</p>\n<hr>\n<h3>Tổng kết</h3>\n<p>Trong bài học này, chúng ta đã biết cách truyền tham số là địa chỉ (hoặc con trỏ) vào cho hàm, và trả về địa chỉ cho lời gọi hàm. Bên cạnh đó, chúng ta cũng đã biết được một số vấn đề phát sinh khi sử dụng các kỹ thuật này. Vẫn còn nhiều vấn đề cần phải nói khi sử dụng con trỏ, chúng ta sẽ cùng tiếp tục tìm hiểu trong các bài học tiếp theo.</p>\n<h3>Bài tập cơ bản</h3>\n<p>Xét đoạn chương trình của ví dụ trên.</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\nusing namespace std;\n<p>int * createAnInteger(int value = 0)\n{\nreturn new int(value);\n}</p>\n<p>int main()\n{\nint <em>pInt = createAnInteger(10);\n\ncout &#x3C;&#x3C; \"Print immediately:   \" &#x3C;&#x3C; </em>pInt &#x3C;&#x3C; endl;\n_sleep(5000);\ncout &#x3C;&#x3C; \"After a few seconds: \" &#x3C;&#x3C; *pInt &#x3C;&#x3C; endl;\n\nsystem(\"pause\");\nreturn 0;\n}</code></pre></p>\n<p>Đoạn chương trình trên cho ra kết quả đúng, giá trị được in ra khi sử dụng toán tử dereference để truy xuất không bị thay đổi theo thời gian, nhưng nó lại phát sinh một vấn đề khác. Đó là vấn đề gì?</p>\n<hr>\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.807439d811fbe3c25a6fe7de6f440dcd.json"}