{"head":{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","id":31625,"description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int…"},"body":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<h3>Void pointers</h3>\n\n<p>Con trỏ kiểu <strong>void</strong>, có thể gọi là con trỏ tổng quát, là một kiểu dữ liệu đặc biệt của con trỏ. Con trỏ kiểu <strong>void</strong> có thể trỏ đến bất kỳ đối tượng nào (với bất kỳ kiểu dữ liệu nào) có địa chỉ cụ thể trên bộ nhớ ảo. Cách khai báo con trỏ kiểu <strong>void</strong> cũng giống với các con trỏ có kiểu dữ liệu được xây dựng sẵn:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr; // ptr is a void pointer</code></pre>\n\n<p>Bây giờ, mình có thể gán địa chỉ của các biến có kiểu dữ liệu khác nhau cho con trỏ ptr:</p>\n\n<p></p><pre><code class=\"lang-auto\">\tvoid *ptr;\n\n\tint iValue;\n\tfloat fValue;\n\tdouble dValue;\n\tstring str;\n\tint iArr[10];\n\t\n\tptr = &amp;iValue;\n\tptr = &amp;fValue;\n\tptr = &amp;dValue;\n\tptr = &amp;str;\n\tptr = iArr;</code></pre>\n\n<p>Chúng ta còn có thể cho con trỏ <strong>void</strong> trỏ đến những con trỏ khác:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr;\n\nint *iArr = new int[10];\nptr = iArr;\n\ndelete[] iArr;</code></pre>\n\n<p>Cũng như mọi kiểu con trỏ khác, con trỏ kiểu void cũng có kích thước 4 bytes khi chạy trên nền tảng 32 bits, hoặc 8 bytes nếu chạy trên nền tàng 64 bits. Tuy nhiên, con trỏ kiểu <strong>void</strong> không xác định được kiểu dữ liệu của vùng nhớ mà nó trỏ tới, chúng ta không thể truy xuất trực tiếp nội dung thông qua toán tử <strong>dereference</strong> được. Do đó, con trỏ kiểu void cần phải được ép kiểu một cách rõ ràng sang con trỏ có kiểu dữ liệu khác trước khi sử dụng toán tử dereference cho vùng nhớ mà con trỏ đang nắm giữ.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int value = 5;\nvoid *vPtr = &amp;value;\n\nint *iPtr = static_cast&lt;int *&gt; (vPtr);\ncout &lt;&lt; *iPtr &lt;&lt; endl;</code></pre>\n\n<p>Lúc này, vPtr và iPtr đều trỏ vào địa chỉ của biến value, nhưng chúng ta chỉ có thể sử dụng toán tử <strong>dereference</strong> lên con trỏ iPtr chứ không thể sử dụng cho con trỏ vPtr.</p>\n\n<p>Điều gì xảy ra nếu chúng ta ép sai kiểu dữ liệu? </p>\n\n<p>Thử với ví dụ sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int value = 5;\nvoid *vPtr = &amp;value;\n\nint *iPtr = static_cast&lt;int *&gt; (vPtr);\ncout &lt;&lt; *iPtr &lt;&lt; endl;\n\nint64_t * i64Ptr = static_cast&lt;int64_t *&gt; (vPtr);\ncout &lt;&lt; *i64Ptr &lt;&lt; endl;</code></pre>\n\n<p>Kết quả:</p>\n\n<p>5<br>-5233161171908952059</p>\n\n<p>Như các bạn thấy, sử dụng sai kiểu dữ liệu đi kèm với đó là kết quả không mong muốn. Do đó, chúng ta nên hạn chế sử dụng con trỏ kiểu void.</p>\n\n<p><strong>Vậy chúng ta sử dụng con trỏ kiểu void cho mục đích gì?</strong></p>\n\n<p>Chúng ta thường sử dụng con trỏ kiểu <strong>void</strong> khi mà dữ liệu bên trong vùng nhớ đó không quan trọng. Ví dụ mình muốn copy dữ liệu từ dãy vùng nhớ này sang dãy vùng nhớ khác mà không cần quan tâm định dạng của chúng.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr = operator new (100);</code></pre>\n\n<p>Dòng lệnh trên sử dụng toán tử new để cấp phát 100 bytes trên Heap partition và lưu địa chỉ của vùng nhớ đó bên trong con trỏ ptr.</p>\n\n<p>Con trỏ void cũng thường được sử dụng làm tham số của hàm khi muốn input của hàm là con trỏ có kiểu dữ liệu bất kỳ. Chúng ta sẽ tìm hiểu vấn đề này trong những bài học tiếp theo.</p>\n\n<p>Việc giải phóng một vùng nhớ trên Heap bằng tên con trỏ kiểu void cũng có thể gây ra lỗi vì hệ điều hành không tính được kích thước vùng nhớ cần thu hồi là bao nhiêu.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trên thực tế, chúng ta nên tránh sử dụng con trỏ kiểu void trừ những lúc thực sự cần thiết để tránh gây ra những sai sót không đáng có cho chương trình.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","rawBody":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<h3>Void pointers</h3>\n\n<p>Con trỏ kiểu <strong>void</strong>, có thể gọi là con trỏ tổng quát, là một kiểu dữ liệu đặc biệt của con trỏ. Con trỏ kiểu <strong>void</strong> có thể trỏ đến bất kỳ đối tượng nào (với bất kỳ kiểu dữ liệu nào) có địa chỉ cụ thể trên bộ nhớ ảo. Cách khai báo con trỏ kiểu <strong>void</strong> cũng giống với các con trỏ có kiểu dữ liệu được xây dựng sẵn:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr; // ptr is a void pointer</code></pre>\n\n<p>Bây giờ, mình có thể gán địa chỉ của các biến có kiểu dữ liệu khác nhau cho con trỏ ptr:</p>\n\n<p></p><pre><code class=\"lang-auto\">\tvoid *ptr;\n\n\tint iValue;\n\tfloat fValue;\n\tdouble dValue;\n\tstring str;\n\tint iArr[10];\n\t\n\tptr = &amp;iValue;\n\tptr = &amp;fValue;\n\tptr = &amp;dValue;\n\tptr = &amp;str;\n\tptr = iArr;</code></pre>\n\n<p>Chúng ta còn có thể cho con trỏ <strong>void</strong> trỏ đến những con trỏ khác:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr;\n\nint *iArr = new int[10];\nptr = iArr;\n\ndelete[] iArr;</code></pre>\n\n<p>Cũng như mọi kiểu con trỏ khác, con trỏ kiểu void cũng có kích thước 4 bytes khi chạy trên nền tảng 32 bits, hoặc 8 bytes nếu chạy trên nền tàng 64 bits. Tuy nhiên, con trỏ kiểu <strong>void</strong> không xác định được kiểu dữ liệu của vùng nhớ mà nó trỏ tới, chúng ta không thể truy xuất trực tiếp nội dung thông qua toán tử <strong>dereference</strong> được. Do đó, con trỏ kiểu void cần phải được ép kiểu một cách rõ ràng sang con trỏ có kiểu dữ liệu khác trước khi sử dụng toán tử dereference cho vùng nhớ mà con trỏ đang nắm giữ.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int value = 5;\nvoid *vPtr = &amp;value;\n\nint *iPtr = static_cast&lt;int *&gt; (vPtr);\ncout &lt;&lt; *iPtr &lt;&lt; endl;</code></pre>\n\n<p>Lúc này, vPtr và iPtr đều trỏ vào địa chỉ của biến value, nhưng chúng ta chỉ có thể sử dụng toán tử <strong>dereference</strong> lên con trỏ iPtr chứ không thể sử dụng cho con trỏ vPtr.</p>\n\n<p>Điều gì xảy ra nếu chúng ta ép sai kiểu dữ liệu? </p>\n\n<p>Thử với ví dụ sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int value = 5;\nvoid *vPtr = &amp;value;\n\nint *iPtr = static_cast&lt;int *&gt; (vPtr);\ncout &lt;&lt; *iPtr &lt;&lt; endl;\n\nint64_t * i64Ptr = static_cast&lt;int64_t *&gt; (vPtr);\ncout &lt;&lt; *i64Ptr &lt;&lt; endl;</code></pre>\n\n<p>Kết quả:</p>\n\n<p>5<br>-5233161171908952059</p>\n\n<p>Như các bạn thấy, sử dụng sai kiểu dữ liệu đi kèm với đó là kết quả không mong muốn. Do đó, chúng ta nên hạn chế sử dụng con trỏ kiểu void.</p>\n\n<p><strong>Vậy chúng ta sử dụng con trỏ kiểu void cho mục đích gì?</strong></p>\n\n<p>Chúng ta thường sử dụng con trỏ kiểu <strong>void</strong> khi mà dữ liệu bên trong vùng nhớ đó không quan trọng. Ví dụ mình muốn copy dữ liệu từ dãy vùng nhớ này sang dãy vùng nhớ khác mà không cần quan tâm định dạng của chúng.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr = operator new (100);</code></pre>\n\n<p>Dòng lệnh trên sử dụng toán tử new để cấp phát 100 bytes trên Heap partition và lưu địa chỉ của vùng nhớ đó bên trong con trỏ ptr.</p>\n\n<p>Con trỏ void cũng thường được sử dụng làm tham số của hàm khi muốn input của hàm là con trỏ có kiểu dữ liệu bất kỳ. Chúng ta sẽ tìm hiểu vấn đề này trong những bài học tiếp theo.</p>\n\n<p>Việc giải phóng một vùng nhớ trên Heap bằng tên con trỏ kiểu void cũng có thể gây ra lỗi vì hệ điều hành không tính được kích thước vùng nhớ cần thu hồi là bao nhiêu.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trên thực tế, chúng ta nên tránh sử dụng con trỏ kiểu void trừ những lúc thực sự cần thiết để tránh gây ra những sai sót không đáng có cho chương trình.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","raw":"---json\n{\"title\":\"8.6 Con trỏ void\",\"route\":\"8/6-con-tr-void\",\"id\":31625}\n---\n\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<h3>Void pointers</h3>\n\n<p>Con trỏ kiểu <strong>void</strong>, có thể gọi là con trỏ tổng quát, là một kiểu dữ liệu đặc biệt của con trỏ. Con trỏ kiểu <strong>void</strong> có thể trỏ đến bất kỳ đối tượng nào (với bất kỳ kiểu dữ liệu nào) có địa chỉ cụ thể trên bộ nhớ ảo. Cách khai báo con trỏ kiểu <strong>void</strong> cũng giống với các con trỏ có kiểu dữ liệu được xây dựng sẵn:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr; // ptr is a void pointer</code></pre>\n\n<p>Bây giờ, mình có thể gán địa chỉ của các biến có kiểu dữ liệu khác nhau cho con trỏ ptr:</p>\n\n<p></p><pre><code class=\"lang-auto\">\tvoid *ptr;\n\n\tint iValue;\n\tfloat fValue;\n\tdouble dValue;\n\tstring str;\n\tint iArr[10];\n\t\n\tptr = &amp;iValue;\n\tptr = &amp;fValue;\n\tptr = &amp;dValue;\n\tptr = &amp;str;\n\tptr = iArr;</code></pre>\n\n<p>Chúng ta còn có thể cho con trỏ <strong>void</strong> trỏ đến những con trỏ khác:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr;\n\nint *iArr = new int[10];\nptr = iArr;\n\ndelete[] iArr;</code></pre>\n\n<p>Cũng như mọi kiểu con trỏ khác, con trỏ kiểu void cũng có kích thước 4 bytes khi chạy trên nền tảng 32 bits, hoặc 8 bytes nếu chạy trên nền tàng 64 bits. Tuy nhiên, con trỏ kiểu <strong>void</strong> không xác định được kiểu dữ liệu của vùng nhớ mà nó trỏ tới, chúng ta không thể truy xuất trực tiếp nội dung thông qua toán tử <strong>dereference</strong> được. Do đó, con trỏ kiểu void cần phải được ép kiểu một cách rõ ràng sang con trỏ có kiểu dữ liệu khác trước khi sử dụng toán tử dereference cho vùng nhớ mà con trỏ đang nắm giữ.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int value = 5;\nvoid *vPtr = &amp;value;\n\nint *iPtr = static_cast&lt;int *&gt; (vPtr);\ncout &lt;&lt; *iPtr &lt;&lt; endl;</code></pre>\n\n<p>Lúc này, vPtr và iPtr đều trỏ vào địa chỉ của biến value, nhưng chúng ta chỉ có thể sử dụng toán tử <strong>dereference</strong> lên con trỏ iPtr chứ không thể sử dụng cho con trỏ vPtr.</p>\n\n<p>Điều gì xảy ra nếu chúng ta ép sai kiểu dữ liệu? </p>\n\n<p>Thử với ví dụ sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int value = 5;\nvoid *vPtr = &amp;value;\n\nint *iPtr = static_cast&lt;int *&gt; (vPtr);\ncout &lt;&lt; *iPtr &lt;&lt; endl;\n\nint64_t * i64Ptr = static_cast&lt;int64_t *&gt; (vPtr);\ncout &lt;&lt; *i64Ptr &lt;&lt; endl;</code></pre>\n\n<p>Kết quả:</p>\n\n<p>5<br>-5233161171908952059</p>\n\n<p>Như các bạn thấy, sử dụng sai kiểu dữ liệu đi kèm với đó là kết quả không mong muốn. Do đó, chúng ta nên hạn chế sử dụng con trỏ kiểu void.</p>\n\n<p><strong>Vậy chúng ta sử dụng con trỏ kiểu void cho mục đích gì?</strong></p>\n\n<p>Chúng ta thường sử dụng con trỏ kiểu <strong>void</strong> khi mà dữ liệu bên trong vùng nhớ đó không quan trọng. Ví dụ mình muốn copy dữ liệu từ dãy vùng nhớ này sang dãy vùng nhớ khác mà không cần quan tâm định dạng của chúng.</p>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void *ptr = operator new (100);</code></pre>\n\n<p>Dòng lệnh trên sử dụng toán tử new để cấp phát 100 bytes trên Heap partition và lưu địa chỉ của vùng nhớ đó bên trong con trỏ ptr.</p>\n\n<p>Con trỏ void cũng thường được sử dụng làm tham số của hàm khi muốn input của hàm là con trỏ có kiểu dữ liệu bất kỳ. Chúng ta sẽ tìm hiểu vấn đề này trong những bài học tiếp theo.</p>\n\n<p>Việc giải phóng một vùng nhớ trên Heap bằng tên con trỏ kiểu void cũng có thể gây ra lỗi vì hệ điều hành không tính được kích thước vùng nhớ cần thu hồi là bao nhiêu.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trên thực tế, chúng ta nên tránh sử dụng con trỏ kiểu void trừ những lúc thực sự cần thiết để tránh gây ra những sai sót không đáng có cho chương trình.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.95810b485beb7091df5fbe0cdad166a6.json"}