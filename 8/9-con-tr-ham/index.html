<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/dnh-cpp/phenomic.browser.e6384768077a0a2f9d14.css" /><meta data-react-helmet="true" property="og:site_name" content="dnh-cpp"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="8.9 Con trỏ hàm"/><meta data-react-helmet="true" property="og:url" content="/8/9-con-tr-ham/"/><meta data-react-helmet="true" property="og:description" content="int main()	 { 	int n = foo(); } int main() { 	cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; } int main() { 	void(\*pSwap) (int &amp;, int &amp;) = swapValue…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="8.9 Con trỏ hàm"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="int main()	 { 	int n = foo(); } int main() { 	cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; } int main() { 	void(\*pSwap) (int &amp;, int &amp;) = swapValue…"/><meta data-react-helmet="true" name="description" content="int main()	 { 	int n = foo(); } int main() { 	cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; } int main() { 	void(\*pSwap) (int &amp;, int &amp;) = swapValue…"/><title data-react-helmet="true">8.9 Con trỏ hàm</title></head><body><div id="phenomic"><div class="_2lE56" data-reactroot="" data-reactid="1" data-react-checksum="-1554336791"><!-- react-empty: 2 --><div class="_1Ih7a _1GU64" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><div class="_1G2C6 _3fTO1" data-reactid="7"><div class="aCd9j" data-reactid="8"><a href="https://github.com/daynhauhoc/cppcoban" target="_blank" data-hint="Fork on Github" class="hint--bottom-left _2dICi" data-reactid="9"><span class="SVGInline" data-reactid="10"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span></a><a href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank" data-hint="Share on Facebook" class="hint--bottom-left _2dICi" data-reactid="11"><span class="SVGInline" data-reactid="12"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="430.113px" height="430.114px" viewBox="0 0 430.113 430.114" style="enable-background:new 0 0 430.113 430.114;"
	 xml:space="preserve">
<g>
	<path id="Facebook" d="M158.081,83.3c0,10.839,0,59.218,0,59.218h-43.385v72.412h43.385v215.183h89.122V214.936h59.805
		c0,0,5.601-34.721,8.316-72.685c-7.784,0-67.784,0-67.784,0s0-42.127,0-49.511c0-7.4,9.717-17.354,19.321-17.354
		c9.586,0,29.818,0,48.557,0c0-9.859,0-43.924,0-75.385c-25.016,0-53.476,0-66.021,0C155.878-0.004,158.081,72.48,158.081,83.3z"/>
</g>
</svg></span></a></div></div><article class="markdown-body" data-reactid="13"><h1 data-reactid="14">8.9 Con trỏ hàm</h1><div data-reactid="15"><div class="phenomic-BodyContainer" data-reactid="16">
<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>

<p>Tiếp tục tìm hiểu về con trỏ trong ngôn ngữ lập trình C++, trong bài học này, mình sẽ giới thiệu đến các bạn một loại con trỏ mới có chức năng khá đặc biệt. </p>

<p>Như chúng ta đã biết, con trỏ có chức năng lưu trữ địa chỉ của một vùng nhớ nào đó trên bộ nhớ ảo. Tuy nhiên, bộ nhớ ảo được chia làm nhiều phân vùng khác nhau.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true" class="lightbox" title="0.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true" width="640" height="500"><div class="meta">
<span class="filename">0.png?raw=true</span><span class="informations">670x523</span><span class="expand"></span>
</div></a></div></p>

<p>Như trong hình, hầu hết toàn bộ phân vùng của bộ nhớ ảo đều dùng để lưu trữ dữ liệu (biến đơn, giá trị, chuỗi kí tự, ...). Nhưng dữ liệu lưu trên bộ nhớ ảo là cái được tạo ra sau khi chương trình nào đó được thực thi và nó xin cấp phát vùng nhớ trên bộ nhớ ảo để sử dụng. Trước đó, chương trình hoạt động dựa trên các dòng lệnh mà lập trình viên đưa ra sử dụng cú pháp của ngôn ngữ lập trình nào đó. Và trước khi chạy chương trình, mã nguồn (đã được biên dịch thành mã máy) đang lưu trữ trong máy tính (có thể là trên ổ cứng) cũng phải được hệ điều hành load lên RAM và quản lý bằng cách đưa vào bộ nhớ ảo. Vậy mã nguồn của chương trình sẽ lưu ở đâu trên bộ nhớ ảo? Đó là tại phân vùng Text (<strong>Text segment</strong>) hay còn gọi là phân vùng Code (<strong>Code segment</strong>). Tất cả các lệnh, các hàm... của chương trình sẽ được đưa vào phân vùng này, trong đó có cả hàm <strong>main</strong> nếu đó là chương trình C++. Như các bạn đã biết, một chương trình C++ sẽ có duy nhất một hàm <strong>main</strong> đóng vai trò là điểm bắt đầu của chương trình đó. Như vậy, sau khi được load mã nguồn C++ đã được biên dịch lên bộ nhớ ảo, hệ điều hành sẽ tìm đến vị trí (địa chỉ) của hàm <strong>main</strong> và chuyển mã nguồn đến cho CPU xử lý.</p>

<p>Mình có thể cho các bạn xem địa chỉ của hàm <strong>main</strong> của một chương trình C++ ở trên máy mình như hình bên dưới:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/1.png?raw=true" width="579" height="384"></p>

<p>Như các bạn thấy, hàm <strong>main</strong> (hay bất kỳ hàm nào khác trong chương trình) có một địa chỉ xác định trên bộ nhớ ảo. Do đó, chúng ta có thể sử dụng con trỏ để trỏ đến địa chỉ của hàm <strong>main</strong>. Tuy nhiên, chúng ta cần lưu ý đến kiểu dữ liệu khai báo cho con trỏ phải tương thích với kiểu dữ liệu của vùng nhớ. Ví dụ, con trỏ kiểu <strong>int</strong> dùng để trỏ đến vùng nhớ kiểu <strong>int</strong>, con trỏ trỏ đến hằng (<strong>Pointer to const</strong>) dùng để trỏ đến vùng nhớ hằng... Và để trỏ đến địa chỉ của một hàm, chúng ta cần sử dụng con trỏ hàm (<strong>Function pointer</strong> hoặc có thể gọi là <strong>Pointer to function</strong>).</p>

<h3>Function pointers</h3>

<p>Khi nhìn vào một hàm (function), ví dụ:</p>

<p></p><pre><code class="lang-auto">int foo()
{
	return 0;
}</code></pre>

<p>Chúng ta có thể nói hàm này có định danh là <strong>foo</strong>, kiểu trả về là int, hàm foo không nhận đối số. Đó là những gì chúng ta thấy được trong quá trình biên soạn mã nguồn chương trình. Thuộc tính địa chỉ của hàm chỉ được sinh ra khi chương trình đã được chạy.</p>

<p></p><pre><code class="lang-auto">int foo() // code of foo start at memory address 0x01001492
{
	return 0;
}

int main()	
{
	int n = foo();
	
	return 0;
}</code></pre>

<p>Như vậy, khi trong hàm <strong>main</strong> chạy đến dòng lệnh gọi hàm <strong>foo</strong>, hệ điều hành sẽ tìm đến địa chỉ của hàm <strong>foo</strong> trên bộ nhớ ảo và chuyển mã lệnh của hàm <strong>foo</strong> cho CPU tiếp tục xử lý. Để in ra địa chỉ của hàm <strong>foo</strong>, chúng ta có thể làm như sau:</p>

<p></p><pre><code class="lang-auto">int foo()
{
	return 0;
}

int main()
{
	cout &lt;&lt; foo &lt;&lt; endl;
	
	return 0;
}</code></pre>

<p>Kết quả:</p>

<p></p><pre><code class="lang-auto">013D1492</code></pre>

<p>Như các bạn thấy, khi muốn thực thi một hàm, chúng ta cần thêm cặp dấu ngoặc để truyền đối số vào cho hàm (nếu hàm không có tham số thì để trống). Nếu chúng ta không sử dụng cặp dấu ngoặc, sử dụng tên hàm trả về địa chỉ của hàm trên bộ nhớ ảo. Và địa chỉ này có thể được gán con một con trỏ có kiểu dữ liệu tương ứng (<strong>function pointer</strong>).</p>

<h5>Function pointers syntax</h5>

<p>Cú pháp của một con trỏ hàm có nhiều điểm khác biệt so với cách khai báo con trỏ thông thường.</p>

<p></p><pre><code class="lang-auto">&lt;return_type&gt; (*&lt;name_of_pointer&gt;)( &lt;data_type_of_parameters&gt; );</code></pre>

<p>Mình lấy ví dụ, để trỏ đến hàm foo trong ví dụ trên, chúng ta cần khai báo con trỏ hàm như sau:</p>

<p></p><pre><code class="lang-auto">int (*pFoo) ();</code></pre>

<p>Trong đó, <strong>int</strong> là kiểu trả về của hàm <strong>foo</strong>, <strong>pFoo</strong> là tên của con trỏ, và hàm <strong>foo</strong> không có tham số nên phần trong ngoặc mình bỏ trống. Một ví dụ khác, mình có hàm như bên dưới:</p>

<p></p><pre><code class="lang-auto">void swapValue(int &amp;value1, int &amp;value2) 
{
	int temp = value1;
	value1 = value2;
	value2 = temp;
}</code></pre>

<p>Hàm <strong>swapValue</strong> có không có kiểu trả về, và nó nhận vào 2 tham số đều có kiểu tham chiếu <strong>int</strong>. Như vậy, mình có thể khai báo một con trỏ hàm dùng để trỏ đến hàm <strong>swapValue</strong> như sau:</p>

<p></p><pre><code class="lang-auto">void(*pSwap) (int &amp;, int &amp;);</code></pre>

<h5>Gán địa chỉ của hàm cho Function pointers</h5>

<p>Sau khi đã có được con trỏ hàm được khai báo tương ứng với hàm, chúng ta có thể gán địa chỉ của hàm cho chúng:</p>

<p></p><pre><code class="lang-auto">void swapValue(int &amp;value1, int &amp;value2) 
{
	int temp = value1;
	value1 = value2;
	value2 = temp;
}

int main()
{
	void(*pSwap) (int &amp;, int &amp;) = swapValue;
	cout &lt;&lt; pSwap &lt;&lt; endl;
	cout &lt;&lt; swapValue &lt;&lt; endl;
	
	return 0;
}</code></pre>

<p><strong>Lưu ý, khi cần lấy địa chỉ của hàm, chúng ta chỉ sử dụng duy nhất tên hàm, không đặt thêm cặp dấu ngoặc vào.</strong></p>

<p>Chỉ có con trỏ được khai báo có kiểu dữ liệu trả về và danh sách tham số phù hợp mới trỏ đến hàm được.</p>

<p></p><pre><code class="lang-auto">// function prototypes
int foo();
double goo();
int hoo(int x);
 
// function pointer assignments
int (*funcPtr1)() = foo; // okay
int (*funcPtr2)() = goo; // wrong -- return types don't match!
double (*funcPtr4)() = goo; // okay
funcPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does
int (*funcPtr3)(int) = hoo; // okay</code></pre>

<h5>Sử dụng Function pointers</h5>

<p>Sau khi đã nắm giữ được địa chỉ của hàm, con trỏ hàm có thể được sử dụng như hàm thông qua toán tử <strong>dereference</strong>. Ví dụ:</p>

<p></p><pre><code class="lang-auto">void swapValue(int &amp;value1, int &amp;value2)
{
	int temp = value1;
	value1 = value2;
	value2 = temp;
}

int main()
{
	void(*pSwap) (int &amp;, int &amp;) = swapValue;
	
	int a = 1, b = 5;
	cout &lt;&lt; "Before: " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
	(*pSwap)(a, b);
	cout &lt;&lt; "After:  " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;

	return 0;
}</code></pre>

<p>Lưu ý, tham số mặc định của hàm không áp dụng được cho con trỏ hàm, vì tham số mặc định được <strong>compiler</strong> xác định tại thời điểm <strong>compile</strong> chương trình, còn con trỏ hàm được sử dụng tại thời điểm chương trình đang chạy.</p>

<h5>Sử dụng con trỏ hàm làm tham số</h5>

<p>Một con trỏ hàm cũng là một biến con trỏ, do đó chúng ta có thể sử dụng con trỏ hàm là tham số của một hàm nào đó. Khi tham số của hàm là con trỏ hàm, chúng ta sẽ truyền đối số là địa chỉ của một hàm. Hàm được sử dụng làm đối số của hàm có thể gọi là <strong>callback function</strong>.</p>

<p>Mình lấy ví dụ về hàm <strong>selectionSort</strong> dùng để sắp xếp dữ liệu trong mảng số nguyên theo thứ tự tăng dần:</p>

<p></p><pre><code class="lang-auto">#include &lt;algorithm&gt; // use for std::swap

void selectionSort(int *arr, int length)
{
	for (int i_start = 0; i_start &lt; length; i_start++)
	{
		int minIndex = i_start;

		for (int i_current = i_start + 1; i_current &lt; length; i_current++)
		{
			if (arr[minIndex] &gt; arr[i_current])
			{
				minIndex = i_current;
			}
		}

		swap(arr[i_start], arr[minIndex]); // std::swap
	}
}

//................

int main()
{
	int arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };
	int length = sizeof(arr) / sizeof(int);

	cout &lt;&lt; "Before sorted: ";
	printArray(arr, length);

	selectionSort(arr, length);

	cout &lt;&lt; "After sorted:  ";
	printArray(arr, length);

	return 0;
}</code></pre>

<p>Kết quả:</p>

<p></p><pre><code class="lang-auto">Before sorted: 1 4 2 3 6 5 8 9 7
After sorted:  1 2 3 4 5 6 7 8 9</code></pre>

<p>Bây giờ đặt ra trường hợp chúng ta muốn có sắp xếp mảng một chiều sử dụng thuật toán <strong>selectionSort</strong> nhưng sắp xếp theo thứ tự giảm dần. Như vậy, chúng ta cần đến 2 hàm <strong>selectionSort</strong> để đáp ứng cho 2 trường hợp mình kể trên. Trong khi cả 2 hàm <strong>selectionSort</strong> này chỉ khác nhau về toán tử so sánh tại phép so sánh ở mệnh đề if trong vòng lặp. </p>

<p>Để giải quyết vấn đề này, đầu tiên mình cần có 2 hàm thực hiện công việc so sánh như sau:</p>

<p></p><pre><code class="lang-auto">bool ascending(int left, int right)
{
	return left &gt; right;
}

bool descending(int left, int right)
{
	return left &lt; right;
}</code></pre>

<p>Hai hàm này chỉ có tác dụng thay thế phép so sánh trong mệnh đề if. Nếu chúng ta cần sắp xếp giá trị trong mảng theo thứ tự tăng dần, chúng ta sẽ thay thế hàm <strong>ascending</strong> vào mệnh đề if trong hàm <strong>selectionSort</strong> như sau:</p>

<p></p><pre><code class="lang-auto">void selectionSort(int *arr, int length)
{
	for (int i_start = 0; i_start &lt; length; i_start++)
	{
		int minIndex = i_start;

		for (int i_current = i_start + 1; i_current &lt; length; i_current++)
		{
			if (ascending(arr[minIndex], arr[i_current])) // replace comparison expression by ascending function
			{
				minIndex = i_current;
			}
		}

		swap(arr[i_start], arr[minIndex]); // std::swap
	}
}</code></pre>

<p>Lúc này, chúng ta vẫn còn cần thêm một hàm <strong>selectionSort</strong> khác và thay thế biểu thức so sánh trong mệnh đề if bằng hàm <strong>descending</strong> để có thể sắp xếp mảng theo chiều giảm dần. Chúng ta cần thiết kế lại hàm <strong>selectionSort</strong> này sao cho người dùng có thể tùy chọn việc sắp xếp theo thứ tự tăng dần hay giảm dần theo từng thời điểm khác nhau. Chúng ta sẽ thêm vào tham số thứ 3 cho hàm <strong>selectionSort</strong> là một con trỏ hàm dùng để trỏ đến hàm <strong>ascending</strong> hoặc <strong>descending</strong> tùy vào lời gọi hàm <strong>selectionSort</strong>. Do hàm <strong>ascending</strong> và <strong>descending</strong> có cấu trúc kiểu trả về và tham số hoàn toàn giống nhau, nên chúng ta có thể sử dụng chung một kiểu con trỏ hàm. Mình định nghĩa con trỏ hàm dùng làm tham số thứ 3 của hàm <strong>selectionSort</strong> như sau:</p>

<p></p><pre><code class="lang-auto">bool (*comparisonFunc)(int, int);</code></pre>

<p>Bây giờ, chúng ta sẽ sửa lại hàm <strong>selectionSort</strong> thành phiên bản sử dụng con trỏ hàm:</p>

<p></p><pre><code class="lang-auto">bool ascending(int left, int right)
{
	return left &gt; right;
}

bool descending(int left, int right)
{
	return left &lt; right;
}

void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int))
{
	for (int i_start = 0; i_start &lt; length; i_start++)
	{
		int minIndex = i_start;

		for (int i_current = i_start + 1; i_current &lt; length; i_current++)
		{
			if (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function
			{
				minIndex = i_current;
			}
		}

		swap(arr[i_start], arr[minIndex]); // std::swap
	}
}</code></pre>

<p>Lúc này, giả sử mình muốn sắp xếp mảng theo thứ tự giảm dần, mình sẽ sử dụng lời gọi hàm như sau:</p>

<p></p><pre><code class="lang-auto">int main()
{
	int arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };
	int length = sizeof(arr) / sizeof(int);

	cout &lt;&lt; "Before sorted: ";
	printArray(arr, length);

	selectionSort(arr, length, descending);

	cout &lt;&lt; "After sorted:  ";
	printArray(arr, length);

	return 0;
}</code></pre>

<p>Mình sử dụng địa chỉ của hàm <strong>descending</strong> làm đối số cho tham số thứ 3 của hàm <strong>selectionSort</strong>. Như vậy, hàm <strong>descending</strong> sẽ được sử dụng bên trong hàm <strong>selectionSort</strong> và mảng của chúng ta sẽ sắp xếp theo thứ tự giảm dần.</p>

<p></p><pre><code class="lang-auto">Before sorted: 1 4 2 3 6 5 8 9 7
After sorted:  9 8 7 6 5 4 3 2 1</code></pre>

<p>Nếu muốn đổi ngược lại thứ tự của mảng khi sắp xếp, chúng ta chỉ cần thay đối số thứ 3 của hàm <strong>selectionSort</strong> là địa chỉ của hàm <strong>ascending</strong>:</p>

<p></p><pre><code class="lang-auto">int main()
{
	int arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };
	int length = sizeof(arr) / sizeof(int);

	cout &lt;&lt; "Before sorted: ";
	printArray(arr, length);

	selectionSort(arr, length, ascending);

	cout &lt;&lt; "After sorted:  ";
	printArray(arr, length);

	return 0;
}</code></pre>

<p>Với việc đặt thêm tham số thứ 3 của hàm <strong>selectionSort</strong> là 1 con trỏ hàm, chúng ta có thể thiết kế thêm nhiều tùy chọn cho điều kiện sắp xếp mảng một chiều khác nhau và vẫn có thể sử dụng cho hàm <strong>selectionSort</strong>. Ví dụ mình muốn thêm một kiểu sắp xếp có điều kiện khác là mọi số chẵn trong mảng sẽ đứng trước, các số lẻ trong mảng sẽ đứng sau, và phần chẵn hay phần lẻ đều được sắp xếp tăng dần, mình sẽ làm như sau:</p>

<p></p><pre><code class="lang-auto">bool evensFirst(int left, int right)
{
	//if left is even and right is odd, not need to swap
	if ((left % 2 == 0) &amp;&amp; (right % 2 != 0))
		return false;

	//if left is odd and right is even, swap this couple
	if ((left % 2 != 0) &amp;&amp; (right % 2 == 0))
		return true;

	return ascending(left, right);
}</code></pre>

<p>Và mình chỉ cần sử dụng địa chỉ của hàm này làm đối số:</p>

<p></p><pre><code class="lang-auto">int main()
{
	int arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };
	int length = sizeof(arr) / sizeof(int);

	cout &lt;&lt; "Before sorted: ";
	printArray(arr, length);

	selectionSort(arr, length, evensFirst);

	cout &lt;&lt; "After sorted:  ";
	printArray(arr, length);

	return 0;
}</code></pre>

<p>Kết quả:</p>

<p></p><pre><code class="lang-auto">Before sorted: 1 4 2 3 6 5 8 9 7
After sorted:  2 4 6 8 1 3 5 7 9</code></pre>

<p>Như các bạn thấy, sử dụng con trỏ hàm trong trường hợp này mang lại cho chúng ta một cách sử dụng hàm sắp xếp hiệu quả hơn.</p>

<h5>Tham số mặc định của tham số con trỏ hàm</h5>

<p>Chúng ta có thể cung cấp cho tham số con trỏ hàm một địa chỉ hàm cụ thể, và hàm đó sẽ được gọi mặc định nếu chúng ta không cung cấp đối số cho tham số con trỏ hàm. Ví dụ:</p>

<p></p><pre><code class="lang-auto">void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int) = ascending)
{
	for (int i_start = 0; i_start &lt; length; i_start++)
	{
		int minIndex = i_start;

		for (int i_current = i_start + 1; i_current &lt; length; i_current++)
		{
			if (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function
			{
				minIndex = i_current;
			}
		}

		swap(arr[i_start], arr[minIndex]); // std::swap
	}
}</code></pre>

<p>Như vậy, lời gọi hàm <strong>selectionSort</strong> với 2 đối số sẽ được mặc định là sắp xếp mảng tăng dần.</p>

<h3>std::function in C++11</h3>

<p>Chuẩn C++11 cung cấp cho chúng ta một cách thay thế cho việc sử dụng con trỏ hàm bằng cách sử dụng kiểu dữ liệu <strong>function</strong> thuộc thư viện <strong>functional</strong>. Thư viện này cũng được định nghĩa trong namespace <strong>std</strong> nên chúng ta cần có dòng lệnh <code>using namespace std;</code> hoặc có thể khai báo là <code>std::function</code>.</p>

<p>Cú pháp khai báo biến kiểu <code>std::function</code> như sau:</p>

<p></p><pre><code class="lang-auto">std::function&lt; &lt;return_type&gt;([list of parameters]) &gt; varName;</code></pre>

<p>Ví dụ:</p>

<p></p><pre><code class="lang-auto">std::function&lt; bool(int, int) &gt; comparisonFunc;</code></pre>

<p>Mình lấy ví dụ về việc sử dụng kiểu dữ liệu <code>std::function</code> như sau:</p>

<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;functional&gt;
using namespace std;

void addOne(int &amp;value)
{
	value++;
}

int main()
{
	function&lt;void(int &amp;)&gt; func = addOne;
	
	int number = 5;
	func(number);

	cout &lt;&lt; "New value: " &lt;&lt; number &lt;&lt; endl;

	return 0;
}</code></pre>

<p>Như các bạn thấy, sử dụng kiểu dữ liệu <code>std::function</code> cũng tương tự như sử dụng con trỏ hàm, chỉ khác nhau về cách khai báo.</p>

<hr>

<h3>Tổng kết</h3>

<p>Con trỏ hàm (<strong>function pointers</strong>) thường được sử dụng khi chúng ta có các hàm có cùng kiểu trả về và danh sách tham số. Đặt con trỏ hàm làm tham số của hàm cũng là một cách sử dụng con trỏ hàm khá phổ biến. </p>

<p>Vì con trỏ hàm có cú pháp khai báo khó nhớ hơn kiểu <code>std::function</code>, mình khuyến khích các bạn sử dụng kiểu <code>std::function</code> được định nghĩa bên trong thư viện <strong>functional</strong> của chuẩn C++11.</p>

<h3>Bài tập cơ bản</h3>

<p>1/ Sửa lại hàm selectionSort phiên bản sử dụng con trỏ hàm làm tham số thứ 3 sao cho phù hợp với cách định nghĩa của 2 hàm so sánh bên dưới:</p>

<p></p><pre><code class="lang-auto">bool ascending(int left, int right)
{
	return left &lt; right;
}

bool descending(int left, int right)
{
	return left &gt; right;
}</code></pre>

<p>2/ Sử dụng con trỏ hàm để tạo hàm có thể thực hiện 4 phép toán cơ bản (+, -, *, /). Biết rằng, với mỗi phép toán chúng ta có một hàm có kiểu trả về float, mỗi hàm có 2 tham số kiểu float. Sau đó, viết hoàn thiện một chương trình đơn giản cho phép người dùng nhập vào toán tử (+, -, *, /) từ bàn phím và thực hiện phép toán với toán tử tương ứng thông qua hàm mà bạn đã định nghĩa.</p>

<hr>

<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>

<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>

<p><a title="DayNhauHoc" class="onebox" target="_blank">www.daynhauhoc.com</a></p>
</div></div></article></div></div></div><div class="_30zqN _1M-6l _7YJ7M" data-reactid="17"><div style="position:relative;overflow:hidden;width:100%;height:100%;" data-reactid="18"><div style="position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;-webkit-overflow-scrolling:touch;margin-right:0;margin-bottom:0;" data-reactid="19"><ul style="list-style:none;background-color:transparent;margin:0;padding:0;color:#242a31;font-family:lucida grande ,tahoma,verdana,arial,sans-serif;font-size:14px;" data-reactid="20"><li style="position:relative;" data-reactid="21"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="22"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="23"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="24"><svg height="14" width="14" data-reactid="25"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="26"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="27"><div style="line-height:24px;vertical-align:middle;font-size:1.5em;font-weight:300;font-family:Source Sans Pro,sans-serif;margin-bottom:1em;" data-reactid="28">Khóa học C++</div></div></div><span data-reactid="29"><ul style="list-style:none;padding-left:19px;" data-reactid="30"><li style="position:relative;" data-reactid="31"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="32"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="33"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="34"><svg height="14" width="14" data-reactid="35"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="36"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="37"><div style="line-height:24px;vertical-align:middle;" data-reactid="38">Giới thiệu tổng quan khóa học</div></div></div><span data-reactid="39"></span></li><li style="position:relative;" data-reactid="40"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="41"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="42"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="43"><svg height="14" width="14" data-reactid="44"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="45"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="46"><div style="line-height:24px;vertical-align:middle;" data-reactid="47">C++ cơ bản</div></div></div><span data-reactid="48"></span></li><li style="position:relative;" data-reactid="49"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="50"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="51"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="52"><svg height="14" width="14" data-reactid="53"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="54"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="55"><div style="line-height:24px;vertical-align:middle;" data-reactid="56">Cấu trúc rẽ nhánh</div></div></div><span data-reactid="57"></span></li><li style="position:relative;" data-reactid="58"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="59"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="60"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="61"><svg height="14" width="14" data-reactid="62"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="63"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="64"><div style="line-height:24px;vertical-align:middle;" data-reactid="65">Cấu trúc vòng lặp</div></div></div><span data-reactid="66"></span></li><li style="position:relative;" data-reactid="67"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="68"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="69"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="70"><svg height="14" width="14" data-reactid="71"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="72"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="73"><div style="line-height:24px;vertical-align:middle;" data-reactid="74">Nâng cao về biến, kiểu dữ liệu</div></div></div><span data-reactid="75"></span></li><li style="position:relative;" data-reactid="76"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="77"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="78"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="79"><svg height="14" width="14" data-reactid="80"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="81"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="82"><div style="line-height:24px;vertical-align:middle;" data-reactid="83">Kiểu dữ liệu mảng</div></div></div><span data-reactid="84"></span></li><li style="position:relative;" data-reactid="85"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="86"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="87"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="88"><svg height="14" width="14" data-reactid="89"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="90"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="91"><div style="line-height:24px;vertical-align:middle;" data-reactid="92">Kiểu chuỗi kí tự</div></div></div><span data-reactid="93"></span></li><li style="position:relative;" data-reactid="94"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="95"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="96"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="97"><svg height="14" width="14" data-reactid="98"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="99"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="100"><div style="line-height:24px;vertical-align:middle;" data-reactid="101">Cơ bản về Function</div></div></div><span data-reactid="102"></span></li><li style="position:relative;" data-reactid="103"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="104"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="105"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="106"><svg height="14" width="14" data-reactid="107"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="108"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="109"><div style="line-height:24px;vertical-align:middle;" data-reactid="110">Con trỏ</div></div></div><span data-reactid="111"></span></li><li style="position:relative;" data-reactid="112"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="113"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="114"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="115"><svg height="14" width="14" data-reactid="116"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="117"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="118"><div style="line-height:24px;vertical-align:middle;" data-reactid="119">Kiểu dữ liệu tự định nghĩa</div></div></div><span data-reactid="120"></span></li><li style="position:relative;" data-reactid="121"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="122"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="123"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="124"><svg height="14" width="14" data-reactid="125"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="126"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="127"><div style="line-height:24px;vertical-align:middle;" data-reactid="128">Nhập, xuất (Input &amp; Output)</div></div></div><span data-reactid="129"></span></li><li style="position:relative;" data-reactid="130"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="131"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="132"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="133"><svg height="14" width="14" data-reactid="134"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="135"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="136"><div style="line-height:24px;vertical-align:middle;" data-reactid="137">Một số thư viện thường dùng trong STL</div></div></div><span data-reactid="138"></span></li><li style="position:relative;" data-reactid="139"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="140"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="141"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="142"><svg height="14" width="14" data-reactid="143"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="144"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="145"><div style="line-height:24px;vertical-align:middle;" data-reactid="146">Auto pointer</div></div></div><span data-reactid="147"></span></li><li style="position:relative;" data-reactid="148"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="149"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="150"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="151"><svg height="14" width="14" data-reactid="152"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="153"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="154"><div style="line-height:24px;vertical-align:middle;" data-reactid="155">Quản lý mã nguồn</div></div></div><span data-reactid="156"></span></li><li style="position:relative;" data-reactid="157"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="158"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="159"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="160"><svg height="14" width="14" data-reactid="161"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="162"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="163"><div style="line-height:24px;vertical-align:middle;" data-reactid="164">Một số feature trong C++11, C++14</div></div></div><span data-reactid="165"></span></li></ul></span></li></ul></div><div style="position:absolute;height:6px;display:none;right:2px;bottom:2px;left:2px;border-radius:3px;" data-reactid="166"><div style="position:relative;display:block;height:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="167"></div></div><div style="position:absolute;width:6px;display:none;right:2px;bottom:2px;top:2px;border-radius:3px;" data-reactid="168"><div style="position:relative;display:block;width:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="169"></div></div></div></div><div class="_3eRtW _1tTpi" data-reactid="170"><span class="SVGInline" data-reactid="171"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 396.667 396.667" style="enable-background:new 0 0 396.667 396.667;" xml:space="preserve">
<g>
	<g>
		<path d="M17,87.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17C0,80.183,7.65,87.833,17,87.833z"/>
		<path d="M17,215.333h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,215.333,17,215.333z"/>
		<path d="M17,342.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,342.833,17,342.833z"/>
	</g>
</g>
</svg></span></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"title":"Cài đặt Code::blocks để lập trình C++ trên Ubuntu/Linux","route":"0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux","description":"int main() {   std::cout &lt;&lt; \"Hello World!\"; }","__filename":"generated/24563.md","__url":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/","__resourceUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html","__dataUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html.d7146b8f6b06f293bfd7d7072595786f.json"},{"title":"Cài đặt Xcode để lập trình C++ trên Mac OS X","route":"0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x","description":"int main() {     std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;     return 0; }","__filename":"generated/24606.md","__url":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/","__resourceUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html","__dataUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html.b267f6bba27c47a6fd8837792aa9ed05.json"},{"title":"Cài đặt Visual Studio 2015 để lập trình C++ trên Windows","route":"0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows","description":"","__filename":"generated/24768.md","__url":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/","__resourceUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html","__dataUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html.acf989adbfe293778195699d01ad0f77.json"},{"title":"0.0 Giới thiệu về series tutorial","route":"0/0-gioi-thieu-ve-series-tutorial","description":"Tóm tắt về bản thân  Minh tên Lê Trần Đạt, 28 tuổi, là lập trình viên lập trình nhúng, ngoài làm việc mình thích dạy học online và viết. Tự…","__filename":"generated/29402.md","__url":"/0/0-gioi-thieu-ve-series-tutorial/","__resourceUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html","__dataUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html.b3a9c7a55cfe71fb06282d41eb35a19e.json"},{"title":"0.1 Giới thiệu về ngôn ngữ lập trình","route":"0/1-gioi-thieu-ve-ngon-ngu-lap-trinh","description":"","__filename":"generated/29425.md","__url":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/","__resourceUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html","__dataUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html.ee05b7a2f09ce56983fe6ecdb5e2cae1.json"},{"title":"0.2 Giới thiệu về ngôn ngữ lập trình C++","route":"0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c","description":"","__filename":"generated/29448.md","__url":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/","__resourceUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html","__dataUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html.eb8440bdc067f39ed5ed01dcb67ec011.json"},{"title":"0.3 Các công đoạn phát triển của một chương trình C++","route":"0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c","description":"","__filename":"generated/29449.md","__url":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/","__resourceUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html.985676c594c63a65a27c349d01aba1c2.json"},{"title":"0.4 Giới thiệu môi trường phát triển ứng dụng C++","route":"0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c","description":"","__filename":"generated/29503.md","__url":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/","__resourceUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html","__dataUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html.4d09242acbe8c00d559a65dfa4e010c8.json"},{"title":"1.0 Viết chương trình đầu tiên","route":"1/0-viet-chuong-trinh-dau-tien","description":"Các bạn sẽ thấy nhiều hàm main có cách khai báo khác nhau. Nhưng với việc bạn là người mới bắt đầu học…","__filename":"generated/29504.md","__url":"/1/0-viet-chuong-trinh-dau-tien/","__resourceUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html","__dataUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html.6d8bc2f6cad6284e8e2fd1bef2562ea3.json"},{"title":"1.1 Cấu trúc cơ bản của một chương trình C++","route":"1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c","description":"\\#include &lt;iostream> using namespace std; int main()\t{ \t// We write some code inside main function. } } / We can put…","__filename":"generated/29527.md","__url":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/","__resourceUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html.1754c050053054d0d4962d6ed4069bcc.json"},{"title":"1.10 Độ ưu tiên của các toán tử","route":"1/10-do-uu-tien-cua-cac-toan-tu","description":"","__filename":"generated/29574.md","__url":"/1/10-do-uu-tien-cua-cac-toan-tu/","__resourceUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html","__dataUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html.2ed2467f55ba1f9faebf54445fa0e702.json"},{"title":"1.2 Lệnh, khối lệnh, từ khóa","route":"1/2-lenh-khoi-lenh-tu-khoa","description":"Những dòng lệnh bên trong thân hàm main. (Có thể có hoặc không) Những dòng comment. (Có thể có hoặc không) Tích hợp thư viện và không gian…","__filename":"generated/29575.md","__url":"/1/2-lenh-khoi-lenh-tu-khoa/","__resourceUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html","__dataUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html.bf958184eaea47730791808e2dc576df.json"},{"title":"1.3 Sử dụng các lệnh liên quan đến xuất dữ liệu","route":"1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu","description":"","__filename":"generated/29796.md","__url":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/","__resourceUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html","__dataUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html.764e0a3a06f81e99ab53a9ab17e892f9.json"},{"title":"1.4 Biến và các kiểu dữ liệu trong C++","route":"1/4-bien-va-cac-kieu-du-lieu-trong-c","description":"float valueFloat = 5.394; // (2) Xin hệ điều hành thêm một vùng nhớ để chứa 1 số thực string myName = \"Minh Vu\"; // (3) Biến này chứa được…","__filename":"generated/29935.md","__url":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/","__resourceUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html","__dataUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html.dffc5fbfdf664d44b3b28b7905117ee5.json"},{"title":"1.6 Hằng số","route":"1/6-hang-so","description":"","__filename":"generated/29938.md","__url":"/1/6-hang-so/","__resourceUrl":"/1/6-hang-so/index.html","__dataUrl":"/1/6-hang-so/index.html.a053963fb53e3188dd8ab0c9dac43085.json"},{"title":"1.5 Nhập và xuất dữ liệu","route":"1/5-nhap-va-xuat-du-lieu","description":"","__filename":"generated/29936.md","__url":"/1/5-nhap-va-xuat-du-lieu/","__resourceUrl":"/1/5-nhap-va-xuat-du-lieu/index.html","__dataUrl":"/1/5-nhap-va-xuat-du-lieu/index.html.c56c9c3f92a8e8db1438ddde847a2a16.json"},{"title":"1.7 Phạm vi của biến","route":"1/7-pham-vi-cua-bien","description":"int value = 1; int main()\t{ }","__filename":"generated/29939.md","__url":"/1/7-pham-vi-cua-bien/","__resourceUrl":"/1/7-pham-vi-cua-bien/index.html","__dataUrl":"/1/7-pham-vi-cua-bien/index.html.64607a2e78fc6b0159cfb3975ff151d6.json"},{"title":"1.8 Các phép toán cơ bản","route":"1/8-cac-phep-toan-co-ban","description":"int another_variable = 3; variable = another_variable \\* 2; variable = variable + 1; //tăng giá trị biến variable lên…","__filename":"generated/29944.md","__url":"/1/8-cac-phep-toan-co-ban/","__resourceUrl":"/1/8-cac-phep-toan-co-ban/index.html","__dataUrl":"/1/8-cac-phep-toan-co-ban/index.html.66e87835a401bc447f8384e79b564131.json"},{"title":"1.9 Toán tử tăng giảm","route":"1/9-toan-tu-tang-giam","description":"","__filename":"generated/29945.md","__url":"/1/9-toan-tu-tang-giam/","__resourceUrl":"/1/9-toan-tu-tang-giam/index.html","__dataUrl":"/1/9-toan-tu-tang-giam/index.html.abef97628c0b0b73bcc4d77d8d04b434.json"},{"title":"2.0 Boolean","route":"2/0-boolean","description":"int a = 2, b = 4; a \\* 3 != b; //đúng int main() { \tcout &lt;&lt; true &lt;&lt; endl; \tcout &lt;&lt; false &lt;&lt; endl; } int main…","__filename":"generated/29992.md","__url":"/2/0-boolean/","__resourceUrl":"/2/0-boolean/index.html","__dataUrl":"/2/0-boolean/index.html.68ed7d7b73e2f995c30477ffd2450120.json"},{"title":"2.1 Giới thiệu một số cấu trúc điều khiển","route":"2/1-gioi-thieu-mot-so-cau-truc-dieu-khien","description":"int main() { \tcout &lt;&lt; \"This line is printed out.\" &lt;&lt; endl; \texit(-1); //Terminate and return -1 to operating system.  \tcout &lt…","__filename":"generated/30007.md","__url":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/","__resourceUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html","__dataUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html.f922a5691cd782f11d83854853313a15.json"},{"title":"2.2 if statements","route":"2/2-if-statements","description":"} } if(value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; } if (value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl…","__filename":"generated/30008.md","__url":"/2/2-if-statements/","__resourceUrl":"/2/2-if-statements/index.html","__dataUrl":"/2/2-if-statements/index.html.7b04da482f36108555912c4dc0604cc1.json"},{"title":"2.3 switch case statements","route":"2/3-switch-case-statements","description":"} }","__filename":"generated/30009.md","__url":"/2/3-switch-case-statements/","__resourceUrl":"/2/3-switch-case-statements/index.html","__dataUrl":"/2/3-switch-case-statements/index.html.9fe094b93c2d8db3141fd46d847d467c.json"},{"title":"3.0 Vòng lặp while","route":"3/0-vong-lap-while","description":"} while (score &lt; 4) { \tcount++; \tcout &lt;&lt; \"Learn C++ programming language...\" &lt;&lt; endl; \tcout &lt;&lt; \"Enter your final score…","__filename":"generated/30011.md","__url":"/3/0-vong-lap-while/","__resourceUrl":"/3/0-vong-lap-while/index.html","__dataUrl":"/3/0-vong-lap-while/index.html.8611da6a5d3acd3ba1b3db2bccd4ded2.json"},{"title":"3.1 Vòng lặp do-while","route":"3/1-vong-lap-do-while","description":"} const int ID = 123; const int password = 123456; int main() { \t//................. }","__filename":"generated/30012.md","__url":"/3/1-vong-lap-do-while/","__resourceUrl":"/3/1-vong-lap-do-while/index.html","__dataUrl":"/3/1-vong-lap-do-while/index.html.8118d8e5f576f351b305bd20ccff339a.json"},{"title":"3.2 Vòng lặp for","route":"3/2-vong-lap-for","description":"}","__filename":"generated/30013.md","__url":"/3/2-vong-lap-for/","__resourceUrl":"/3/2-vong-lap-for/index.html","__dataUrl":"/3/2-vong-lap-for/index.html.d9f9bf135a584e44a623c43dc2a1d4b7.json"},{"title":"3.3 từ khóa break và continue","route":"3/3-tu-khoa-break-va-continue","description":"} } }","__filename":"generated/30014.md","__url":"/3/3-tu-khoa-break-va-continue/","__resourceUrl":"/3/3-tu-khoa-break-va-continue/index.html","__dataUrl":"/3/3-tu-khoa-break-va-continue/index.html.3b5d42b0f50995d27f54e8f8be5a4cc0.json"},{"title":"4.0 Sử dụng thư viện cstdint","route":"4/0-su-dung-thu-vien-cstdint","description":"int main()\t{ } //in ra kết quả là giá trị lớn nhất của 5 số vừa nhập //in ra kết quả là giá trị nhỏ nhất của 5 số vừa nhập int main…","__filename":"generated/30016.md","__url":"/4/0-su-dung-thu-vien-cstdint/","__resourceUrl":"/4/0-su-dung-thu-vien-cstdint/index.html","__dataUrl":"/4/0-su-dung-thu-vien-cstdint/index.html.aff7e4b68f74e27b2d9c9e8aabafb425.json"},{"title":"4.1 Kiểu kí tự","route":"4/1-kieu-ki-tu","description":"//check if there is any character exist in stdin file object if (!cin.eof())\t{ \tcout &lt;&lt; \"There are some character more in stdin file…","__filename":"generated/30018.md","__url":"/4/1-kieu-ki-tu/","__resourceUrl":"/4/1-kieu-ki-tu/index.html","__dataUrl":"/4/1-kieu-ki-tu/index.html.9982f009ee563c9838c9470e7bccce0d.json"},{"title":"4.2 Ép kiểu dữ liệu","route":"4/2-ep-kieu-du-lieu","description":"","__filename":"generated/30019.md","__url":"/4/2-ep-kieu-du-lieu/","__resourceUrl":"/4/2-ep-kieu-du-lieu/index.html","__dataUrl":"/4/2-ep-kieu-du-lieu/index.html.9093a9b251652c3f0d9c518a05058b3c.json"},{"title":"4.3 auto và decltype","route":"4/3-auto-va-decltype","description":"// compare the type of n with type int32_t if (typeid(int32_t) == typeid(n)) \tcout &lt;&lt; \"n is an object of type int32_t\" &lt;&lt; endl…","__filename":"generated/30020.md","__url":"/4/3-auto-va-decltype/","__resourceUrl":"/4/3-auto-va-decltype/index.html","__dataUrl":"/4/3-auto-va-decltype/index.html.6492a2c327eec109328a4f36f875b5ec.json"},{"title":"4.4 Địa chỉ của biến","route":"4/4-dia-chi-cua-bien","description":"cout &lt;&lt; \"Value of var: \" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; \"Value of var_reference: \" &lt;&lt; var_reference &lt;&lt; endl…","__filename":"generated/30022.md","__url":"/4/4-dia-chi-cua-bien/","__resourceUrl":"/4/4-dia-chi-cua-bien/index.html","__dataUrl":"/4/4-dia-chi-cua-bien/index.html.ec3e9179d8d83f7637aea29c682e42c9.json"},{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt…","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.db023247931fdd0e22e4bdf7ad1c7ff1.json"},{"title":"5.1 Các thao tác cơ bản với mảng một chiều","route":"5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu","description":"int32_t arr[ARRAY_SIZE];\t int32_t arr_clone[ARRAY_SIZE]; } } int main() { \tchar ch_array\\[] = { 'L', 'e', 'T', 'r', 'a', 'n', 'D', 'a…","__filename":"generated/30082.md","__url":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/","__resourceUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html","__dataUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html.8a635c59a7efecc14b6166c240ef06ff.json"},{"title":"5.2 Thư viện array trong STL","route":"5/2-thu-vien-array-trong-stl","description":"//Access to all of elements of arr object for (int32_t index = 0; index &lt;= arr.size() - 1; index++) { \tcout &lt;&lt; arr[index] &lt;&lt…","__filename":"generated/30083.md","__url":"/5/2-thu-vien-array-trong-stl/","__resourceUrl":"/5/2-thu-vien-array-trong-stl/index.html","__dataUrl":"/5/2-thu-vien-array-trong-stl/index.html.4d2fcee9d1d839fa510361a92690a625.json"},{"title":"5.3 Mảng hai chiều","route":"5/3-mang-hai-chieu","description":"for(int row = 0; row &lt; 3; row++) { \tfor(int col = 0; col &lt; 4; col++) \t{ \t\tcout &lt;&lt; board[row][col] &lt;&lt; \" \"; \t} \tcout &lt;&lt…","__filename":"generated/30085.md","__url":"/5/3-mang-hai-chieu/","__resourceUrl":"/5/3-mang-hai-chieu/index.html","__dataUrl":"/5/3-mang-hai-chieu/index.html.b5c4d6bd648ebce96975afc0a540003c.json"},{"title":"5.4 Các thao tác cơ bản với mảng hai chiều","route":"5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu","description":"} }","__filename":"generated/30086.md","__url":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/","__resourceUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html","__dataUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html.6e869616a193f204da370ff6042afac3.json"},{"title":"6.0 Mảng kí tự","route":"6/0-mang-ki-tu","description":"cout &lt;&lt; \"Enter your full name: \"; cin >> full_name; cout &lt;&lt; \"Your full name is \" &lt;&lt; full_name &lt;&lt; endl; cout &lt…","__filename":"generated/30090.md","__url":"/6/0-mang-ki-tu/","__resourceUrl":"/6/0-mang-ki-tu/index.html","__dataUrl":"/6/0-mang-ki-tu/index.html.e00029e1f168f1d138caba46b0257e9f.json"},{"title":"6.1 Các thao tác cơ bản với mảng kí tự","route":"6/1-cac-thao-tac-co-ban-voi-mang-ki-tu","description":"memset(foo, '-', 7); cout &lt;&lt; foo &lt;&lt; endl; \\-------every programmer should know memset! strcpy(str_destination, str_source…","__filename":"generated/30091.md","__url":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/","__resourceUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html","__dataUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html.b7aa8fed8d72491d018cc1daa25b8509.json"},{"title":"6.2 Thư viện string trong C++","route":"6/2-thu-vien-string-trong-c","description":"//......... string my_string; string temp_string(\"What the hell is going on?\"); string one_more = temp_string; string it_just_began(temp…","__filename":"generated/30092.md","__url":"/6/2-thu-vien-string-trong-c/","__resourceUrl":"/6/2-thu-vien-string-trong-c/index.html","__dataUrl":"/6/2-thu-vien-string-trong-c/index.html.fa8f82230a15f56f06af44a5d465f939.json"},{"title":"7.0 Làm quen với khái niệm function","route":"7/0-lam-quen-voi-khai-niem-function","description":"if(strlen(str1) == strlen(str2))\t{ \t//do something } void introduce() { \tcout &lt;&lt; \"Hello!\" &lt;&lt; endl; \tcout &lt;&lt; \"I'm a…","__filename":"generated/30132.md","__url":"/7/0-lam-quen-voi-khai-niem-function/","__resourceUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html","__dataUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html.65f217e229d77ce8b2497175dceac24f.json"},{"title":"7.1 Thiết kế chương trình dựa trên khái niệm function","route":"7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function","description":"} } float subtraction(float value1, float value2) { \treturn value1 - value2; } float multiplication(float value1, float value2) { \treturn…","__filename":"generated/30133.md","__url":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/","__resourceUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html","__dataUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html.709c05b00b2bae84c7baad49de176dbd.json"},{"title":"7.2 Truyền đối số cho hàm là giá trị hoặc tham chiếu","route":"7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu","description":"} } int main() { \tint argument; \tcout &lt;&lt; \"Address of argument: \" &lt;&lt; &argument &lt;&lt; endl; \tprintAddressOfParameter(argument…","__filename":"generated/30319.md","__url":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html.9f6c74d5d714f90dd4eb8741c7848e47.json"},{"title":"7.3 Hàm trả về giá trị hoặc tham chiếu","route":"7/3-ham-tra-ve-gia-tri-hoac-tham-chieu","description":"// .............. // function call int result = doubleValue(10); // ................ // function call int & myRef = returnReference(); for…","__filename":"generated/30381.md","__url":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html.461ae9d757da250cc59984265501a866.json"},{"title":"7.4 Tham số mặc định, tham số hằng","route":"7/4-tham-so-mac-dinh-tham-so-hang","description":"int main() { \tstring non_const_msg = \"This is non-const message\"; \tconst string const_msg = \"This is const message\"; } int main() { }","__filename":"generated/30382.md","__url":"/7/4-tham-so-mac-dinh-tham-so-hang/","__resourceUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html","__dataUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html.9d8d265a84d637c3c05004f404728474.json"},{"title":"7.5 Function overloading","route":"7/5-function-overloading","description":"float addFloat(float f1, float f2) { \treturn f1 + f2; } float add(float f1, float f2) { \treturn f1 + f2; } print(0); print('a'); print…","__filename":"generated/30477.md","__url":"/7/5-function-overloading/","__resourceUrl":"/7/5-function-overloading/index.html","__dataUrl":"/7/5-function-overloading/index.html.2290b48f00a85929ef4aba00f5401e08.json"},{"title":"8.0 Con trỏ","route":"8/0-con-tr","description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt…","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.c96a1fa2938a6be431d4ca1446f891e1.json"},{"title":"8.1 Toán tử tăng, giảm dùng cho con trỏ","route":"8/1-toan-tu-tang-giam-dung-cho-con-tr","description":"cout &lt;&lt; \"Before decreased: \" &lt;&lt; ptr &lt;&lt; endl; ptr--; cout &lt;&lt; \" After decreased: \" &lt;&lt; ptr &lt;&lt; endl; cout…","__filename":"generated/30699.md","__url":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/","__resourceUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html","__dataUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html.b0629507a79bd1a3061af63f38b13ff9.json"},{"title":"8.2 Con trỏ và mảng một chiều","route":"8/2-con-tr-va-mang-mot-chieu","description":"//show address of the first element of arr cout &lt;&lt; &arr[0] &lt;&lt; endl; //show address of the first element of arr cout &lt;&lt…","__filename":"generated/30788.md","__url":"/8/2-con-tr-va-mang-mot-chieu/","__resourceUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html","__dataUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html.b5e8e82e62fce2b9e1353768b39948ca.json"},{"title":"8.3 Con trỏ và mảng kí tự","route":"8/3-con-tr-va-mang-ki-tu","description":"p_name[1] = 'E'; cout &lt;&lt; my_name &lt;&lt; endl; cout &lt;&lt; p_name &lt;&lt; endl; } \"Le Tran Dat\"[1] = 'E'; //this line will make…","__filename":"generated/30876.md","__url":"/8/3-con-tr-va-mang-ki-tu/","__resourceUrl":"/8/3-con-tr-va-mang-ki-tu/index.html","__dataUrl":"/8/3-con-tr-va-mang-ki-tu/index.html.5583c492247883ef973e567716a9ec31.json"},{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt…","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.eb83f8a3bbb96ccc9afb58a885bbae19.json"},{"title":"8.5 Con trỏ và hằng","route":"8/5-con-tr-va-hang","description":"int value1 = 5; ptr = &value1; int value2 = 10; ptr = &value2; &ptr = 10; //compile error int otherValue = 10; ptr = &otherValue…","__filename":"generated/31355.md","__url":"/8/5-con-tr-va-hang/","__resourceUrl":"/8/5-con-tr-va-hang/index.html","__dataUrl":"/8/5-con-tr-va-hang/index.html.db6a1713c09e060e1515fabd7a42c5d4.json"},{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int…","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.792da3c393bbac25881f92a268beee71.json"},{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl…","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.054dae5e872a1f2c75e3062bd577174a.json"},{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue…","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.bc2b8ac23d5e828477e2e837d3519fd7.json"},{"title":"8.10 Phân loại các vùng nhớ (stack & heap ...)","route":"8/10-phan-loai-cac-vung-nho-stack-va-heap","description":"","__filename":"generated/32101.md","__url":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/","__resourceUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html","__dataUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html.ee65b1f85a502eb43fca51c20ed8fb57.json"},{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i…","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/8/7-con-tr-tr-den-con-tr/index.html.d07a86154a6961984bd2566d041f6e1e.json"},{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int…","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.6e1574bcefc94d2d2e3a4ef309681497.json"},{"title":"9.0 Kiểu liệt kê (enum)","route":"9/0-kieu-liet-ke-enum","description":"enum Color { \tRED, \tGREEN, \tBLUE, \tWHITE }; enum Animal { \tCAT, \tDOG, \tHORSE, \tMONKEY, \tCHICKEN }; } int iValue = LETTER_A; cout &lt;&lt…","__filename":"generated/32760.md","__url":"/9/0-kieu-liet-ke-enum/","__resourceUrl":"/9/0-kieu-liet-ke-enum/index.html","__dataUrl":"/9/0-kieu-liet-ke-enum/index.html.860576a918a655f1f53e822bc51c8bf5.json"},{"title":"9.1 Structs","route":"9/1-structs","description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent…","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.3a2cb4930e4325d583c56db63e3817bf.json"},{"title":"Khóa học C++","description":"","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.6be0918faeb891a3ade9da07ef33c29b.json"}];window.__INITIAL_STATE__ = {"pages":{"/8/9-con-tr-ham/":{"head":{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue…"},"body":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục tìm hiểu về con trỏ trong ngôn ngữ lập trình C++, trong bài học này, mình sẽ giới thiệu đến các bạn một loại con trỏ mới có chức năng khá đặc biệt. </p>\n\n<p>Như chúng ta đã biết, con trỏ có chức năng lưu trữ địa chỉ của một vùng nhớ nào đó trên bộ nhớ ảo. Tuy nhiên, bộ nhớ ảo được chia làm nhiều phân vùng khác nhau.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như trong hình, hầu hết toàn bộ phân vùng của bộ nhớ ảo đều dùng để lưu trữ dữ liệu (biến đơn, giá trị, chuỗi kí tự, ...). Nhưng dữ liệu lưu trên bộ nhớ ảo là cái được tạo ra sau khi chương trình nào đó được thực thi và nó xin cấp phát vùng nhớ trên bộ nhớ ảo để sử dụng. Trước đó, chương trình hoạt động dựa trên các dòng lệnh mà lập trình viên đưa ra sử dụng cú pháp của ngôn ngữ lập trình nào đó. Và trước khi chạy chương trình, mã nguồn (đã được biên dịch thành mã máy) đang lưu trữ trong máy tính (có thể là trên ổ cứng) cũng phải được hệ điều hành load lên RAM và quản lý bằng cách đưa vào bộ nhớ ảo. Vậy mã nguồn của chương trình sẽ lưu ở đâu trên bộ nhớ ảo? Đó là tại phân vùng Text (<strong>Text segment</strong>) hay còn gọi là phân vùng Code (<strong>Code segment</strong>). Tất cả các lệnh, các hàm... của chương trình sẽ được đưa vào phân vùng này, trong đó có cả hàm <strong>main</strong> nếu đó là chương trình C++. Như các bạn đã biết, một chương trình C++ sẽ có duy nhất một hàm <strong>main</strong> đóng vai trò là điểm bắt đầu của chương trình đó. Như vậy, sau khi được load mã nguồn C++ đã được biên dịch lên bộ nhớ ảo, hệ điều hành sẽ tìm đến vị trí (địa chỉ) của hàm <strong>main</strong> và chuyển mã nguồn đến cho CPU xử lý.</p>\n\n<p>Mình có thể cho các bạn xem địa chỉ của hàm <strong>main</strong> của một chương trình C++ ở trên máy mình như hình bên dưới:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/1.png?raw=true\" width=\"579\" height=\"384\"></p>\n\n<p>Như các bạn thấy, hàm <strong>main</strong> (hay bất kỳ hàm nào khác trong chương trình) có một địa chỉ xác định trên bộ nhớ ảo. Do đó, chúng ta có thể sử dụng con trỏ để trỏ đến địa chỉ của hàm <strong>main</strong>. Tuy nhiên, chúng ta cần lưu ý đến kiểu dữ liệu khai báo cho con trỏ phải tương thích với kiểu dữ liệu của vùng nhớ. Ví dụ, con trỏ kiểu <strong>int</strong> dùng để trỏ đến vùng nhớ kiểu <strong>int</strong>, con trỏ trỏ đến hằng (<strong>Pointer to const</strong>) dùng để trỏ đến vùng nhớ hằng... Và để trỏ đến địa chỉ của một hàm, chúng ta cần sử dụng con trỏ hàm (<strong>Function pointer</strong> hoặc có thể gọi là <strong>Pointer to function</strong>).</p>\n\n<h3>Function pointers</h3>\n\n<p>Khi nhìn vào một hàm (function), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể nói hàm này có định danh là <strong>foo</strong>, kiểu trả về là int, hàm foo không nhận đối số. Đó là những gì chúng ta thấy được trong quá trình biên soạn mã nguồn chương trình. Thuộc tính địa chỉ của hàm chỉ được sinh ra khi chương trình đã được chạy.</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo() // code of foo start at memory address 0x01001492\n{\n\treturn 0;\n}\n\nint main()\t\n{\n\tint n = foo();\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Như vậy, khi trong hàm <strong>main</strong> chạy đến dòng lệnh gọi hàm <strong>foo</strong>, hệ điều hành sẽ tìm đến địa chỉ của hàm <strong>foo</strong> trên bộ nhớ ảo và chuyển mã lệnh của hàm <strong>foo</strong> cho CPU tiếp tục xử lý. Để in ra địa chỉ của hàm <strong>foo</strong>, chúng ta có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}\n\nint main()\n{\n\tcout &lt;&lt; foo &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">013D1492</code></pre>\n\n<p>Như các bạn thấy, khi muốn thực thi một hàm, chúng ta cần thêm cặp dấu ngoặc để truyền đối số vào cho hàm (nếu hàm không có tham số thì để trống). Nếu chúng ta không sử dụng cặp dấu ngoặc, sử dụng tên hàm trả về địa chỉ của hàm trên bộ nhớ ảo. Và địa chỉ này có thể được gán con một con trỏ có kiểu dữ liệu tương ứng (<strong>function pointer</strong>).</p>\n\n<h5>Function pointers syntax</h5>\n\n<p>Cú pháp của một con trỏ hàm có nhiều điểm khác biệt so với cách khai báo con trỏ thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">&lt;return_type&gt; (*&lt;name_of_pointer&gt;)( &lt;data_type_of_parameters&gt; );</code></pre>\n\n<p>Mình lấy ví dụ, để trỏ đến hàm foo trong ví dụ trên, chúng ta cần khai báo con trỏ hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int (*pFoo) ();</code></pre>\n\n<p>Trong đó, <strong>int</strong> là kiểu trả về của hàm <strong>foo</strong>, <strong>pFoo</strong> là tên của con trỏ, và hàm <strong>foo</strong> không có tham số nên phần trong ngoặc mình bỏ trống. Một ví dụ khác, mình có hàm như bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}</code></pre>\n\n<p>Hàm <strong>swapValue</strong> có không có kiểu trả về, và nó nhận vào 2 tham số đều có kiểu tham chiếu <strong>int</strong>. Như vậy, mình có thể khai báo một con trỏ hàm dùng để trỏ đến hàm <strong>swapValue</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void(*pSwap) (int &amp;, int &amp;);</code></pre>\n\n<h5>Gán địa chỉ của hàm cho Function pointers</h5>\n\n<p>Sau khi đã có được con trỏ hàm được khai báo tương ứng với hàm, chúng ta có thể gán địa chỉ của hàm cho chúng:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\tcout &lt;&lt; pSwap &lt;&lt; endl;\n\tcout &lt;&lt; swapValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p><strong>Lưu ý, khi cần lấy địa chỉ của hàm, chúng ta chỉ sử dụng duy nhất tên hàm, không đặt thêm cặp dấu ngoặc vào.</strong></p>\n\n<p>Chỉ có con trỏ được khai báo có kiểu dữ liệu trả về và danh sách tham số phù hợp mới trỏ đến hàm được.</p>\n\n<p></p><pre><code class=\"lang-auto\">// function prototypes\nint foo();\ndouble goo();\nint hoo(int x);\n \n// function pointer assignments\nint (*funcPtr1)() = foo; // okay\nint (*funcPtr2)() = goo; // wrong -- return types don't match!\ndouble (*funcPtr4)() = goo; // okay\nfuncPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does\nint (*funcPtr3)(int) = hoo; // okay</code></pre>\n\n<h5>Sử dụng Function pointers</h5>\n\n<p>Sau khi đã nắm giữ được địa chỉ của hàm, con trỏ hàm có thể được sử dụng như hàm thông qua toán tử <strong>dereference</strong>. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2)\n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\t\n\tint a = 1, b = 5;\n\tcout &lt;&lt; \"Before: \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\t(*pSwap)(a, b);\n\tcout &lt;&lt; \"After:  \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, tham số mặc định của hàm không áp dụng được cho con trỏ hàm, vì tham số mặc định được <strong>compiler</strong> xác định tại thời điểm <strong>compile</strong> chương trình, còn con trỏ hàm được sử dụng tại thời điểm chương trình đang chạy.</p>\n\n<h5>Sử dụng con trỏ hàm làm tham số</h5>\n\n<p>Một con trỏ hàm cũng là một biến con trỏ, do đó chúng ta có thể sử dụng con trỏ hàm là tham số của một hàm nào đó. Khi tham số của hàm là con trỏ hàm, chúng ta sẽ truyền đối số là địa chỉ của một hàm. Hàm được sử dụng làm đối số của hàm có thể gọi là <strong>callback function</strong>.</p>\n\n<p>Mình lấy ví dụ về hàm <strong>selectionSort</strong> dùng để sắp xếp dữ liệu trong mảng số nguyên theo thứ tự tăng dần:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;algorithm&gt; // use for std::swap\n\nvoid selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (arr[minIndex] &gt; arr[i_current])\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}\n\n//................\n\nint main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  1 2 3 4 5 6 7 8 9</code></pre>\n\n<p>Bây giờ đặt ra trường hợp chúng ta muốn có sắp xếp mảng một chiều sử dụng thuật toán <strong>selectionSort</strong> nhưng sắp xếp theo thứ tự giảm dần. Như vậy, chúng ta cần đến 2 hàm <strong>selectionSort</strong> để đáp ứng cho 2 trường hợp mình kể trên. Trong khi cả 2 hàm <strong>selectionSort</strong> này chỉ khác nhau về toán tử so sánh tại phép so sánh ở mệnh đề if trong vòng lặp. </p>\n\n<p>Để giải quyết vấn đề này, đầu tiên mình cần có 2 hàm thực hiện công việc so sánh như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}</code></pre>\n\n<p>Hai hàm này chỉ có tác dụng thay thế phép so sánh trong mệnh đề if. Nếu chúng ta cần sắp xếp giá trị trong mảng theo thứ tự tăng dần, chúng ta sẽ thay thế hàm <strong>ascending</strong> vào mệnh đề if trong hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (ascending(arr[minIndex], arr[i_current])) // replace comparison expression by ascending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, chúng ta vẫn còn cần thêm một hàm <strong>selectionSort</strong> khác và thay thế biểu thức so sánh trong mệnh đề if bằng hàm <strong>descending</strong> để có thể sắp xếp mảng theo chiều giảm dần. Chúng ta cần thiết kế lại hàm <strong>selectionSort</strong> này sao cho người dùng có thể tùy chọn việc sắp xếp theo thứ tự tăng dần hay giảm dần theo từng thời điểm khác nhau. Chúng ta sẽ thêm vào tham số thứ 3 cho hàm <strong>selectionSort</strong> là một con trỏ hàm dùng để trỏ đến hàm <strong>ascending</strong> hoặc <strong>descending</strong> tùy vào lời gọi hàm <strong>selectionSort</strong>. Do hàm <strong>ascending</strong> và <strong>descending</strong> có cấu trúc kiểu trả về và tham số hoàn toàn giống nhau, nên chúng ta có thể sử dụng chung một kiểu con trỏ hàm. Mình định nghĩa con trỏ hàm dùng làm tham số thứ 3 của hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool (*comparisonFunc)(int, int);</code></pre>\n\n<p>Bây giờ, chúng ta sẽ sửa lại hàm <strong>selectionSort</strong> thành phiên bản sử dụng con trỏ hàm:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nvoid selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int))\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, giả sử mình muốn sắp xếp mảng theo thứ tự giảm dần, mình sẽ sử dụng lời gọi hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, descending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Mình sử dụng địa chỉ của hàm <strong>descending</strong> làm đối số cho tham số thứ 3 của hàm <strong>selectionSort</strong>. Như vậy, hàm <strong>descending</strong> sẽ được sử dụng bên trong hàm <strong>selectionSort</strong> và mảng của chúng ta sẽ sắp xếp theo thứ tự giảm dần.</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  9 8 7 6 5 4 3 2 1</code></pre>\n\n<p>Nếu muốn đổi ngược lại thứ tự của mảng khi sắp xếp, chúng ta chỉ cần thay đối số thứ 3 của hàm <strong>selectionSort</strong> là địa chỉ của hàm <strong>ascending</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, ascending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Với việc đặt thêm tham số thứ 3 của hàm <strong>selectionSort</strong> là 1 con trỏ hàm, chúng ta có thể thiết kế thêm nhiều tùy chọn cho điều kiện sắp xếp mảng một chiều khác nhau và vẫn có thể sử dụng cho hàm <strong>selectionSort</strong>. Ví dụ mình muốn thêm một kiểu sắp xếp có điều kiện khác là mọi số chẵn trong mảng sẽ đứng trước, các số lẻ trong mảng sẽ đứng sau, và phần chẵn hay phần lẻ đều được sắp xếp tăng dần, mình sẽ làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool evensFirst(int left, int right)\n{\n\t//if left is even and right is odd, not need to swap\n\tif ((left % 2 == 0) &amp;&amp; (right % 2 != 0))\n\t\treturn false;\n\n\t//if left is odd and right is even, swap this couple\n\tif ((left % 2 != 0) &amp;&amp; (right % 2 == 0))\n\t\treturn true;\n\n\treturn ascending(left, right);\n}</code></pre>\n\n<p>Và mình chỉ cần sử dụng địa chỉ của hàm này làm đối số:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, evensFirst);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  2 4 6 8 1 3 5 7 9</code></pre>\n\n<p>Như các bạn thấy, sử dụng con trỏ hàm trong trường hợp này mang lại cho chúng ta một cách sử dụng hàm sắp xếp hiệu quả hơn.</p>\n\n<h5>Tham số mặc định của tham số con trỏ hàm</h5>\n\n<p>Chúng ta có thể cung cấp cho tham số con trỏ hàm một địa chỉ hàm cụ thể, và hàm đó sẽ được gọi mặc định nếu chúng ta không cung cấp đối số cho tham số con trỏ hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int) = ascending)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Như vậy, lời gọi hàm <strong>selectionSort</strong> với 2 đối số sẽ được mặc định là sắp xếp mảng tăng dần.</p>\n\n<h3>std::function in C++11</h3>\n\n<p>Chuẩn C++11 cung cấp cho chúng ta một cách thay thế cho việc sử dụng con trỏ hàm bằng cách sử dụng kiểu dữ liệu <strong>function</strong> thuộc thư viện <strong>functional</strong>. Thư viện này cũng được định nghĩa trong namespace <strong>std</strong> nên chúng ta cần có dòng lệnh <code>using namespace std;</code> hoặc có thể khai báo là <code>std::function</code>.</p>\n\n<p>Cú pháp khai báo biến kiểu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; &lt;return_type&gt;([list of parameters]) &gt; varName;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; bool(int, int) &gt; comparisonFunc;</code></pre>\n\n<p>Mình lấy ví dụ về việc sử dụng kiểu dữ liệu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nvoid addOne(int &amp;value)\n{\n\tvalue++;\n}\n\nint main()\n{\n\tfunction&lt;void(int &amp;)&gt; func = addOne;\n\t\n\tint number = 5;\n\tfunc(number);\n\n\tcout &lt;&lt; \"New value: \" &lt;&lt; number &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Như các bạn thấy, sử dụng kiểu dữ liệu <code>std::function</code> cũng tương tự như sử dụng con trỏ hàm, chỉ khác nhau về cách khai báo.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Con trỏ hàm (<strong>function pointers</strong>) thường được sử dụng khi chúng ta có các hàm có cùng kiểu trả về và danh sách tham số. Đặt con trỏ hàm làm tham số của hàm cũng là một cách sử dụng con trỏ hàm khá phổ biến. </p>\n\n<p>Vì con trỏ hàm có cú pháp khai báo khó nhớ hơn kiểu <code>std::function</code>, mình khuyến khích các bạn sử dụng kiểu <code>std::function</code> được định nghĩa bên trong thư viện <strong>functional</strong> của chuẩn C++11.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Sửa lại hàm selectionSort phiên bản sử dụng con trỏ hàm làm tham số thứ 3 sao cho phù hợp với cách định nghĩa của 2 hàm so sánh bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &gt; right;\n}</code></pre>\n\n<p>2/ Sử dụng con trỏ hàm để tạo hàm có thể thực hiện 4 phép toán cơ bản (+, -, *, /). Biết rằng, với mỗi phép toán chúng ta có một hàm có kiểu trả về float, mỗi hàm có 2 tham số kiểu float. Sau đó, viết hoàn thiện một chương trình đơn giản cho phép người dùng nhập vào toán tử (+, -, *, /) từ bàn phím và thực hiện phép toán với toán tử tương ứng thông qua hàm mà bạn đã định nghĩa.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","rawBody":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục tìm hiểu về con trỏ trong ngôn ngữ lập trình C++, trong bài học này, mình sẽ giới thiệu đến các bạn một loại con trỏ mới có chức năng khá đặc biệt. </p>\n\n<p>Như chúng ta đã biết, con trỏ có chức năng lưu trữ địa chỉ của một vùng nhớ nào đó trên bộ nhớ ảo. Tuy nhiên, bộ nhớ ảo được chia làm nhiều phân vùng khác nhau.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như trong hình, hầu hết toàn bộ phân vùng của bộ nhớ ảo đều dùng để lưu trữ dữ liệu (biến đơn, giá trị, chuỗi kí tự, ...). Nhưng dữ liệu lưu trên bộ nhớ ảo là cái được tạo ra sau khi chương trình nào đó được thực thi và nó xin cấp phát vùng nhớ trên bộ nhớ ảo để sử dụng. Trước đó, chương trình hoạt động dựa trên các dòng lệnh mà lập trình viên đưa ra sử dụng cú pháp của ngôn ngữ lập trình nào đó. Và trước khi chạy chương trình, mã nguồn (đã được biên dịch thành mã máy) đang lưu trữ trong máy tính (có thể là trên ổ cứng) cũng phải được hệ điều hành load lên RAM và quản lý bằng cách đưa vào bộ nhớ ảo. Vậy mã nguồn của chương trình sẽ lưu ở đâu trên bộ nhớ ảo? Đó là tại phân vùng Text (<strong>Text segment</strong>) hay còn gọi là phân vùng Code (<strong>Code segment</strong>). Tất cả các lệnh, các hàm... của chương trình sẽ được đưa vào phân vùng này, trong đó có cả hàm <strong>main</strong> nếu đó là chương trình C++. Như các bạn đã biết, một chương trình C++ sẽ có duy nhất một hàm <strong>main</strong> đóng vai trò là điểm bắt đầu của chương trình đó. Như vậy, sau khi được load mã nguồn C++ đã được biên dịch lên bộ nhớ ảo, hệ điều hành sẽ tìm đến vị trí (địa chỉ) của hàm <strong>main</strong> và chuyển mã nguồn đến cho CPU xử lý.</p>\n\n<p>Mình có thể cho các bạn xem địa chỉ của hàm <strong>main</strong> của một chương trình C++ ở trên máy mình như hình bên dưới:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/1.png?raw=true\" width=\"579\" height=\"384\"></p>\n\n<p>Như các bạn thấy, hàm <strong>main</strong> (hay bất kỳ hàm nào khác trong chương trình) có một địa chỉ xác định trên bộ nhớ ảo. Do đó, chúng ta có thể sử dụng con trỏ để trỏ đến địa chỉ của hàm <strong>main</strong>. Tuy nhiên, chúng ta cần lưu ý đến kiểu dữ liệu khai báo cho con trỏ phải tương thích với kiểu dữ liệu của vùng nhớ. Ví dụ, con trỏ kiểu <strong>int</strong> dùng để trỏ đến vùng nhớ kiểu <strong>int</strong>, con trỏ trỏ đến hằng (<strong>Pointer to const</strong>) dùng để trỏ đến vùng nhớ hằng... Và để trỏ đến địa chỉ của một hàm, chúng ta cần sử dụng con trỏ hàm (<strong>Function pointer</strong> hoặc có thể gọi là <strong>Pointer to function</strong>).</p>\n\n<h3>Function pointers</h3>\n\n<p>Khi nhìn vào một hàm (function), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể nói hàm này có định danh là <strong>foo</strong>, kiểu trả về là int, hàm foo không nhận đối số. Đó là những gì chúng ta thấy được trong quá trình biên soạn mã nguồn chương trình. Thuộc tính địa chỉ của hàm chỉ được sinh ra khi chương trình đã được chạy.</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo() // code of foo start at memory address 0x01001492\n{\n\treturn 0;\n}\n\nint main()\t\n{\n\tint n = foo();\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Như vậy, khi trong hàm <strong>main</strong> chạy đến dòng lệnh gọi hàm <strong>foo</strong>, hệ điều hành sẽ tìm đến địa chỉ của hàm <strong>foo</strong> trên bộ nhớ ảo và chuyển mã lệnh của hàm <strong>foo</strong> cho CPU tiếp tục xử lý. Để in ra địa chỉ của hàm <strong>foo</strong>, chúng ta có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}\n\nint main()\n{\n\tcout &lt;&lt; foo &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">013D1492</code></pre>\n\n<p>Như các bạn thấy, khi muốn thực thi một hàm, chúng ta cần thêm cặp dấu ngoặc để truyền đối số vào cho hàm (nếu hàm không có tham số thì để trống). Nếu chúng ta không sử dụng cặp dấu ngoặc, sử dụng tên hàm trả về địa chỉ của hàm trên bộ nhớ ảo. Và địa chỉ này có thể được gán con một con trỏ có kiểu dữ liệu tương ứng (<strong>function pointer</strong>).</p>\n\n<h5>Function pointers syntax</h5>\n\n<p>Cú pháp của một con trỏ hàm có nhiều điểm khác biệt so với cách khai báo con trỏ thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">&lt;return_type&gt; (*&lt;name_of_pointer&gt;)( &lt;data_type_of_parameters&gt; );</code></pre>\n\n<p>Mình lấy ví dụ, để trỏ đến hàm foo trong ví dụ trên, chúng ta cần khai báo con trỏ hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int (*pFoo) ();</code></pre>\n\n<p>Trong đó, <strong>int</strong> là kiểu trả về của hàm <strong>foo</strong>, <strong>pFoo</strong> là tên của con trỏ, và hàm <strong>foo</strong> không có tham số nên phần trong ngoặc mình bỏ trống. Một ví dụ khác, mình có hàm như bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}</code></pre>\n\n<p>Hàm <strong>swapValue</strong> có không có kiểu trả về, và nó nhận vào 2 tham số đều có kiểu tham chiếu <strong>int</strong>. Như vậy, mình có thể khai báo một con trỏ hàm dùng để trỏ đến hàm <strong>swapValue</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void(*pSwap) (int &amp;, int &amp;);</code></pre>\n\n<h5>Gán địa chỉ của hàm cho Function pointers</h5>\n\n<p>Sau khi đã có được con trỏ hàm được khai báo tương ứng với hàm, chúng ta có thể gán địa chỉ của hàm cho chúng:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\tcout &lt;&lt; pSwap &lt;&lt; endl;\n\tcout &lt;&lt; swapValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p><strong>Lưu ý, khi cần lấy địa chỉ của hàm, chúng ta chỉ sử dụng duy nhất tên hàm, không đặt thêm cặp dấu ngoặc vào.</strong></p>\n\n<p>Chỉ có con trỏ được khai báo có kiểu dữ liệu trả về và danh sách tham số phù hợp mới trỏ đến hàm được.</p>\n\n<p></p><pre><code class=\"lang-auto\">// function prototypes\nint foo();\ndouble goo();\nint hoo(int x);\n \n// function pointer assignments\nint (*funcPtr1)() = foo; // okay\nint (*funcPtr2)() = goo; // wrong -- return types don't match!\ndouble (*funcPtr4)() = goo; // okay\nfuncPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does\nint (*funcPtr3)(int) = hoo; // okay</code></pre>\n\n<h5>Sử dụng Function pointers</h5>\n\n<p>Sau khi đã nắm giữ được địa chỉ của hàm, con trỏ hàm có thể được sử dụng như hàm thông qua toán tử <strong>dereference</strong>. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2)\n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\t\n\tint a = 1, b = 5;\n\tcout &lt;&lt; \"Before: \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\t(*pSwap)(a, b);\n\tcout &lt;&lt; \"After:  \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, tham số mặc định của hàm không áp dụng được cho con trỏ hàm, vì tham số mặc định được <strong>compiler</strong> xác định tại thời điểm <strong>compile</strong> chương trình, còn con trỏ hàm được sử dụng tại thời điểm chương trình đang chạy.</p>\n\n<h5>Sử dụng con trỏ hàm làm tham số</h5>\n\n<p>Một con trỏ hàm cũng là một biến con trỏ, do đó chúng ta có thể sử dụng con trỏ hàm là tham số của một hàm nào đó. Khi tham số của hàm là con trỏ hàm, chúng ta sẽ truyền đối số là địa chỉ của một hàm. Hàm được sử dụng làm đối số của hàm có thể gọi là <strong>callback function</strong>.</p>\n\n<p>Mình lấy ví dụ về hàm <strong>selectionSort</strong> dùng để sắp xếp dữ liệu trong mảng số nguyên theo thứ tự tăng dần:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;algorithm&gt; // use for std::swap\n\nvoid selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (arr[minIndex] &gt; arr[i_current])\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}\n\n//................\n\nint main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  1 2 3 4 5 6 7 8 9</code></pre>\n\n<p>Bây giờ đặt ra trường hợp chúng ta muốn có sắp xếp mảng một chiều sử dụng thuật toán <strong>selectionSort</strong> nhưng sắp xếp theo thứ tự giảm dần. Như vậy, chúng ta cần đến 2 hàm <strong>selectionSort</strong> để đáp ứng cho 2 trường hợp mình kể trên. Trong khi cả 2 hàm <strong>selectionSort</strong> này chỉ khác nhau về toán tử so sánh tại phép so sánh ở mệnh đề if trong vòng lặp. </p>\n\n<p>Để giải quyết vấn đề này, đầu tiên mình cần có 2 hàm thực hiện công việc so sánh như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}</code></pre>\n\n<p>Hai hàm này chỉ có tác dụng thay thế phép so sánh trong mệnh đề if. Nếu chúng ta cần sắp xếp giá trị trong mảng theo thứ tự tăng dần, chúng ta sẽ thay thế hàm <strong>ascending</strong> vào mệnh đề if trong hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (ascending(arr[minIndex], arr[i_current])) // replace comparison expression by ascending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, chúng ta vẫn còn cần thêm một hàm <strong>selectionSort</strong> khác và thay thế biểu thức so sánh trong mệnh đề if bằng hàm <strong>descending</strong> để có thể sắp xếp mảng theo chiều giảm dần. Chúng ta cần thiết kế lại hàm <strong>selectionSort</strong> này sao cho người dùng có thể tùy chọn việc sắp xếp theo thứ tự tăng dần hay giảm dần theo từng thời điểm khác nhau. Chúng ta sẽ thêm vào tham số thứ 3 cho hàm <strong>selectionSort</strong> là một con trỏ hàm dùng để trỏ đến hàm <strong>ascending</strong> hoặc <strong>descending</strong> tùy vào lời gọi hàm <strong>selectionSort</strong>. Do hàm <strong>ascending</strong> và <strong>descending</strong> có cấu trúc kiểu trả về và tham số hoàn toàn giống nhau, nên chúng ta có thể sử dụng chung một kiểu con trỏ hàm. Mình định nghĩa con trỏ hàm dùng làm tham số thứ 3 của hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool (*comparisonFunc)(int, int);</code></pre>\n\n<p>Bây giờ, chúng ta sẽ sửa lại hàm <strong>selectionSort</strong> thành phiên bản sử dụng con trỏ hàm:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nvoid selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int))\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, giả sử mình muốn sắp xếp mảng theo thứ tự giảm dần, mình sẽ sử dụng lời gọi hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, descending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Mình sử dụng địa chỉ của hàm <strong>descending</strong> làm đối số cho tham số thứ 3 của hàm <strong>selectionSort</strong>. Như vậy, hàm <strong>descending</strong> sẽ được sử dụng bên trong hàm <strong>selectionSort</strong> và mảng của chúng ta sẽ sắp xếp theo thứ tự giảm dần.</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  9 8 7 6 5 4 3 2 1</code></pre>\n\n<p>Nếu muốn đổi ngược lại thứ tự của mảng khi sắp xếp, chúng ta chỉ cần thay đối số thứ 3 của hàm <strong>selectionSort</strong> là địa chỉ của hàm <strong>ascending</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, ascending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Với việc đặt thêm tham số thứ 3 của hàm <strong>selectionSort</strong> là 1 con trỏ hàm, chúng ta có thể thiết kế thêm nhiều tùy chọn cho điều kiện sắp xếp mảng một chiều khác nhau và vẫn có thể sử dụng cho hàm <strong>selectionSort</strong>. Ví dụ mình muốn thêm một kiểu sắp xếp có điều kiện khác là mọi số chẵn trong mảng sẽ đứng trước, các số lẻ trong mảng sẽ đứng sau, và phần chẵn hay phần lẻ đều được sắp xếp tăng dần, mình sẽ làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool evensFirst(int left, int right)\n{\n\t//if left is even and right is odd, not need to swap\n\tif ((left % 2 == 0) &amp;&amp; (right % 2 != 0))\n\t\treturn false;\n\n\t//if left is odd and right is even, swap this couple\n\tif ((left % 2 != 0) &amp;&amp; (right % 2 == 0))\n\t\treturn true;\n\n\treturn ascending(left, right);\n}</code></pre>\n\n<p>Và mình chỉ cần sử dụng địa chỉ của hàm này làm đối số:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, evensFirst);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  2 4 6 8 1 3 5 7 9</code></pre>\n\n<p>Như các bạn thấy, sử dụng con trỏ hàm trong trường hợp này mang lại cho chúng ta một cách sử dụng hàm sắp xếp hiệu quả hơn.</p>\n\n<h5>Tham số mặc định của tham số con trỏ hàm</h5>\n\n<p>Chúng ta có thể cung cấp cho tham số con trỏ hàm một địa chỉ hàm cụ thể, và hàm đó sẽ được gọi mặc định nếu chúng ta không cung cấp đối số cho tham số con trỏ hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int) = ascending)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Như vậy, lời gọi hàm <strong>selectionSort</strong> với 2 đối số sẽ được mặc định là sắp xếp mảng tăng dần.</p>\n\n<h3>std::function in C++11</h3>\n\n<p>Chuẩn C++11 cung cấp cho chúng ta một cách thay thế cho việc sử dụng con trỏ hàm bằng cách sử dụng kiểu dữ liệu <strong>function</strong> thuộc thư viện <strong>functional</strong>. Thư viện này cũng được định nghĩa trong namespace <strong>std</strong> nên chúng ta cần có dòng lệnh <code>using namespace std;</code> hoặc có thể khai báo là <code>std::function</code>.</p>\n\n<p>Cú pháp khai báo biến kiểu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; &lt;return_type&gt;([list of parameters]) &gt; varName;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; bool(int, int) &gt; comparisonFunc;</code></pre>\n\n<p>Mình lấy ví dụ về việc sử dụng kiểu dữ liệu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nvoid addOne(int &amp;value)\n{\n\tvalue++;\n}\n\nint main()\n{\n\tfunction&lt;void(int &amp;)&gt; func = addOne;\n\t\n\tint number = 5;\n\tfunc(number);\n\n\tcout &lt;&lt; \"New value: \" &lt;&lt; number &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Như các bạn thấy, sử dụng kiểu dữ liệu <code>std::function</code> cũng tương tự như sử dụng con trỏ hàm, chỉ khác nhau về cách khai báo.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Con trỏ hàm (<strong>function pointers</strong>) thường được sử dụng khi chúng ta có các hàm có cùng kiểu trả về và danh sách tham số. Đặt con trỏ hàm làm tham số của hàm cũng là một cách sử dụng con trỏ hàm khá phổ biến. </p>\n\n<p>Vì con trỏ hàm có cú pháp khai báo khó nhớ hơn kiểu <code>std::function</code>, mình khuyến khích các bạn sử dụng kiểu <code>std::function</code> được định nghĩa bên trong thư viện <strong>functional</strong> của chuẩn C++11.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Sửa lại hàm selectionSort phiên bản sử dụng con trỏ hàm làm tham số thứ 3 sao cho phù hợp với cách định nghĩa của 2 hàm so sánh bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &gt; right;\n}</code></pre>\n\n<p>2/ Sử dụng con trỏ hàm để tạo hàm có thể thực hiện 4 phép toán cơ bản (+, -, *, /). Biết rằng, với mỗi phép toán chúng ta có một hàm có kiểu trả về float, mỗi hàm có 2 tham số kiểu float. Sau đó, viết hoàn thiện một chương trình đơn giản cho phép người dùng nhập vào toán tử (+, -, *, /) từ bàn phím và thực hiện phép toán với toán tử tương ứng thông qua hàm mà bạn đã định nghĩa.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","raw":"---json\n{\"title\":\"8.9 Con trỏ hàm\",\"route\":\"8/9-con-tr-ham\"}\n---\n\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục tìm hiểu về con trỏ trong ngôn ngữ lập trình C++, trong bài học này, mình sẽ giới thiệu đến các bạn một loại con trỏ mới có chức năng khá đặc biệt. </p>\n\n<p>Như chúng ta đã biết, con trỏ có chức năng lưu trữ địa chỉ của một vùng nhớ nào đó trên bộ nhớ ảo. Tuy nhiên, bộ nhớ ảo được chia làm nhiều phân vùng khác nhau.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như trong hình, hầu hết toàn bộ phân vùng của bộ nhớ ảo đều dùng để lưu trữ dữ liệu (biến đơn, giá trị, chuỗi kí tự, ...). Nhưng dữ liệu lưu trên bộ nhớ ảo là cái được tạo ra sau khi chương trình nào đó được thực thi và nó xin cấp phát vùng nhớ trên bộ nhớ ảo để sử dụng. Trước đó, chương trình hoạt động dựa trên các dòng lệnh mà lập trình viên đưa ra sử dụng cú pháp của ngôn ngữ lập trình nào đó. Và trước khi chạy chương trình, mã nguồn (đã được biên dịch thành mã máy) đang lưu trữ trong máy tính (có thể là trên ổ cứng) cũng phải được hệ điều hành load lên RAM và quản lý bằng cách đưa vào bộ nhớ ảo. Vậy mã nguồn của chương trình sẽ lưu ở đâu trên bộ nhớ ảo? Đó là tại phân vùng Text (<strong>Text segment</strong>) hay còn gọi là phân vùng Code (<strong>Code segment</strong>). Tất cả các lệnh, các hàm... của chương trình sẽ được đưa vào phân vùng này, trong đó có cả hàm <strong>main</strong> nếu đó là chương trình C++. Như các bạn đã biết, một chương trình C++ sẽ có duy nhất một hàm <strong>main</strong> đóng vai trò là điểm bắt đầu của chương trình đó. Như vậy, sau khi được load mã nguồn C++ đã được biên dịch lên bộ nhớ ảo, hệ điều hành sẽ tìm đến vị trí (địa chỉ) của hàm <strong>main</strong> và chuyển mã nguồn đến cho CPU xử lý.</p>\n\n<p>Mình có thể cho các bạn xem địa chỉ của hàm <strong>main</strong> của một chương trình C++ ở trên máy mình như hình bên dưới:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/1.png?raw=true\" width=\"579\" height=\"384\"></p>\n\n<p>Như các bạn thấy, hàm <strong>main</strong> (hay bất kỳ hàm nào khác trong chương trình) có một địa chỉ xác định trên bộ nhớ ảo. Do đó, chúng ta có thể sử dụng con trỏ để trỏ đến địa chỉ của hàm <strong>main</strong>. Tuy nhiên, chúng ta cần lưu ý đến kiểu dữ liệu khai báo cho con trỏ phải tương thích với kiểu dữ liệu của vùng nhớ. Ví dụ, con trỏ kiểu <strong>int</strong> dùng để trỏ đến vùng nhớ kiểu <strong>int</strong>, con trỏ trỏ đến hằng (<strong>Pointer to const</strong>) dùng để trỏ đến vùng nhớ hằng... Và để trỏ đến địa chỉ của một hàm, chúng ta cần sử dụng con trỏ hàm (<strong>Function pointer</strong> hoặc có thể gọi là <strong>Pointer to function</strong>).</p>\n\n<h3>Function pointers</h3>\n\n<p>Khi nhìn vào một hàm (function), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể nói hàm này có định danh là <strong>foo</strong>, kiểu trả về là int, hàm foo không nhận đối số. Đó là những gì chúng ta thấy được trong quá trình biên soạn mã nguồn chương trình. Thuộc tính địa chỉ của hàm chỉ được sinh ra khi chương trình đã được chạy.</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo() // code of foo start at memory address 0x01001492\n{\n\treturn 0;\n}\n\nint main()\t\n{\n\tint n = foo();\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Như vậy, khi trong hàm <strong>main</strong> chạy đến dòng lệnh gọi hàm <strong>foo</strong>, hệ điều hành sẽ tìm đến địa chỉ của hàm <strong>foo</strong> trên bộ nhớ ảo và chuyển mã lệnh của hàm <strong>foo</strong> cho CPU tiếp tục xử lý. Để in ra địa chỉ của hàm <strong>foo</strong>, chúng ta có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}\n\nint main()\n{\n\tcout &lt;&lt; foo &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">013D1492</code></pre>\n\n<p>Như các bạn thấy, khi muốn thực thi một hàm, chúng ta cần thêm cặp dấu ngoặc để truyền đối số vào cho hàm (nếu hàm không có tham số thì để trống). Nếu chúng ta không sử dụng cặp dấu ngoặc, sử dụng tên hàm trả về địa chỉ của hàm trên bộ nhớ ảo. Và địa chỉ này có thể được gán con một con trỏ có kiểu dữ liệu tương ứng (<strong>function pointer</strong>).</p>\n\n<h5>Function pointers syntax</h5>\n\n<p>Cú pháp của một con trỏ hàm có nhiều điểm khác biệt so với cách khai báo con trỏ thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">&lt;return_type&gt; (*&lt;name_of_pointer&gt;)( &lt;data_type_of_parameters&gt; );</code></pre>\n\n<p>Mình lấy ví dụ, để trỏ đến hàm foo trong ví dụ trên, chúng ta cần khai báo con trỏ hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int (*pFoo) ();</code></pre>\n\n<p>Trong đó, <strong>int</strong> là kiểu trả về của hàm <strong>foo</strong>, <strong>pFoo</strong> là tên của con trỏ, và hàm <strong>foo</strong> không có tham số nên phần trong ngoặc mình bỏ trống. Một ví dụ khác, mình có hàm như bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}</code></pre>\n\n<p>Hàm <strong>swapValue</strong> có không có kiểu trả về, và nó nhận vào 2 tham số đều có kiểu tham chiếu <strong>int</strong>. Như vậy, mình có thể khai báo một con trỏ hàm dùng để trỏ đến hàm <strong>swapValue</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void(*pSwap) (int &amp;, int &amp;);</code></pre>\n\n<h5>Gán địa chỉ của hàm cho Function pointers</h5>\n\n<p>Sau khi đã có được con trỏ hàm được khai báo tương ứng với hàm, chúng ta có thể gán địa chỉ của hàm cho chúng:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\tcout &lt;&lt; pSwap &lt;&lt; endl;\n\tcout &lt;&lt; swapValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p><strong>Lưu ý, khi cần lấy địa chỉ của hàm, chúng ta chỉ sử dụng duy nhất tên hàm, không đặt thêm cặp dấu ngoặc vào.</strong></p>\n\n<p>Chỉ có con trỏ được khai báo có kiểu dữ liệu trả về và danh sách tham số phù hợp mới trỏ đến hàm được.</p>\n\n<p></p><pre><code class=\"lang-auto\">// function prototypes\nint foo();\ndouble goo();\nint hoo(int x);\n \n// function pointer assignments\nint (*funcPtr1)() = foo; // okay\nint (*funcPtr2)() = goo; // wrong -- return types don't match!\ndouble (*funcPtr4)() = goo; // okay\nfuncPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does\nint (*funcPtr3)(int) = hoo; // okay</code></pre>\n\n<h5>Sử dụng Function pointers</h5>\n\n<p>Sau khi đã nắm giữ được địa chỉ của hàm, con trỏ hàm có thể được sử dụng như hàm thông qua toán tử <strong>dereference</strong>. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2)\n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\t\n\tint a = 1, b = 5;\n\tcout &lt;&lt; \"Before: \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\t(*pSwap)(a, b);\n\tcout &lt;&lt; \"After:  \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, tham số mặc định của hàm không áp dụng được cho con trỏ hàm, vì tham số mặc định được <strong>compiler</strong> xác định tại thời điểm <strong>compile</strong> chương trình, còn con trỏ hàm được sử dụng tại thời điểm chương trình đang chạy.</p>\n\n<h5>Sử dụng con trỏ hàm làm tham số</h5>\n\n<p>Một con trỏ hàm cũng là một biến con trỏ, do đó chúng ta có thể sử dụng con trỏ hàm là tham số của một hàm nào đó. Khi tham số của hàm là con trỏ hàm, chúng ta sẽ truyền đối số là địa chỉ của một hàm. Hàm được sử dụng làm đối số của hàm có thể gọi là <strong>callback function</strong>.</p>\n\n<p>Mình lấy ví dụ về hàm <strong>selectionSort</strong> dùng để sắp xếp dữ liệu trong mảng số nguyên theo thứ tự tăng dần:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;algorithm&gt; // use for std::swap\n\nvoid selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (arr[minIndex] &gt; arr[i_current])\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}\n\n//................\n\nint main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  1 2 3 4 5 6 7 8 9</code></pre>\n\n<p>Bây giờ đặt ra trường hợp chúng ta muốn có sắp xếp mảng một chiều sử dụng thuật toán <strong>selectionSort</strong> nhưng sắp xếp theo thứ tự giảm dần. Như vậy, chúng ta cần đến 2 hàm <strong>selectionSort</strong> để đáp ứng cho 2 trường hợp mình kể trên. Trong khi cả 2 hàm <strong>selectionSort</strong> này chỉ khác nhau về toán tử so sánh tại phép so sánh ở mệnh đề if trong vòng lặp. </p>\n\n<p>Để giải quyết vấn đề này, đầu tiên mình cần có 2 hàm thực hiện công việc so sánh như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}</code></pre>\n\n<p>Hai hàm này chỉ có tác dụng thay thế phép so sánh trong mệnh đề if. Nếu chúng ta cần sắp xếp giá trị trong mảng theo thứ tự tăng dần, chúng ta sẽ thay thế hàm <strong>ascending</strong> vào mệnh đề if trong hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (ascending(arr[minIndex], arr[i_current])) // replace comparison expression by ascending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, chúng ta vẫn còn cần thêm một hàm <strong>selectionSort</strong> khác và thay thế biểu thức so sánh trong mệnh đề if bằng hàm <strong>descending</strong> để có thể sắp xếp mảng theo chiều giảm dần. Chúng ta cần thiết kế lại hàm <strong>selectionSort</strong> này sao cho người dùng có thể tùy chọn việc sắp xếp theo thứ tự tăng dần hay giảm dần theo từng thời điểm khác nhau. Chúng ta sẽ thêm vào tham số thứ 3 cho hàm <strong>selectionSort</strong> là một con trỏ hàm dùng để trỏ đến hàm <strong>ascending</strong> hoặc <strong>descending</strong> tùy vào lời gọi hàm <strong>selectionSort</strong>. Do hàm <strong>ascending</strong> và <strong>descending</strong> có cấu trúc kiểu trả về và tham số hoàn toàn giống nhau, nên chúng ta có thể sử dụng chung một kiểu con trỏ hàm. Mình định nghĩa con trỏ hàm dùng làm tham số thứ 3 của hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool (*comparisonFunc)(int, int);</code></pre>\n\n<p>Bây giờ, chúng ta sẽ sửa lại hàm <strong>selectionSort</strong> thành phiên bản sử dụng con trỏ hàm:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nvoid selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int))\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, giả sử mình muốn sắp xếp mảng theo thứ tự giảm dần, mình sẽ sử dụng lời gọi hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, descending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Mình sử dụng địa chỉ của hàm <strong>descending</strong> làm đối số cho tham số thứ 3 của hàm <strong>selectionSort</strong>. Như vậy, hàm <strong>descending</strong> sẽ được sử dụng bên trong hàm <strong>selectionSort</strong> và mảng của chúng ta sẽ sắp xếp theo thứ tự giảm dần.</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  9 8 7 6 5 4 3 2 1</code></pre>\n\n<p>Nếu muốn đổi ngược lại thứ tự của mảng khi sắp xếp, chúng ta chỉ cần thay đối số thứ 3 của hàm <strong>selectionSort</strong> là địa chỉ của hàm <strong>ascending</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, ascending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Với việc đặt thêm tham số thứ 3 của hàm <strong>selectionSort</strong> là 1 con trỏ hàm, chúng ta có thể thiết kế thêm nhiều tùy chọn cho điều kiện sắp xếp mảng một chiều khác nhau và vẫn có thể sử dụng cho hàm <strong>selectionSort</strong>. Ví dụ mình muốn thêm một kiểu sắp xếp có điều kiện khác là mọi số chẵn trong mảng sẽ đứng trước, các số lẻ trong mảng sẽ đứng sau, và phần chẵn hay phần lẻ đều được sắp xếp tăng dần, mình sẽ làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool evensFirst(int left, int right)\n{\n\t//if left is even and right is odd, not need to swap\n\tif ((left % 2 == 0) &amp;&amp; (right % 2 != 0))\n\t\treturn false;\n\n\t//if left is odd and right is even, swap this couple\n\tif ((left % 2 != 0) &amp;&amp; (right % 2 == 0))\n\t\treturn true;\n\n\treturn ascending(left, right);\n}</code></pre>\n\n<p>Và mình chỉ cần sử dụng địa chỉ của hàm này làm đối số:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, evensFirst);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  2 4 6 8 1 3 5 7 9</code></pre>\n\n<p>Như các bạn thấy, sử dụng con trỏ hàm trong trường hợp này mang lại cho chúng ta một cách sử dụng hàm sắp xếp hiệu quả hơn.</p>\n\n<h5>Tham số mặc định của tham số con trỏ hàm</h5>\n\n<p>Chúng ta có thể cung cấp cho tham số con trỏ hàm một địa chỉ hàm cụ thể, và hàm đó sẽ được gọi mặc định nếu chúng ta không cung cấp đối số cho tham số con trỏ hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int) = ascending)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Như vậy, lời gọi hàm <strong>selectionSort</strong> với 2 đối số sẽ được mặc định là sắp xếp mảng tăng dần.</p>\n\n<h3>std::function in C++11</h3>\n\n<p>Chuẩn C++11 cung cấp cho chúng ta một cách thay thế cho việc sử dụng con trỏ hàm bằng cách sử dụng kiểu dữ liệu <strong>function</strong> thuộc thư viện <strong>functional</strong>. Thư viện này cũng được định nghĩa trong namespace <strong>std</strong> nên chúng ta cần có dòng lệnh <code>using namespace std;</code> hoặc có thể khai báo là <code>std::function</code>.</p>\n\n<p>Cú pháp khai báo biến kiểu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; &lt;return_type&gt;([list of parameters]) &gt; varName;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; bool(int, int) &gt; comparisonFunc;</code></pre>\n\n<p>Mình lấy ví dụ về việc sử dụng kiểu dữ liệu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nvoid addOne(int &amp;value)\n{\n\tvalue++;\n}\n\nint main()\n{\n\tfunction&lt;void(int &amp;)&gt; func = addOne;\n\t\n\tint number = 5;\n\tfunc(number);\n\n\tcout &lt;&lt; \"New value: \" &lt;&lt; number &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Như các bạn thấy, sử dụng kiểu dữ liệu <code>std::function</code> cũng tương tự như sử dụng con trỏ hàm, chỉ khác nhau về cách khai báo.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Con trỏ hàm (<strong>function pointers</strong>) thường được sử dụng khi chúng ta có các hàm có cùng kiểu trả về và danh sách tham số. Đặt con trỏ hàm làm tham số của hàm cũng là một cách sử dụng con trỏ hàm khá phổ biến. </p>\n\n<p>Vì con trỏ hàm có cú pháp khai báo khó nhớ hơn kiểu <code>std::function</code>, mình khuyến khích các bạn sử dụng kiểu <code>std::function</code> được định nghĩa bên trong thư viện <strong>functional</strong> của chuẩn C++11.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Sửa lại hàm selectionSort phiên bản sử dụng con trỏ hàm làm tham số thứ 3 sao cho phù hợp với cách định nghĩa của 2 hàm so sánh bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &gt; right;\n}</code></pre>\n\n<p>2/ Sử dụng con trỏ hàm để tạo hàm có thể thực hiện 4 phép toán cơ bản (+, -, *, /). Biết rằng, với mỗi phép toán chúng ta có một hàm có kiểu trả về float, mỗi hàm có 2 tham số kiểu float. Sau đó, viết hoàn thiện một chương trình đơn giản cho phép người dùng nhập vào toán tử (+, -, *, /) từ bàn phím và thực hiện phép toán với toán tử tương ứng thông qua hàm mà bạn đã định nghĩa.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.bc2b8ac23d5e828477e2e837d3519fd7.json"}}}</script><script src="/dnh-cpp/phenomic.browser.e6384768077a0a2f9d14.js"></script></body></html>