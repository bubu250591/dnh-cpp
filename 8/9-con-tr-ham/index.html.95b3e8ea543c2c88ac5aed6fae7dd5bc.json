{"head":{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","id":31959,"description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue…"},"body":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục tìm hiểu về con trỏ trong ngôn ngữ lập trình C++, trong bài học này, mình sẽ giới thiệu đến các bạn một loại con trỏ mới có chức năng khá đặc biệt. </p>\n\n<p>Như chúng ta đã biết, con trỏ có chức năng lưu trữ địa chỉ của một vùng nhớ nào đó trên bộ nhớ ảo. Tuy nhiên, bộ nhớ ảo được chia làm nhiều phân vùng khác nhau.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như trong hình, hầu hết toàn bộ phân vùng của bộ nhớ ảo đều dùng để lưu trữ dữ liệu (biến đơn, giá trị, chuỗi kí tự, ...). Nhưng dữ liệu lưu trên bộ nhớ ảo là cái được tạo ra sau khi chương trình nào đó được thực thi và nó xin cấp phát vùng nhớ trên bộ nhớ ảo để sử dụng. Trước đó, chương trình hoạt động dựa trên các dòng lệnh mà lập trình viên đưa ra sử dụng cú pháp của ngôn ngữ lập trình nào đó. Và trước khi chạy chương trình, mã nguồn (đã được biên dịch thành mã máy) đang lưu trữ trong máy tính (có thể là trên ổ cứng) cũng phải được hệ điều hành load lên RAM và quản lý bằng cách đưa vào bộ nhớ ảo. Vậy mã nguồn của chương trình sẽ lưu ở đâu trên bộ nhớ ảo? Đó là tại phân vùng Text (<strong>Text segment</strong>) hay còn gọi là phân vùng Code (<strong>Code segment</strong>). Tất cả các lệnh, các hàm... của chương trình sẽ được đưa vào phân vùng này, trong đó có cả hàm <strong>main</strong> nếu đó là chương trình C++. Như các bạn đã biết, một chương trình C++ sẽ có duy nhất một hàm <strong>main</strong> đóng vai trò là điểm bắt đầu của chương trình đó. Như vậy, sau khi được load mã nguồn C++ đã được biên dịch lên bộ nhớ ảo, hệ điều hành sẽ tìm đến vị trí (địa chỉ) của hàm <strong>main</strong> và chuyển mã nguồn đến cho CPU xử lý.</p>\n\n<p>Mình có thể cho các bạn xem địa chỉ của hàm <strong>main</strong> của một chương trình C++ ở trên máy mình như hình bên dưới:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/1.png?raw=true\" width=\"579\" height=\"384\"></p>\n\n<p>Như các bạn thấy, hàm <strong>main</strong> (hay bất kỳ hàm nào khác trong chương trình) có một địa chỉ xác định trên bộ nhớ ảo. Do đó, chúng ta có thể sử dụng con trỏ để trỏ đến địa chỉ của hàm <strong>main</strong>. Tuy nhiên, chúng ta cần lưu ý đến kiểu dữ liệu khai báo cho con trỏ phải tương thích với kiểu dữ liệu của vùng nhớ. Ví dụ, con trỏ kiểu <strong>int</strong> dùng để trỏ đến vùng nhớ kiểu <strong>int</strong>, con trỏ trỏ đến hằng (<strong>Pointer to const</strong>) dùng để trỏ đến vùng nhớ hằng... Và để trỏ đến địa chỉ của một hàm, chúng ta cần sử dụng con trỏ hàm (<strong>Function pointer</strong> hoặc có thể gọi là <strong>Pointer to function</strong>).</p>\n\n<h3>Function pointers</h3>\n\n<p>Khi nhìn vào một hàm (function), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể nói hàm này có định danh là <strong>foo</strong>, kiểu trả về là int, hàm foo không nhận đối số. Đó là những gì chúng ta thấy được trong quá trình biên soạn mã nguồn chương trình. Thuộc tính địa chỉ của hàm chỉ được sinh ra khi chương trình đã được chạy.</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo() // code of foo start at memory address 0x01001492\n{\n\treturn 0;\n}\n\nint main()\t\n{\n\tint n = foo();\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Như vậy, khi trong hàm <strong>main</strong> chạy đến dòng lệnh gọi hàm <strong>foo</strong>, hệ điều hành sẽ tìm đến địa chỉ của hàm <strong>foo</strong> trên bộ nhớ ảo và chuyển mã lệnh của hàm <strong>foo</strong> cho CPU tiếp tục xử lý. Để in ra địa chỉ của hàm <strong>foo</strong>, chúng ta có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}\n\nint main()\n{\n\tcout &lt;&lt; foo &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">013D1492</code></pre>\n\n<p>Như các bạn thấy, khi muốn thực thi một hàm, chúng ta cần thêm cặp dấu ngoặc để truyền đối số vào cho hàm (nếu hàm không có tham số thì để trống). Nếu chúng ta không sử dụng cặp dấu ngoặc, sử dụng tên hàm trả về địa chỉ của hàm trên bộ nhớ ảo. Và địa chỉ này có thể được gán con một con trỏ có kiểu dữ liệu tương ứng (<strong>function pointer</strong>).</p>\n\n<h5>Function pointers syntax</h5>\n\n<p>Cú pháp của một con trỏ hàm có nhiều điểm khác biệt so với cách khai báo con trỏ thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">&lt;return_type&gt; (*&lt;name_of_pointer&gt;)( &lt;data_type_of_parameters&gt; );</code></pre>\n\n<p>Mình lấy ví dụ, để trỏ đến hàm foo trong ví dụ trên, chúng ta cần khai báo con trỏ hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int (*pFoo) ();</code></pre>\n\n<p>Trong đó, <strong>int</strong> là kiểu trả về của hàm <strong>foo</strong>, <strong>pFoo</strong> là tên của con trỏ, và hàm <strong>foo</strong> không có tham số nên phần trong ngoặc mình bỏ trống. Một ví dụ khác, mình có hàm như bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}</code></pre>\n\n<p>Hàm <strong>swapValue</strong> có không có kiểu trả về, và nó nhận vào 2 tham số đều có kiểu tham chiếu <strong>int</strong>. Như vậy, mình có thể khai báo một con trỏ hàm dùng để trỏ đến hàm <strong>swapValue</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void(*pSwap) (int &amp;, int &amp;);</code></pre>\n\n<h5>Gán địa chỉ của hàm cho Function pointers</h5>\n\n<p>Sau khi đã có được con trỏ hàm được khai báo tương ứng với hàm, chúng ta có thể gán địa chỉ của hàm cho chúng:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\tcout &lt;&lt; pSwap &lt;&lt; endl;\n\tcout &lt;&lt; swapValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p><strong>Lưu ý, khi cần lấy địa chỉ của hàm, chúng ta chỉ sử dụng duy nhất tên hàm, không đặt thêm cặp dấu ngoặc vào.</strong></p>\n\n<p>Chỉ có con trỏ được khai báo có kiểu dữ liệu trả về và danh sách tham số phù hợp mới trỏ đến hàm được.</p>\n\n<p></p><pre><code class=\"lang-auto\">// function prototypes\nint foo();\ndouble goo();\nint hoo(int x);\n \n// function pointer assignments\nint (*funcPtr1)() = foo; // okay\nint (*funcPtr2)() = goo; // wrong -- return types don't match!\ndouble (*funcPtr4)() = goo; // okay\nfuncPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does\nint (*funcPtr3)(int) = hoo; // okay</code></pre>\n\n<h5>Sử dụng Function pointers</h5>\n\n<p>Sau khi đã nắm giữ được địa chỉ của hàm, con trỏ hàm có thể được sử dụng như hàm thông qua toán tử <strong>dereference</strong>. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2)\n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\t\n\tint a = 1, b = 5;\n\tcout &lt;&lt; \"Before: \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\t(*pSwap)(a, b);\n\tcout &lt;&lt; \"After:  \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, tham số mặc định của hàm không áp dụng được cho con trỏ hàm, vì tham số mặc định được <strong>compiler</strong> xác định tại thời điểm <strong>compile</strong> chương trình, còn con trỏ hàm được sử dụng tại thời điểm chương trình đang chạy.</p>\n\n<h5>Sử dụng con trỏ hàm làm tham số</h5>\n\n<p>Một con trỏ hàm cũng là một biến con trỏ, do đó chúng ta có thể sử dụng con trỏ hàm là tham số của một hàm nào đó. Khi tham số của hàm là con trỏ hàm, chúng ta sẽ truyền đối số là địa chỉ của một hàm. Hàm được sử dụng làm đối số của hàm có thể gọi là <strong>callback function</strong>.</p>\n\n<p>Mình lấy ví dụ về hàm <strong>selectionSort</strong> dùng để sắp xếp dữ liệu trong mảng số nguyên theo thứ tự tăng dần:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;algorithm&gt; // use for std::swap\n\nvoid selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (arr[minIndex] &gt; arr[i_current])\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}\n\n//................\n\nint main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  1 2 3 4 5 6 7 8 9</code></pre>\n\n<p>Bây giờ đặt ra trường hợp chúng ta muốn có sắp xếp mảng một chiều sử dụng thuật toán <strong>selectionSort</strong> nhưng sắp xếp theo thứ tự giảm dần. Như vậy, chúng ta cần đến 2 hàm <strong>selectionSort</strong> để đáp ứng cho 2 trường hợp mình kể trên. Trong khi cả 2 hàm <strong>selectionSort</strong> này chỉ khác nhau về toán tử so sánh tại phép so sánh ở mệnh đề if trong vòng lặp. </p>\n\n<p>Để giải quyết vấn đề này, đầu tiên mình cần có 2 hàm thực hiện công việc so sánh như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}</code></pre>\n\n<p>Hai hàm này chỉ có tác dụng thay thế phép so sánh trong mệnh đề if. Nếu chúng ta cần sắp xếp giá trị trong mảng theo thứ tự tăng dần, chúng ta sẽ thay thế hàm <strong>ascending</strong> vào mệnh đề if trong hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (ascending(arr[minIndex], arr[i_current])) // replace comparison expression by ascending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, chúng ta vẫn còn cần thêm một hàm <strong>selectionSort</strong> khác và thay thế biểu thức so sánh trong mệnh đề if bằng hàm <strong>descending</strong> để có thể sắp xếp mảng theo chiều giảm dần. Chúng ta cần thiết kế lại hàm <strong>selectionSort</strong> này sao cho người dùng có thể tùy chọn việc sắp xếp theo thứ tự tăng dần hay giảm dần theo từng thời điểm khác nhau. Chúng ta sẽ thêm vào tham số thứ 3 cho hàm <strong>selectionSort</strong> là một con trỏ hàm dùng để trỏ đến hàm <strong>ascending</strong> hoặc <strong>descending</strong> tùy vào lời gọi hàm <strong>selectionSort</strong>. Do hàm <strong>ascending</strong> và <strong>descending</strong> có cấu trúc kiểu trả về và tham số hoàn toàn giống nhau, nên chúng ta có thể sử dụng chung một kiểu con trỏ hàm. Mình định nghĩa con trỏ hàm dùng làm tham số thứ 3 của hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool (*comparisonFunc)(int, int);</code></pre>\n\n<p>Bây giờ, chúng ta sẽ sửa lại hàm <strong>selectionSort</strong> thành phiên bản sử dụng con trỏ hàm:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nvoid selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int))\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, giả sử mình muốn sắp xếp mảng theo thứ tự giảm dần, mình sẽ sử dụng lời gọi hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, descending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Mình sử dụng địa chỉ của hàm <strong>descending</strong> làm đối số cho tham số thứ 3 của hàm <strong>selectionSort</strong>. Như vậy, hàm <strong>descending</strong> sẽ được sử dụng bên trong hàm <strong>selectionSort</strong> và mảng của chúng ta sẽ sắp xếp theo thứ tự giảm dần.</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  9 8 7 6 5 4 3 2 1</code></pre>\n\n<p>Nếu muốn đổi ngược lại thứ tự của mảng khi sắp xếp, chúng ta chỉ cần thay đối số thứ 3 của hàm <strong>selectionSort</strong> là địa chỉ của hàm <strong>ascending</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, ascending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Với việc đặt thêm tham số thứ 3 của hàm <strong>selectionSort</strong> là 1 con trỏ hàm, chúng ta có thể thiết kế thêm nhiều tùy chọn cho điều kiện sắp xếp mảng một chiều khác nhau và vẫn có thể sử dụng cho hàm <strong>selectionSort</strong>. Ví dụ mình muốn thêm một kiểu sắp xếp có điều kiện khác là mọi số chẵn trong mảng sẽ đứng trước, các số lẻ trong mảng sẽ đứng sau, và phần chẵn hay phần lẻ đều được sắp xếp tăng dần, mình sẽ làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool evensFirst(int left, int right)\n{\n\t//if left is even and right is odd, not need to swap\n\tif ((left % 2 == 0) &amp;&amp; (right % 2 != 0))\n\t\treturn false;\n\n\t//if left is odd and right is even, swap this couple\n\tif ((left % 2 != 0) &amp;&amp; (right % 2 == 0))\n\t\treturn true;\n\n\treturn ascending(left, right);\n}</code></pre>\n\n<p>Và mình chỉ cần sử dụng địa chỉ của hàm này làm đối số:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, evensFirst);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  2 4 6 8 1 3 5 7 9</code></pre>\n\n<p>Như các bạn thấy, sử dụng con trỏ hàm trong trường hợp này mang lại cho chúng ta một cách sử dụng hàm sắp xếp hiệu quả hơn.</p>\n\n<h5>Tham số mặc định của tham số con trỏ hàm</h5>\n\n<p>Chúng ta có thể cung cấp cho tham số con trỏ hàm một địa chỉ hàm cụ thể, và hàm đó sẽ được gọi mặc định nếu chúng ta không cung cấp đối số cho tham số con trỏ hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int) = ascending)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Như vậy, lời gọi hàm <strong>selectionSort</strong> với 2 đối số sẽ được mặc định là sắp xếp mảng tăng dần.</p>\n\n<h3>std::function in C++11</h3>\n\n<p>Chuẩn C++11 cung cấp cho chúng ta một cách thay thế cho việc sử dụng con trỏ hàm bằng cách sử dụng kiểu dữ liệu <strong>function</strong> thuộc thư viện <strong>functional</strong>. Thư viện này cũng được định nghĩa trong namespace <strong>std</strong> nên chúng ta cần có dòng lệnh <code>using namespace std;</code> hoặc có thể khai báo là <code>std::function</code>.</p>\n\n<p>Cú pháp khai báo biến kiểu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; &lt;return_type&gt;([list of parameters]) &gt; varName;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; bool(int, int) &gt; comparisonFunc;</code></pre>\n\n<p>Mình lấy ví dụ về việc sử dụng kiểu dữ liệu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nvoid addOne(int &amp;value)\n{\n\tvalue++;\n}\n\nint main()\n{\n\tfunction&lt;void(int &amp;)&gt; func = addOne;\n\t\n\tint number = 5;\n\tfunc(number);\n\n\tcout &lt;&lt; \"New value: \" &lt;&lt; number &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Như các bạn thấy, sử dụng kiểu dữ liệu <code>std::function</code> cũng tương tự như sử dụng con trỏ hàm, chỉ khác nhau về cách khai báo.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Con trỏ hàm (<strong>function pointers</strong>) thường được sử dụng khi chúng ta có các hàm có cùng kiểu trả về và danh sách tham số. Đặt con trỏ hàm làm tham số của hàm cũng là một cách sử dụng con trỏ hàm khá phổ biến. </p>\n\n<p>Vì con trỏ hàm có cú pháp khai báo khó nhớ hơn kiểu <code>std::function</code>, mình khuyến khích các bạn sử dụng kiểu <code>std::function</code> được định nghĩa bên trong thư viện <strong>functional</strong> của chuẩn C++11.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Sửa lại hàm selectionSort phiên bản sử dụng con trỏ hàm làm tham số thứ 3 sao cho phù hợp với cách định nghĩa của 2 hàm so sánh bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &gt; right;\n}</code></pre>\n\n<p>2/ Sử dụng con trỏ hàm để tạo hàm có thể thực hiện 4 phép toán cơ bản (+, -, *, /). Biết rằng, với mỗi phép toán chúng ta có một hàm có kiểu trả về float, mỗi hàm có 2 tham số kiểu float. Sau đó, viết hoàn thiện một chương trình đơn giản cho phép người dùng nhập vào toán tử (+, -, *, /) từ bàn phím và thực hiện phép toán với toán tử tương ứng thông qua hàm mà bạn đã định nghĩa.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","rawBody":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục tìm hiểu về con trỏ trong ngôn ngữ lập trình C++, trong bài học này, mình sẽ giới thiệu đến các bạn một loại con trỏ mới có chức năng khá đặc biệt. </p>\n\n<p>Như chúng ta đã biết, con trỏ có chức năng lưu trữ địa chỉ của một vùng nhớ nào đó trên bộ nhớ ảo. Tuy nhiên, bộ nhớ ảo được chia làm nhiều phân vùng khác nhau.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như trong hình, hầu hết toàn bộ phân vùng của bộ nhớ ảo đều dùng để lưu trữ dữ liệu (biến đơn, giá trị, chuỗi kí tự, ...). Nhưng dữ liệu lưu trên bộ nhớ ảo là cái được tạo ra sau khi chương trình nào đó được thực thi và nó xin cấp phát vùng nhớ trên bộ nhớ ảo để sử dụng. Trước đó, chương trình hoạt động dựa trên các dòng lệnh mà lập trình viên đưa ra sử dụng cú pháp của ngôn ngữ lập trình nào đó. Và trước khi chạy chương trình, mã nguồn (đã được biên dịch thành mã máy) đang lưu trữ trong máy tính (có thể là trên ổ cứng) cũng phải được hệ điều hành load lên RAM và quản lý bằng cách đưa vào bộ nhớ ảo. Vậy mã nguồn của chương trình sẽ lưu ở đâu trên bộ nhớ ảo? Đó là tại phân vùng Text (<strong>Text segment</strong>) hay còn gọi là phân vùng Code (<strong>Code segment</strong>). Tất cả các lệnh, các hàm... của chương trình sẽ được đưa vào phân vùng này, trong đó có cả hàm <strong>main</strong> nếu đó là chương trình C++. Như các bạn đã biết, một chương trình C++ sẽ có duy nhất một hàm <strong>main</strong> đóng vai trò là điểm bắt đầu của chương trình đó. Như vậy, sau khi được load mã nguồn C++ đã được biên dịch lên bộ nhớ ảo, hệ điều hành sẽ tìm đến vị trí (địa chỉ) của hàm <strong>main</strong> và chuyển mã nguồn đến cho CPU xử lý.</p>\n\n<p>Mình có thể cho các bạn xem địa chỉ của hàm <strong>main</strong> của một chương trình C++ ở trên máy mình như hình bên dưới:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/1.png?raw=true\" width=\"579\" height=\"384\"></p>\n\n<p>Như các bạn thấy, hàm <strong>main</strong> (hay bất kỳ hàm nào khác trong chương trình) có một địa chỉ xác định trên bộ nhớ ảo. Do đó, chúng ta có thể sử dụng con trỏ để trỏ đến địa chỉ của hàm <strong>main</strong>. Tuy nhiên, chúng ta cần lưu ý đến kiểu dữ liệu khai báo cho con trỏ phải tương thích với kiểu dữ liệu của vùng nhớ. Ví dụ, con trỏ kiểu <strong>int</strong> dùng để trỏ đến vùng nhớ kiểu <strong>int</strong>, con trỏ trỏ đến hằng (<strong>Pointer to const</strong>) dùng để trỏ đến vùng nhớ hằng... Và để trỏ đến địa chỉ của một hàm, chúng ta cần sử dụng con trỏ hàm (<strong>Function pointer</strong> hoặc có thể gọi là <strong>Pointer to function</strong>).</p>\n\n<h3>Function pointers</h3>\n\n<p>Khi nhìn vào một hàm (function), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể nói hàm này có định danh là <strong>foo</strong>, kiểu trả về là int, hàm foo không nhận đối số. Đó là những gì chúng ta thấy được trong quá trình biên soạn mã nguồn chương trình. Thuộc tính địa chỉ của hàm chỉ được sinh ra khi chương trình đã được chạy.</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo() // code of foo start at memory address 0x01001492\n{\n\treturn 0;\n}\n\nint main()\t\n{\n\tint n = foo();\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Như vậy, khi trong hàm <strong>main</strong> chạy đến dòng lệnh gọi hàm <strong>foo</strong>, hệ điều hành sẽ tìm đến địa chỉ của hàm <strong>foo</strong> trên bộ nhớ ảo và chuyển mã lệnh của hàm <strong>foo</strong> cho CPU tiếp tục xử lý. Để in ra địa chỉ của hàm <strong>foo</strong>, chúng ta có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}\n\nint main()\n{\n\tcout &lt;&lt; foo &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">013D1492</code></pre>\n\n<p>Như các bạn thấy, khi muốn thực thi một hàm, chúng ta cần thêm cặp dấu ngoặc để truyền đối số vào cho hàm (nếu hàm không có tham số thì để trống). Nếu chúng ta không sử dụng cặp dấu ngoặc, sử dụng tên hàm trả về địa chỉ của hàm trên bộ nhớ ảo. Và địa chỉ này có thể được gán con một con trỏ có kiểu dữ liệu tương ứng (<strong>function pointer</strong>).</p>\n\n<h5>Function pointers syntax</h5>\n\n<p>Cú pháp của một con trỏ hàm có nhiều điểm khác biệt so với cách khai báo con trỏ thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">&lt;return_type&gt; (*&lt;name_of_pointer&gt;)( &lt;data_type_of_parameters&gt; );</code></pre>\n\n<p>Mình lấy ví dụ, để trỏ đến hàm foo trong ví dụ trên, chúng ta cần khai báo con trỏ hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int (*pFoo) ();</code></pre>\n\n<p>Trong đó, <strong>int</strong> là kiểu trả về của hàm <strong>foo</strong>, <strong>pFoo</strong> là tên của con trỏ, và hàm <strong>foo</strong> không có tham số nên phần trong ngoặc mình bỏ trống. Một ví dụ khác, mình có hàm như bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}</code></pre>\n\n<p>Hàm <strong>swapValue</strong> có không có kiểu trả về, và nó nhận vào 2 tham số đều có kiểu tham chiếu <strong>int</strong>. Như vậy, mình có thể khai báo một con trỏ hàm dùng để trỏ đến hàm <strong>swapValue</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void(*pSwap) (int &amp;, int &amp;);</code></pre>\n\n<h5>Gán địa chỉ của hàm cho Function pointers</h5>\n\n<p>Sau khi đã có được con trỏ hàm được khai báo tương ứng với hàm, chúng ta có thể gán địa chỉ của hàm cho chúng:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\tcout &lt;&lt; pSwap &lt;&lt; endl;\n\tcout &lt;&lt; swapValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p><strong>Lưu ý, khi cần lấy địa chỉ của hàm, chúng ta chỉ sử dụng duy nhất tên hàm, không đặt thêm cặp dấu ngoặc vào.</strong></p>\n\n<p>Chỉ có con trỏ được khai báo có kiểu dữ liệu trả về và danh sách tham số phù hợp mới trỏ đến hàm được.</p>\n\n<p></p><pre><code class=\"lang-auto\">// function prototypes\nint foo();\ndouble goo();\nint hoo(int x);\n \n// function pointer assignments\nint (*funcPtr1)() = foo; // okay\nint (*funcPtr2)() = goo; // wrong -- return types don't match!\ndouble (*funcPtr4)() = goo; // okay\nfuncPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does\nint (*funcPtr3)(int) = hoo; // okay</code></pre>\n\n<h5>Sử dụng Function pointers</h5>\n\n<p>Sau khi đã nắm giữ được địa chỉ của hàm, con trỏ hàm có thể được sử dụng như hàm thông qua toán tử <strong>dereference</strong>. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2)\n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\t\n\tint a = 1, b = 5;\n\tcout &lt;&lt; \"Before: \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\t(*pSwap)(a, b);\n\tcout &lt;&lt; \"After:  \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, tham số mặc định của hàm không áp dụng được cho con trỏ hàm, vì tham số mặc định được <strong>compiler</strong> xác định tại thời điểm <strong>compile</strong> chương trình, còn con trỏ hàm được sử dụng tại thời điểm chương trình đang chạy.</p>\n\n<h5>Sử dụng con trỏ hàm làm tham số</h5>\n\n<p>Một con trỏ hàm cũng là một biến con trỏ, do đó chúng ta có thể sử dụng con trỏ hàm là tham số của một hàm nào đó. Khi tham số của hàm là con trỏ hàm, chúng ta sẽ truyền đối số là địa chỉ của một hàm. Hàm được sử dụng làm đối số của hàm có thể gọi là <strong>callback function</strong>.</p>\n\n<p>Mình lấy ví dụ về hàm <strong>selectionSort</strong> dùng để sắp xếp dữ liệu trong mảng số nguyên theo thứ tự tăng dần:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;algorithm&gt; // use for std::swap\n\nvoid selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (arr[minIndex] &gt; arr[i_current])\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}\n\n//................\n\nint main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  1 2 3 4 5 6 7 8 9</code></pre>\n\n<p>Bây giờ đặt ra trường hợp chúng ta muốn có sắp xếp mảng một chiều sử dụng thuật toán <strong>selectionSort</strong> nhưng sắp xếp theo thứ tự giảm dần. Như vậy, chúng ta cần đến 2 hàm <strong>selectionSort</strong> để đáp ứng cho 2 trường hợp mình kể trên. Trong khi cả 2 hàm <strong>selectionSort</strong> này chỉ khác nhau về toán tử so sánh tại phép so sánh ở mệnh đề if trong vòng lặp. </p>\n\n<p>Để giải quyết vấn đề này, đầu tiên mình cần có 2 hàm thực hiện công việc so sánh như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}</code></pre>\n\n<p>Hai hàm này chỉ có tác dụng thay thế phép so sánh trong mệnh đề if. Nếu chúng ta cần sắp xếp giá trị trong mảng theo thứ tự tăng dần, chúng ta sẽ thay thế hàm <strong>ascending</strong> vào mệnh đề if trong hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (ascending(arr[minIndex], arr[i_current])) // replace comparison expression by ascending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, chúng ta vẫn còn cần thêm một hàm <strong>selectionSort</strong> khác và thay thế biểu thức so sánh trong mệnh đề if bằng hàm <strong>descending</strong> để có thể sắp xếp mảng theo chiều giảm dần. Chúng ta cần thiết kế lại hàm <strong>selectionSort</strong> này sao cho người dùng có thể tùy chọn việc sắp xếp theo thứ tự tăng dần hay giảm dần theo từng thời điểm khác nhau. Chúng ta sẽ thêm vào tham số thứ 3 cho hàm <strong>selectionSort</strong> là một con trỏ hàm dùng để trỏ đến hàm <strong>ascending</strong> hoặc <strong>descending</strong> tùy vào lời gọi hàm <strong>selectionSort</strong>. Do hàm <strong>ascending</strong> và <strong>descending</strong> có cấu trúc kiểu trả về và tham số hoàn toàn giống nhau, nên chúng ta có thể sử dụng chung một kiểu con trỏ hàm. Mình định nghĩa con trỏ hàm dùng làm tham số thứ 3 của hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool (*comparisonFunc)(int, int);</code></pre>\n\n<p>Bây giờ, chúng ta sẽ sửa lại hàm <strong>selectionSort</strong> thành phiên bản sử dụng con trỏ hàm:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nvoid selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int))\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, giả sử mình muốn sắp xếp mảng theo thứ tự giảm dần, mình sẽ sử dụng lời gọi hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, descending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Mình sử dụng địa chỉ của hàm <strong>descending</strong> làm đối số cho tham số thứ 3 của hàm <strong>selectionSort</strong>. Như vậy, hàm <strong>descending</strong> sẽ được sử dụng bên trong hàm <strong>selectionSort</strong> và mảng của chúng ta sẽ sắp xếp theo thứ tự giảm dần.</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  9 8 7 6 5 4 3 2 1</code></pre>\n\n<p>Nếu muốn đổi ngược lại thứ tự của mảng khi sắp xếp, chúng ta chỉ cần thay đối số thứ 3 của hàm <strong>selectionSort</strong> là địa chỉ của hàm <strong>ascending</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, ascending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Với việc đặt thêm tham số thứ 3 của hàm <strong>selectionSort</strong> là 1 con trỏ hàm, chúng ta có thể thiết kế thêm nhiều tùy chọn cho điều kiện sắp xếp mảng một chiều khác nhau và vẫn có thể sử dụng cho hàm <strong>selectionSort</strong>. Ví dụ mình muốn thêm một kiểu sắp xếp có điều kiện khác là mọi số chẵn trong mảng sẽ đứng trước, các số lẻ trong mảng sẽ đứng sau, và phần chẵn hay phần lẻ đều được sắp xếp tăng dần, mình sẽ làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool evensFirst(int left, int right)\n{\n\t//if left is even and right is odd, not need to swap\n\tif ((left % 2 == 0) &amp;&amp; (right % 2 != 0))\n\t\treturn false;\n\n\t//if left is odd and right is even, swap this couple\n\tif ((left % 2 != 0) &amp;&amp; (right % 2 == 0))\n\t\treturn true;\n\n\treturn ascending(left, right);\n}</code></pre>\n\n<p>Và mình chỉ cần sử dụng địa chỉ của hàm này làm đối số:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, evensFirst);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  2 4 6 8 1 3 5 7 9</code></pre>\n\n<p>Như các bạn thấy, sử dụng con trỏ hàm trong trường hợp này mang lại cho chúng ta một cách sử dụng hàm sắp xếp hiệu quả hơn.</p>\n\n<h5>Tham số mặc định của tham số con trỏ hàm</h5>\n\n<p>Chúng ta có thể cung cấp cho tham số con trỏ hàm một địa chỉ hàm cụ thể, và hàm đó sẽ được gọi mặc định nếu chúng ta không cung cấp đối số cho tham số con trỏ hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int) = ascending)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Như vậy, lời gọi hàm <strong>selectionSort</strong> với 2 đối số sẽ được mặc định là sắp xếp mảng tăng dần.</p>\n\n<h3>std::function in C++11</h3>\n\n<p>Chuẩn C++11 cung cấp cho chúng ta một cách thay thế cho việc sử dụng con trỏ hàm bằng cách sử dụng kiểu dữ liệu <strong>function</strong> thuộc thư viện <strong>functional</strong>. Thư viện này cũng được định nghĩa trong namespace <strong>std</strong> nên chúng ta cần có dòng lệnh <code>using namespace std;</code> hoặc có thể khai báo là <code>std::function</code>.</p>\n\n<p>Cú pháp khai báo biến kiểu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; &lt;return_type&gt;([list of parameters]) &gt; varName;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; bool(int, int) &gt; comparisonFunc;</code></pre>\n\n<p>Mình lấy ví dụ về việc sử dụng kiểu dữ liệu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nvoid addOne(int &amp;value)\n{\n\tvalue++;\n}\n\nint main()\n{\n\tfunction&lt;void(int &amp;)&gt; func = addOne;\n\t\n\tint number = 5;\n\tfunc(number);\n\n\tcout &lt;&lt; \"New value: \" &lt;&lt; number &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Như các bạn thấy, sử dụng kiểu dữ liệu <code>std::function</code> cũng tương tự như sử dụng con trỏ hàm, chỉ khác nhau về cách khai báo.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Con trỏ hàm (<strong>function pointers</strong>) thường được sử dụng khi chúng ta có các hàm có cùng kiểu trả về và danh sách tham số. Đặt con trỏ hàm làm tham số của hàm cũng là một cách sử dụng con trỏ hàm khá phổ biến. </p>\n\n<p>Vì con trỏ hàm có cú pháp khai báo khó nhớ hơn kiểu <code>std::function</code>, mình khuyến khích các bạn sử dụng kiểu <code>std::function</code> được định nghĩa bên trong thư viện <strong>functional</strong> của chuẩn C++11.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Sửa lại hàm selectionSort phiên bản sử dụng con trỏ hàm làm tham số thứ 3 sao cho phù hợp với cách định nghĩa của 2 hàm so sánh bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &gt; right;\n}</code></pre>\n\n<p>2/ Sử dụng con trỏ hàm để tạo hàm có thể thực hiện 4 phép toán cơ bản (+, -, *, /). Biết rằng, với mỗi phép toán chúng ta có một hàm có kiểu trả về float, mỗi hàm có 2 tham số kiểu float. Sau đó, viết hoàn thiện một chương trình đơn giản cho phép người dùng nhập vào toán tử (+, -, *, /) từ bàn phím và thực hiện phép toán với toán tử tương ứng thông qua hàm mà bạn đã định nghĩa.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","raw":"---json\n{\"title\":\"8.9 Con trỏ hàm\",\"route\":\"8/9-con-tr-ham\",\"id\":31959}\n---\n\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Tiếp tục tìm hiểu về con trỏ trong ngôn ngữ lập trình C++, trong bài học này, mình sẽ giới thiệu đến các bạn một loại con trỏ mới có chức năng khá đặc biệt. </p>\n\n<p>Như chúng ta đã biết, con trỏ có chức năng lưu trữ địa chỉ của một vùng nhớ nào đó trên bộ nhớ ảo. Tuy nhiên, bộ nhớ ảo được chia làm nhiều phân vùng khác nhau.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/0.png?raw=true\" width=\"640\" height=\"500\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">670x523</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Như trong hình, hầu hết toàn bộ phân vùng của bộ nhớ ảo đều dùng để lưu trữ dữ liệu (biến đơn, giá trị, chuỗi kí tự, ...). Nhưng dữ liệu lưu trên bộ nhớ ảo là cái được tạo ra sau khi chương trình nào đó được thực thi và nó xin cấp phát vùng nhớ trên bộ nhớ ảo để sử dụng. Trước đó, chương trình hoạt động dựa trên các dòng lệnh mà lập trình viên đưa ra sử dụng cú pháp của ngôn ngữ lập trình nào đó. Và trước khi chạy chương trình, mã nguồn (đã được biên dịch thành mã máy) đang lưu trữ trong máy tính (có thể là trên ổ cứng) cũng phải được hệ điều hành load lên RAM và quản lý bằng cách đưa vào bộ nhớ ảo. Vậy mã nguồn của chương trình sẽ lưu ở đâu trên bộ nhớ ảo? Đó là tại phân vùng Text (<strong>Text segment</strong>) hay còn gọi là phân vùng Code (<strong>Code segment</strong>). Tất cả các lệnh, các hàm... của chương trình sẽ được đưa vào phân vùng này, trong đó có cả hàm <strong>main</strong> nếu đó là chương trình C++. Như các bạn đã biết, một chương trình C++ sẽ có duy nhất một hàm <strong>main</strong> đóng vai trò là điểm bắt đầu của chương trình đó. Như vậy, sau khi được load mã nguồn C++ đã được biên dịch lên bộ nhớ ảo, hệ điều hành sẽ tìm đến vị trí (địa chỉ) của hàm <strong>main</strong> và chuyển mã nguồn đến cho CPU xử lý.</p>\n\n<p>Mình có thể cho các bạn xem địa chỉ của hàm <strong>main</strong> của một chương trình C++ ở trên máy mình như hình bên dưới:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-9-con-tro-ham/1.png?raw=true\" width=\"579\" height=\"384\"></p>\n\n<p>Như các bạn thấy, hàm <strong>main</strong> (hay bất kỳ hàm nào khác trong chương trình) có một địa chỉ xác định trên bộ nhớ ảo. Do đó, chúng ta có thể sử dụng con trỏ để trỏ đến địa chỉ của hàm <strong>main</strong>. Tuy nhiên, chúng ta cần lưu ý đến kiểu dữ liệu khai báo cho con trỏ phải tương thích với kiểu dữ liệu của vùng nhớ. Ví dụ, con trỏ kiểu <strong>int</strong> dùng để trỏ đến vùng nhớ kiểu <strong>int</strong>, con trỏ trỏ đến hằng (<strong>Pointer to const</strong>) dùng để trỏ đến vùng nhớ hằng... Và để trỏ đến địa chỉ của một hàm, chúng ta cần sử dụng con trỏ hàm (<strong>Function pointer</strong> hoặc có thể gọi là <strong>Pointer to function</strong>).</p>\n\n<h3>Function pointers</h3>\n\n<p>Khi nhìn vào một hàm (function), ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể nói hàm này có định danh là <strong>foo</strong>, kiểu trả về là int, hàm foo không nhận đối số. Đó là những gì chúng ta thấy được trong quá trình biên soạn mã nguồn chương trình. Thuộc tính địa chỉ của hàm chỉ được sinh ra khi chương trình đã được chạy.</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo() // code of foo start at memory address 0x01001492\n{\n\treturn 0;\n}\n\nint main()\t\n{\n\tint n = foo();\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Như vậy, khi trong hàm <strong>main</strong> chạy đến dòng lệnh gọi hàm <strong>foo</strong>, hệ điều hành sẽ tìm đến địa chỉ của hàm <strong>foo</strong> trên bộ nhớ ảo và chuyển mã lệnh của hàm <strong>foo</strong> cho CPU tiếp tục xử lý. Để in ra địa chỉ của hàm <strong>foo</strong>, chúng ta có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int foo()\n{\n\treturn 0;\n}\n\nint main()\n{\n\tcout &lt;&lt; foo &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">013D1492</code></pre>\n\n<p>Như các bạn thấy, khi muốn thực thi một hàm, chúng ta cần thêm cặp dấu ngoặc để truyền đối số vào cho hàm (nếu hàm không có tham số thì để trống). Nếu chúng ta không sử dụng cặp dấu ngoặc, sử dụng tên hàm trả về địa chỉ của hàm trên bộ nhớ ảo. Và địa chỉ này có thể được gán con một con trỏ có kiểu dữ liệu tương ứng (<strong>function pointer</strong>).</p>\n\n<h5>Function pointers syntax</h5>\n\n<p>Cú pháp của một con trỏ hàm có nhiều điểm khác biệt so với cách khai báo con trỏ thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">&lt;return_type&gt; (*&lt;name_of_pointer&gt;)( &lt;data_type_of_parameters&gt; );</code></pre>\n\n<p>Mình lấy ví dụ, để trỏ đến hàm foo trong ví dụ trên, chúng ta cần khai báo con trỏ hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int (*pFoo) ();</code></pre>\n\n<p>Trong đó, <strong>int</strong> là kiểu trả về của hàm <strong>foo</strong>, <strong>pFoo</strong> là tên của con trỏ, và hàm <strong>foo</strong> không có tham số nên phần trong ngoặc mình bỏ trống. Một ví dụ khác, mình có hàm như bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}</code></pre>\n\n<p>Hàm <strong>swapValue</strong> có không có kiểu trả về, và nó nhận vào 2 tham số đều có kiểu tham chiếu <strong>int</strong>. Như vậy, mình có thể khai báo một con trỏ hàm dùng để trỏ đến hàm <strong>swapValue</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void(*pSwap) (int &amp;, int &amp;);</code></pre>\n\n<h5>Gán địa chỉ của hàm cho Function pointers</h5>\n\n<p>Sau khi đã có được con trỏ hàm được khai báo tương ứng với hàm, chúng ta có thể gán địa chỉ của hàm cho chúng:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2) \n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\tcout &lt;&lt; pSwap &lt;&lt; endl;\n\tcout &lt;&lt; swapValue &lt;&lt; endl;\n\t\n\treturn 0;\n}</code></pre>\n\n<p><strong>Lưu ý, khi cần lấy địa chỉ của hàm, chúng ta chỉ sử dụng duy nhất tên hàm, không đặt thêm cặp dấu ngoặc vào.</strong></p>\n\n<p>Chỉ có con trỏ được khai báo có kiểu dữ liệu trả về và danh sách tham số phù hợp mới trỏ đến hàm được.</p>\n\n<p></p><pre><code class=\"lang-auto\">// function prototypes\nint foo();\ndouble goo();\nint hoo(int x);\n \n// function pointer assignments\nint (*funcPtr1)() = foo; // okay\nint (*funcPtr2)() = goo; // wrong -- return types don't match!\ndouble (*funcPtr4)() = goo; // okay\nfuncPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does\nint (*funcPtr3)(int) = hoo; // okay</code></pre>\n\n<h5>Sử dụng Function pointers</h5>\n\n<p>Sau khi đã nắm giữ được địa chỉ của hàm, con trỏ hàm có thể được sử dụng như hàm thông qua toán tử <strong>dereference</strong>. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void swapValue(int &amp;value1, int &amp;value2)\n{\n\tint temp = value1;\n\tvalue1 = value2;\n\tvalue2 = temp;\n}\n\nint main()\n{\n\tvoid(*pSwap) (int &amp;, int &amp;) = swapValue;\n\t\n\tint a = 1, b = 5;\n\tcout &lt;&lt; \"Before: \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\t(*pSwap)(a, b);\n\tcout &lt;&lt; \"After:  \" &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Lưu ý, tham số mặc định của hàm không áp dụng được cho con trỏ hàm, vì tham số mặc định được <strong>compiler</strong> xác định tại thời điểm <strong>compile</strong> chương trình, còn con trỏ hàm được sử dụng tại thời điểm chương trình đang chạy.</p>\n\n<h5>Sử dụng con trỏ hàm làm tham số</h5>\n\n<p>Một con trỏ hàm cũng là một biến con trỏ, do đó chúng ta có thể sử dụng con trỏ hàm là tham số của một hàm nào đó. Khi tham số của hàm là con trỏ hàm, chúng ta sẽ truyền đối số là địa chỉ của một hàm. Hàm được sử dụng làm đối số của hàm có thể gọi là <strong>callback function</strong>.</p>\n\n<p>Mình lấy ví dụ về hàm <strong>selectionSort</strong> dùng để sắp xếp dữ liệu trong mảng số nguyên theo thứ tự tăng dần:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;algorithm&gt; // use for std::swap\n\nvoid selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (arr[minIndex] &gt; arr[i_current])\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}\n\n//................\n\nint main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  1 2 3 4 5 6 7 8 9</code></pre>\n\n<p>Bây giờ đặt ra trường hợp chúng ta muốn có sắp xếp mảng một chiều sử dụng thuật toán <strong>selectionSort</strong> nhưng sắp xếp theo thứ tự giảm dần. Như vậy, chúng ta cần đến 2 hàm <strong>selectionSort</strong> để đáp ứng cho 2 trường hợp mình kể trên. Trong khi cả 2 hàm <strong>selectionSort</strong> này chỉ khác nhau về toán tử so sánh tại phép so sánh ở mệnh đề if trong vòng lặp. </p>\n\n<p>Để giải quyết vấn đề này, đầu tiên mình cần có 2 hàm thực hiện công việc so sánh như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}</code></pre>\n\n<p>Hai hàm này chỉ có tác dụng thay thế phép so sánh trong mệnh đề if. Nếu chúng ta cần sắp xếp giá trị trong mảng theo thứ tự tăng dần, chúng ta sẽ thay thế hàm <strong>ascending</strong> vào mệnh đề if trong hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (ascending(arr[minIndex], arr[i_current])) // replace comparison expression by ascending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, chúng ta vẫn còn cần thêm một hàm <strong>selectionSort</strong> khác và thay thế biểu thức so sánh trong mệnh đề if bằng hàm <strong>descending</strong> để có thể sắp xếp mảng theo chiều giảm dần. Chúng ta cần thiết kế lại hàm <strong>selectionSort</strong> này sao cho người dùng có thể tùy chọn việc sắp xếp theo thứ tự tăng dần hay giảm dần theo từng thời điểm khác nhau. Chúng ta sẽ thêm vào tham số thứ 3 cho hàm <strong>selectionSort</strong> là một con trỏ hàm dùng để trỏ đến hàm <strong>ascending</strong> hoặc <strong>descending</strong> tùy vào lời gọi hàm <strong>selectionSort</strong>. Do hàm <strong>ascending</strong> và <strong>descending</strong> có cấu trúc kiểu trả về và tham số hoàn toàn giống nhau, nên chúng ta có thể sử dụng chung một kiểu con trỏ hàm. Mình định nghĩa con trỏ hàm dùng làm tham số thứ 3 của hàm <strong>selectionSort</strong> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool (*comparisonFunc)(int, int);</code></pre>\n\n<p>Bây giờ, chúng ta sẽ sửa lại hàm <strong>selectionSort</strong> thành phiên bản sử dụng con trỏ hàm:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &gt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nvoid selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int))\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Lúc này, giả sử mình muốn sắp xếp mảng theo thứ tự giảm dần, mình sẽ sử dụng lời gọi hàm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, descending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Mình sử dụng địa chỉ của hàm <strong>descending</strong> làm đối số cho tham số thứ 3 của hàm <strong>selectionSort</strong>. Như vậy, hàm <strong>descending</strong> sẽ được sử dụng bên trong hàm <strong>selectionSort</strong> và mảng của chúng ta sẽ sắp xếp theo thứ tự giảm dần.</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  9 8 7 6 5 4 3 2 1</code></pre>\n\n<p>Nếu muốn đổi ngược lại thứ tự của mảng khi sắp xếp, chúng ta chỉ cần thay đối số thứ 3 của hàm <strong>selectionSort</strong> là địa chỉ của hàm <strong>ascending</strong>:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, ascending);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Với việc đặt thêm tham số thứ 3 của hàm <strong>selectionSort</strong> là 1 con trỏ hàm, chúng ta có thể thiết kế thêm nhiều tùy chọn cho điều kiện sắp xếp mảng một chiều khác nhau và vẫn có thể sử dụng cho hàm <strong>selectionSort</strong>. Ví dụ mình muốn thêm một kiểu sắp xếp có điều kiện khác là mọi số chẵn trong mảng sẽ đứng trước, các số lẻ trong mảng sẽ đứng sau, và phần chẵn hay phần lẻ đều được sắp xếp tăng dần, mình sẽ làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool evensFirst(int left, int right)\n{\n\t//if left is even and right is odd, not need to swap\n\tif ((left % 2 == 0) &amp;&amp; (right % 2 != 0))\n\t\treturn false;\n\n\t//if left is odd and right is even, swap this couple\n\tif ((left % 2 != 0) &amp;&amp; (right % 2 == 0))\n\t\treturn true;\n\n\treturn ascending(left, right);\n}</code></pre>\n\n<p>Và mình chỉ cần sử dụng địa chỉ của hàm này làm đối số:</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tint arr[] = { 1, 4, 2, 3, 6, 5, 8, 9, 7 };\n\tint length = sizeof(arr) / sizeof(int);\n\n\tcout &lt;&lt; \"Before sorted: \";\n\tprintArray(arr, length);\n\n\tselectionSort(arr, length, evensFirst);\n\n\tcout &lt;&lt; \"After sorted:  \";\n\tprintArray(arr, length);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả:</p>\n\n<p></p><pre><code class=\"lang-auto\">Before sorted: 1 4 2 3 6 5 8 9 7\nAfter sorted:  2 4 6 8 1 3 5 7 9</code></pre>\n\n<p>Như các bạn thấy, sử dụng con trỏ hàm trong trường hợp này mang lại cho chúng ta một cách sử dụng hàm sắp xếp hiệu quả hơn.</p>\n\n<h5>Tham số mặc định của tham số con trỏ hàm</h5>\n\n<p>Chúng ta có thể cung cấp cho tham số con trỏ hàm một địa chỉ hàm cụ thể, và hàm đó sẽ được gọi mặc định nếu chúng ta không cung cấp đối số cho tham số con trỏ hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">void selectionSort(int *arr, int length, bool (*comparisonFunc)(int, int) = ascending)\n{\n\tfor (int i_start = 0; i_start &lt; length; i_start++)\n\t{\n\t\tint minIndex = i_start;\n\n\t\tfor (int i_current = i_start + 1; i_current &lt; length; i_current++)\n\t\t{\n\t\t\tif (comparisonFunc(arr[minIndex], arr[i_current])) // use function pointer as ascending or descending function\n\t\t\t{\n\t\t\t\tminIndex = i_current;\n\t\t\t}\n\t\t}\n\n\t\tswap(arr[i_start], arr[minIndex]); // std::swap\n\t}\n}</code></pre>\n\n<p>Như vậy, lời gọi hàm <strong>selectionSort</strong> với 2 đối số sẽ được mặc định là sắp xếp mảng tăng dần.</p>\n\n<h3>std::function in C++11</h3>\n\n<p>Chuẩn C++11 cung cấp cho chúng ta một cách thay thế cho việc sử dụng con trỏ hàm bằng cách sử dụng kiểu dữ liệu <strong>function</strong> thuộc thư viện <strong>functional</strong>. Thư viện này cũng được định nghĩa trong namespace <strong>std</strong> nên chúng ta cần có dòng lệnh <code>using namespace std;</code> hoặc có thể khai báo là <code>std::function</code>.</p>\n\n<p>Cú pháp khai báo biến kiểu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; &lt;return_type&gt;([list of parameters]) &gt; varName;</code></pre>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::function&lt; bool(int, int) &gt; comparisonFunc;</code></pre>\n\n<p>Mình lấy ví dụ về việc sử dụng kiểu dữ liệu <code>std::function</code> như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nvoid addOne(int &amp;value)\n{\n\tvalue++;\n}\n\nint main()\n{\n\tfunction&lt;void(int &amp;)&gt; func = addOne;\n\t\n\tint number = 5;\n\tfunc(number);\n\n\tcout &lt;&lt; \"New value: \" &lt;&lt; number &lt;&lt; endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Như các bạn thấy, sử dụng kiểu dữ liệu <code>std::function</code> cũng tương tự như sử dụng con trỏ hàm, chỉ khác nhau về cách khai báo.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Con trỏ hàm (<strong>function pointers</strong>) thường được sử dụng khi chúng ta có các hàm có cùng kiểu trả về và danh sách tham số. Đặt con trỏ hàm làm tham số của hàm cũng là một cách sử dụng con trỏ hàm khá phổ biến. </p>\n\n<p>Vì con trỏ hàm có cú pháp khai báo khó nhớ hơn kiểu <code>std::function</code>, mình khuyến khích các bạn sử dụng kiểu <code>std::function</code> được định nghĩa bên trong thư viện <strong>functional</strong> của chuẩn C++11.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Sửa lại hàm selectionSort phiên bản sử dụng con trỏ hàm làm tham số thứ 3 sao cho phù hợp với cách định nghĩa của 2 hàm so sánh bên dưới:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool ascending(int left, int right)\n{\n\treturn left &lt; right;\n}\n\nbool descending(int left, int right)\n{\n\treturn left &gt; right;\n}</code></pre>\n\n<p>2/ Sử dụng con trỏ hàm để tạo hàm có thể thực hiện 4 phép toán cơ bản (+, -, *, /). Biết rằng, với mỗi phép toán chúng ta có một hàm có kiểu trả về float, mỗi hàm có 2 tham số kiểu float. Sau đó, viết hoàn thiện một chương trình đơn giản cho phép người dùng nhập vào toán tử (+, -, *, /) từ bàn phím và thực hiện phép toán với toán tử tương ứng thông qua hàm mà bạn đã định nghĩa.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.95b3e8ea543c2c88ac5aed6fae7dd5bc.json"}