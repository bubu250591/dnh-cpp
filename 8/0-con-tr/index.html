<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/dnh-cpp/phenomic.browser.9aef6afea50b2450360e.css" /><meta data-react-helmet="true" property="og:site_name" content="dnh-cpp"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="8.0 Con trỏ"/><meta data-react-helmet="true" property="og:url" content="/8/0-con-tr/"/><meta data-react-helmet="true" property="og:description" content="cout &amp;lt;&amp;lt; &amp;i1 &amp;lt;&amp;lt; endl;    //get address of i1 cout &amp;lt;&amp;lt; &amp;i_ref &amp;lt;&amp;lt; endl; //get address of i_ref cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="8.0 Con trỏ"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="cout &amp;lt;&amp;lt; &amp;i1 &amp;lt;&amp;lt; endl;    //get address of i1 cout &amp;lt;&amp;lt; &amp;i_ref &amp;lt;&amp;lt; endl; //get address of i_ref cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt…"/><meta data-react-helmet="true" name="description" content="cout &amp;lt;&amp;lt; &amp;i1 &amp;lt;&amp;lt; endl;    //get address of i1 cout &amp;lt;&amp;lt; &amp;i_ref &amp;lt;&amp;lt; endl; //get address of i_ref cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt…"/><title data-react-helmet="true">8.0 Con trỏ</title></head><body><div id="phenomic"><div class="_2lE56" data-reactroot="" data-reactid="1" data-react-checksum="482111533"><!-- react-empty: 2 --><div class="_1Ih7a _1GU64" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><div class="_1G2C6 _3fTO1" data-reactid="7"><div class="aCd9j" data-reactid="8"><a href="https://github.com/daynhauhoc/cppcoban" target="_blank" data-hint="Fork on Github" class="hint--bottom-left _2dICi" data-reactid="9"><span class="SVGInline" data-reactid="10"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span></a><a href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank" data-hint="Share on Facebook" class="hint--bottom-left _2dICi" data-reactid="11"><span class="SVGInline" data-reactid="12"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="430.113px" height="430.114px" viewBox="0 0 430.113 430.114" style="enable-background:new 0 0 430.113 430.114;"
	 xml:space="preserve">
<g>
	<path id="Facebook" d="M158.081,83.3c0,10.839,0,59.218,0,59.218h-43.385v72.412h43.385v215.183h89.122V214.936h59.805
		c0,0,5.601-34.721,8.316-72.685c-7.784,0-67.784,0-67.784,0s0-42.127,0-49.511c0-7.4,9.717-17.354,19.321-17.354
		c9.586,0,29.818,0,48.557,0c0-9.859,0-43.924,0-75.385c-25.016,0-53.476,0-66.021,0C155.878-0.004,158.081,72.48,158.081,83.3z"/>
</g>
</svg></span></a></div></div><article class="markdown-body" data-reactid="13"><h1 data-reactid="14">8.0 Con trỏ</h1><div data-reactid="15"><div class="phenomic-BodyContainer" data-reactid="16">
<h4>Chào các bạn học viên đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>

<p>Trong chương này, chúng ta sẽ cùng nhau tìm hiểu về khái niệm con trỏ (<strong>Pointer</strong>) - một đặc trưng của ngôn ngữ lập trình C/C++.</p>

<p>Trước khi vào bài học này, chúng ta cùng nhau xem lại một số khái niệm liên quan đến vùng nhớ, địa chỉ của biến, tham chiếu...</p>

<h5>Variable</h5>

<p>Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình C++ nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu.</p>

<p>Khi thao tác với các biến thông thường, chúng ta không cần quan tâm đến địa chỉ vùng nhớ của biến. Khi cần truy xuất giá trị của biến, chúng ta chỉ cần gọi định danh (hay thường gọi là tên biến).</p>

<p>Ví dụ:</p>

<pre><code>int money;</code></pre>

<p>Khi dòng lệnh này được CPU thực thi, một vùng nhớ có kích thước 4 bytes sẽ được cấp phát. Lấy ví dụ biến money này được đặt tại ô nhớ 1224 (trong địa chỉ ảo của máy tính).</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/0.png?raw=true" width="400" height="300"></p>

<p>Bất cứ khi nào chương trình thấy các bạn sử dụng biến money trong câu lệnh, chương trình hiểu rằng cần tìm đến ô nhớ 1224 để lấy giá trị đó ra.</p>

<h5>Virtual memory &amp; Physical memory</h5>

<p>Việc truy xuất dữ liệu trên bộ nhớ máy tính cần phải thông qua một số bước trung gian, người dùng không thể trực tiếp truy xuất vào các ô nhớ trên các thiết bị lưu trữ. Chúng ta chỉ có thể trỏ đến vùng nhớ ảo (virtual memory) trên máy tính, còn việc truy xuất đến bộ nhớ vật lý (physical memory) từ bộ nhớ ảo phải được thực hiện bởi thiết bị phần cứng có tên là <strong>Memory management unit (MMU)</strong> và một chương trình định vị địa chỉ bộ nhớ gọi là <strong>Virtual address space</strong>.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true" class="lightbox" title="1.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true" width="690" height="373"><div class="meta">
<span class="filename">1.png?raw=true</span><span class="informations">1045x566</span><span class="expand"></span>
</div></a></div></p>

<p>Virtual memory làm che giấu sự phân mảnh của bộ nhớ vật lý, khiến chúng ta có cảm giác đang thao tác với các vùng nhớ liên tục. Trong hình trên, từ phía Virtual memory cho đến Physical memory thuộc về phần quản lý của hệ điều hành, lập trình viên và người dùng chúng ta không thể can thiệp trực tiếp đến trong quá trình máy tính đang hoạt động.</p>

<h5>Variable address &amp; address-of operator</h5>

<p>Địa chỉ của biến mà chúng ta nhìn thấy thật ra chỉ là những giá trị đã được đánh số thứ tự đặt trên Virtual memory. Để lấy được địa chỉ ảo của biến trong chương trình, chúng ta sử dụng toán tử <strong>'&amp;'</strong> đặt trước tên biến.</p>

<pre><code>int x = 5;
std::cout &lt;&lt; x &lt;&lt; '\n'; // print the value of variable x
std::cout &lt;&lt; &amp;x &lt;&lt; '\n'; // print the memory address of variable x</code></pre>

<p>Trên máy tính của mình, kết quả của đoạn chương trình trên được in ra như sau:</p>

<pre><code>5
0027FEA0</code></pre>

<p>Dòng đầu tiên là kết quả của việc truy xuất giá trị của biến thông qua định danh (tên biến). Dòng thứ hai là kết quả của việc truy xuất đến địa chỉ ảo của biến.</p>

<h5>Tham chiếu (Reference)</h5>

<p>Mục đích của tham chiếu trong C++ là tạo ra một biến khác có cùng kiểu dữ liệu nhưng sử dụng chung vùng nhớ với biến được tham chiếu đến.</p>

<pre><code>int i1 = 10;
int &amp;i_ref = i1;        //reference to i1, not means address of i1

cout &lt;&lt; &amp;i1 &lt;&lt; endl;    //get address of i1
cout &lt;&lt; &amp;i_ref &lt;&lt; endl; //get address of i_ref</code></pre>

<p>Kết quả chúng ta được:</p>

<pre><code>0xBFEB475C
0xBFEB475C</code></pre>

<p>Như vậy, mọi hành vi thay đổi giá trị của <code>i_ref</code> đều tác động trực tiếp đến <code>i1</code>.</p>

<p><strong><em>Lưu ý: Biến tham chiếu sẽ có địa chỉ cố định sau khi khởi tạo. Chúng ta không thể tham chiếu lại lần nữa.</em></strong></p>

<h5>Dereference operator</h5>

<p>Toán tử trỏ đến (<strong>dereference operator</strong>) hay còn gọi là <strong>indirection operator</strong> (toán tử điều hành gián tiếp) được kí hiệu bằng dấu sao <strong>" * "</strong> cho phép chúng ta lấy ra giá trị của vùng nhớ có địa chỉ cụ thể.</p>

<p>Ví dụ:</p>

<pre><code>int n = 5;

cout &lt;&lt; n &lt;&lt; endl;     //print the value of variable n
cout &lt;&lt; &amp;n &lt;&lt; endl;    //print the virtual memory address of variable n
cout &lt;&lt; *(&amp;n) &lt;&lt; endl; //print the value at the virtual memory address of variable n</code></pre>

<ul>
<li><p>Dòng lệnh cout đầu tiên khá dễ hiểu, nó thực hiện in ra giá trị của biến n bằng cách gọi định danh n, còn lại phần truy xuất đến địa chỉ ảo của biến n sẽ do chương trình đảm nhiệm.</p></li>
<li><p>Dòng lệnh cout thứ hai không dùng để lấy ra giá trị bên trong vùng nhớ mà biến n đang nắm giữ, mà nó lấy ra địa chỉ ảo của biến n.</p></li>
<li><p>Dòng lệnh cout thứ ba chúng ta sử dụng toán tử trỏ đến <strong>" * "</strong> đặt trước toán tử <strong>address-of</strong>. Khi đó, <strong>(&amp;n)</strong> sẽ lấy ra địa chỉ ảo của biến n, và toán tử * sẽ truy xuất giá trị bên trong địa chỉ đó.</p></li>
</ul>

<p>Kết quả của đoạn chương trình trên là:</p>

<pre><code>5
0xBFD181AC
5</code></pre>

<p>Ngoài việc truy xuất giá trị trong vùng nhớ của một địa chỉ cụ thể, toán tử trỏ đến (<strong>dereference operator</strong>) còn có thể dùng để thay đổi giá trị bên trong vùng nhớ đó.</p>

<pre><code>int n = 5;
cout &lt;&lt; n &lt;&lt; endl;
*(&amp;n) = 10;
cout &lt;&lt; n &lt;&lt; endl;</code></pre>

<p>Kết quả đoạn chương trình này là:</p>

<pre><code>5
10</code></pre>

<p>Như vậy, <strong>dereference operator</strong> cho phép chúng ta thao tác trực tiếp trên <strong>Virtual memory</strong> mà không cần thông qua định danh (tên biến).</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true" class="lightbox" title="2.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true" width="690" height="430"><div class="meta">
<span class="filename">2.png?raw=true</span><span class="informations">786x490</span><span class="expand"></span>
</div></a></div></p>

<p>Mặc dù <strong>dereference operator</strong> có kí hiệu giống <strong>multiplication operator</strong>, nhưng các bạn có thể phân biệt được vì <strong>dereference operator</strong> là toán tử một ngôi, trong khi đó, <strong>multiplication operator</strong> là toán tử hai ngôi.</p>

<p>Khác với tham chiếu (<strong>reference</strong>), toán tử trỏ đến (<strong>dereference operator</strong>) không tạo ra một tên biến khác, mà nó truy xuất trực tiếp đến vùng nhớ có địa chỉ cụ thể trên <strong>Virtual memory</strong>.</p>

<hr>

<h3>Con trỏ (Pointer)</h3>

<p>Với những khái niệm mình trình bày ở trên (một số khái niệm các bạn đã được học), bây giờ chúng ta có thể nói đến con trỏ (<strong>pointer</strong>).</p>

<blockquote><p>Một con trỏ (a <strong>pointer</strong>) là một biến được dùng để lưu trữ địa chỉ của biến khác.</p></blockquote>

<p>Khác với tham chiếu, con trỏ là một biến có địa chỉ độc lập so với vùng nhớ mà nó trỏ đến, nhưng giá trị bên trong vùng nhớ của con trỏ chính là địa chỉ của biến (hoặc địa chỉ ảo) mà nó trỏ tới.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true" class="lightbox" title="3.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true" width="690" height="411"><div class="meta">
<span class="filename">3.png?raw=true</span><span class="informations">983x586</span><span class="expand"></span>
</div></a></div></p>

<p>Trong ví dụ trên, một con trỏ sau khi khai báo đã được cấp phát vùng nhớ tại địa chỉ 3255, và nó trỏ đến địa chỉ 1224, do đó, giá trị bên trong vùng nhớ của con trỏ là 1224.</p>

<h5>Khai báo con trỏ</h5>

<p>Cũng giống như biến thông thường, biến con trỏ cần được khai báo trước khi sử dụng. Con trỏ yêu cầu cú pháp khai báo mới hơn một chút so với biến thông thường.</p>

<pre><code>&lt;data_type&gt; *&lt;name_of_pointer&gt;;</code></pre>

<p>Khác với biến thông thường, chúng ta cần đặt thêm dấu sao giữa kiểu dữ liệu và tên biến của con trỏ.</p>

<p>Ví dụ:</p>

<pre><code>int *iPtr;
float *fPtr;
double *dPtr;

int *iPtr1, *iPtr2;</code></pre>

<p><strong><em>Lưu ý: Dấu sao trong khai báo con trỏ không phải là toán tử trỏ đến (dereference operator), nó chỉ là cú pháp được ngôn ngữ C/C++ quy định.</em></strong></p>

<h5>Cách khai báo dễ gây nhầm lẫn</h5>

<p>Ngôn ngữ C/C++ yêu cầu đặt dấu sao giữa kiểu dữ liệu và tên con trỏ nhưng không bắt buộc phải đặt nó gần với kiểu dữ liệu hay gần với tên con trỏ. Do đó, những cách khai báo dưới đây đều được cho phép:</p>

<pre><code>int *iPtr1; //We recommended you use this way to declare pointers
int* iPtr2;</code></pre>

<p>Nhưng mình khuyến nghị các bạn sử dụng cách khai báo đặt dấu sao ngay trước tên con trỏ vì cách thứ hai có thể gây nhầm lẫn.</p>

<pre><code>int* iPtr1, iPtr2;</code></pre>

<p>Với cách khai báo này, <strong>iPtr1</strong> là một con trỏ kiểu <strong>int</strong>, trong khi đó, <strong>iPtr2</strong> là một biến kiểu <strong>int</strong>. Để có được hai con trỏ, chúng ta cần khai báo như sau:</p>

<pre><code>int *iPtr1, *iPtr2;</code></pre>

<h5>Kích thước của con trỏ trong bộ nhớ</h5>

<p>Các bạn cùng chạy thử đoạn chương trình dưới đây:</p>

<pre><code>cout &lt;&lt; sizeof(char*) &lt;&lt; endl;
cout &lt;&lt; sizeof(int*) &lt;&lt; endl;
cout &lt;&lt; sizeof(double*) &lt;&lt; endl;
cout &lt;&lt; sizeof(string*) &lt;&lt; endl;</code></pre>

<p>Đoạn chương trình trên cho ra kết quả như sau:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/4.png?raw=true" width="677" height="343"></p>

<p>Tại cửa sổ giao diện của Visual studio 2015, chúng ta chuyển sang Debug trên nền tảng 64 bits.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true" class="lightbox" title="5.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true" width="690" height="321"><div class="meta">
<span class="filename">5.png?raw=true</span><span class="informations">901x420</span><span class="expand"></span>
</div></a></div></p>

<p>Nhấn F5 lại lần nữa và xem lại kết quả:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/6.png?raw=true" width="677" height="343"></p>

<p><strong><em>Như vậy, chúng ta thấy rằng khi chạy trên nền tảng hệ điều hành 32 bits con trỏ sẽ có kích thước 4 bytes, khi chạy trên nền tảng hệ điều hành 64 bits con trỏ sẽ có kích thước 8 bytes.</em></strong></p>

<p>Kiểu dữ liệu của con trỏ thay đổi không hề tác động đến kích thước bộ nhớ của con trỏ. Bởi vì giá trị thực sự của con trỏ là kiểu số nguyên không dấu (<strong>unsigned int</strong>), trong nền tảng hệ điều hành <strong>32 bits</strong>, giá trị mà con trỏ lưu trữ sẽ là <code>unsigned __int32</code>, và trong nền tảng hệ điều hành <strong>64 bits</strong>, giá trị của con trỏ lưu trữ có kiểu <code>unsigned __int64</code>.</p>

<p><strong><em>Kiểu dữ liệu của con trỏ không mô tả giá trị địa chỉ được lưu trữ bên trong con trỏ, mà kiểu dữ liệu của con trỏ dùng để xác định kiểu dữ liệu của biến mà nó trỏ đến trên bộ nhớ ảo.</em></strong></p>

<p>Vậy tại sao lại cần 4 bytes cho một con trỏ trong hệ điều hành 32 bits, và cần 8 bytes cho một con trỏ trong hệ điều hành 64 bits?</p>

<p>Phạm vi giá trị của <code>unsigned __int32</code> là từ 0 đến 4294967295, phạm vi giá trị này đủ để đánh dấu địa chỉ tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>32 bits</strong>. Tương tự, phạm vi giá trị của <code>unsigned __int64</code> là tử 0 đến 18446744073709551615, đủ để đánh dấu địa chỉ của tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>64 bits</strong>.</p>

<p>Dưới đây là thông tin Virtual memory trên máy tính của mình:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/virtual_memory.png?raw=true" width="354" height="465"></p>

<p>Dung lượng bộ nhớ ảo hiện tại của máy mình là <strong>1960MB</strong>, tương đương với <strong>2055208960 bytes</strong>. Trong khi đó, con trỏ trong nền tảng hệ điều hành <strong>32 bits</strong> có kích thước <strong>4 bytes</strong>, giá trị địa chỉ lớn nhất mà con trỏ <strong>4 bytes</strong> có thể lưu trữ được là <strong>4294967295</strong>, nên nó đủ để lưu trữ bất kì địa chỉ của biến nào được cấp phát trên bộ nhớ ảo.</p>

<h5>Gán giá trị cho con trỏ</h5>

<p>Giá trị mà biến con trỏ lưu trữ là địa chỉ của biến khác có cùng kiểu dữ liệu với biến con trỏ.</p>

<pre><code>int *ptr;
int value = 5;

ptr = &amp;value;</code></pre>

<p>Do đó, chúng ta cần sử dụng <strong>address-of operator</strong> để lấy ra địa chỉ ảo của biến rồi mới gán cho con trỏ được. Lúc này, biến ptr sẽ lưu trữ địa chỉ ảo của biến value.</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/7.png?raw=true" width="409" height="145"></p>

<p>(Nguồn: <a href="http://www.learncpp.com" rel="nofollow">www.learncpp.com</a>)</p>

<p>Chúng ta có thể nói rằng con trỏ <strong>ptr</strong> đang nắm giữ địa chỉ của biến <strong>value</strong>, cũng có thể nói con trỏ <strong>ptr</strong> trỏ đến biến <strong>value</strong>.</p>

<p>Đoạn chương trình sau sẽ in ra địa chỉ của biến value và giá trị được lưu bởi con trỏ ptr sau khi trỏ đến biến value:</p>

<pre><code>int main()
{
	int value = 5;
	int *ptr = &amp;value;
	
	cout &lt;&lt; &amp;value &lt;&lt; endl;
	cout &lt;&lt; ptr &lt;&lt; endl;

	system("pause");
	return 0;
}</code></pre>

<p>Kết quả thu được trên màn hình console:</p>

<pre><code>0012FF7C
0012FF7C</code></pre>

<p>Lý do mà chúng ta gán được địa chỉ của biến <strong>value</strong> cho con trỏ kiểu <strong>int</strong> (int *) là vì <strong>address-of operator</strong> của một biến kiểu <strong>int</strong> trả về giá trị kiểu con trỏ kiểu <strong>int</strong> (int *).</p>

<p>Thử xem xét đoạn chương trình sau:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
	
	int value = 5;
	cout &lt;&lt; typeid(&amp;value).name() &lt;&lt; endl;
	
	system("pause");
	return 0;
}</code></pre>

<p>Kết quả in ra màn hình của toán tử lấy địa chỉ ở trên là:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/8.png?raw=true" width="677" height="343"></p>

<p>Do đó, chúng ta có thể gán <code>&amp;value</code> cho con trỏ kiểu <strong>int</strong> (int *).</p>

<p>Bên cạnh đó, khi có hai con trỏ cùng kiểu thì chúng ta có thể gán trực tiếp mà không cần sử dụng <strong>address-of operator</strong>.</p>

<pre><code>int main()
{
	int value = 5;
	int *ptr1, *ptr2;

	ptr1 = &amp;value; //ptr1 point to value
	ptr2 = ptr1;   //assign value of ptr1 to ptr2

	cout &lt;&lt; ptr1 &lt;&lt; endl;
	cout &lt;&lt; ptr2 &lt;&lt; endl;

	system("pause");
	return 0;
}</code></pre>

<p>Lúc này, <strong>ptr1</strong> và <strong>ptr2</strong> cùng giữ địa chỉ của biến <strong>value</strong>.</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/9.png?raw=true" width="677" height="343"></p>

<p><strong><em>Khác với tham chiếu (reference), một con trỏ có thể trỏ đến địa chỉ khác trong bộ nhớ ảo sau khi đã được gán giá trị. Tham chiếu (reference) không thể thay đổi địa chỉ sau lần tham chiếu đầu tiên.</em></strong></p>

<p>Ví dụ:</p>

<pre><code>int main()
{
	int *ptr;

	int arr[5] = { 1, 2, 3, 4, 5 };

	for(int i = 0; i &lt; 5; i++)
	{
		ptr = &amp;arr[i];
		cout &lt;&lt; ptr &lt;&lt; endl;
	}

	system("pause");
	return 0;
}</code></pre>

<p>Kết quả của đoạn chương trình này là:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/10.png?raw=true" width="677" height="343"></p>

<p>Con trỏ <strong>ptr</strong> đã trỏ đến lần lượt 5 phần tử của mảng <strong>arr</strong>. Nếu các bạn để ý sẽ thấy 5 địa chỉ này liên tiếp nhau trên bộ nhớ ảo. Mình sẽ trình bày vấn đề này trong các bài học sau.</p>

<h5>Các phép gán không hợp lệ khi sử dụng con trỏ</h5>

<p>Phép gán của con trỏ chỉ thực hiện được khi kiểu dữ liệu của con trỏ phù hợp kiểu dữ liệu của biến mà nó sẽ trỏ tới. Do đó, các phép gán dưới đây là không hợp lệ:</p>

<pre><code>int iValue = 0;
float fValue = 0.0;

int *i_ptr = fValue;   //wrong! int pointer cannot point to the address of a double variable
float *f_ptr = iValue; //wrong! float pointer cannot point to the address of an int variable</code></pre>

<p>Mặc dù giá trị mà con trỏ lưu trữ có kiểu <strong>unsigned int</strong>, nhưng chúng ta không thể gán trực tiếp một giá trị địa chỉ cho con trỏ được.</p>

<pre><code>int *ptr = 1245052; //wrong!</code></pre>

<p>Giá trị 1245052 không có địa chỉ cụ thể, trong khi đó, con trỏ chỉ nhận giá trị là địa chỉ nên phép gán trên là sai. Mặc dù giá trị được chuyển về dạng cơ số thập lục phân để tương xứng với định dạng giá trị mà con trỏ in ra, điều này cũng không được cho phép.</p>

<pre><code>int *ptr = 0012FF7C; //wrong!</code></pre>

<p><strong><em>Chỉ có giá trị kiểu con trỏ (có được nhờ toán tử address-of, hoặc từ một biến con trỏ cùng kiểu khác) mới có thể gán được cho biến con trỏ.</em></strong></p>

<h5>Truy xuất giá trị bên trong vùng nhớ mà con trỏ trỏ đến</h5>

<p>Khi chúng ta có một con trỏ đã được trỏ đến địa chỉ nào đó trong bộ nhớ ảo, chúng ta có thể truy xuất giá trị tại địa chỉ đó bằng <strong>dereference operator</strong>. <strong>Dereference operator</strong> sẽ đánh giá nội dung địa chỉ được trỏ đến.</p>

<pre><code>int *ptr; //declare an int pointer
int value = 5;

ptr = &amp;value; //ptr point to value

cout &lt;&lt; &amp;value &lt;&lt; endl; //print the address of value
cout &lt;&lt; ptr &lt;&lt; endl;    //print the address of value which is held in ptr

cout &lt;&lt; value &lt;&lt; endl;  //print the content of value
cout &lt;&lt; *(&amp;value) &lt;&lt; endl; //print the content of value
cout &lt;&lt; *ptr &lt;&lt; endl;	//print the content of value</code></pre>

<p>Kết quả của đoạn chương trình trên như sau:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/11.png?raw=true" width="677" height="343"></p>

<p>Toán tử trỏ đến (<strong>dereference operator</strong>) được dùng để truy cập trực tiếp vào vùng nhớ có địa chỉ cụ thể trên bộ nhớ ảo (<strong>virtual memory</strong>), vì biến con trỏ <strong>ptr</strong> đang giữ địa chỉ của biến <strong>value</strong> nên khi đặt toán tử trỏ đến (<strong>dereference operator</strong>) trước con trỏ <strong>ptr</strong>, nó sẽ truy xuất giá trị tại địa chỉ mà con trỏ <strong>ptr</strong> đang giữ.</p>

<p>Vì <strong>ptr</strong> có kiểu dữ liệu <strong>con trỏ int</strong> (int *), <strong>ptr</strong> chỉ có thể trỏ đến biến kiểu <strong>int</strong>. Lúc này, <strong>compiler</strong> hiểu rằng cần phân tích <strong>4 bytes</strong> (đúng bằng kích thước kiểu <strong>int</strong>) trên bộ nhớ ảo tại địa chỉ mà <strong>ptr</strong> đang lưu trữ.</p>

<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true" class="lightbox" title="12.png?raw=true" rel="nofollow"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true" width="690" height="328"><div class="meta">
<span class="filename">12.png?raw=true</span><span class="informations">764x364</span><span class="expand"></span>
</div></a></div></p>

<p>Đây là lý do tại sao chúng ta cần khai báo kiểu dữ liệu của con trỏ. Nếu không khai báo kiểu dữ liệu cho con trỏ, toán tử trỏ đến (<strong>dereference operator</strong>) sẽ không biết phải phân tích bao nhiêu bytes tại địa chỉ con trỏ trỏ đến để tính toán được giá trị của vùng nhớ đó. Không những thế, đây còn là lý do kiểu dữ liệu của biến phải tương xứng với kiểu dữ liệu được khai báo cho con trỏ.</p>

<p>Vì chúng ta có thể gán lại địa chỉ mới cho một con trỏ, nên chúng ta có thể truy xuất được giá trị của nhiều vùng nhớ khác nhau chỉ với một con trỏ:</p>

<pre><code>int value1 = 1;
int value2 = 2;

int *ptr = &amp;value1;
cout &lt;&lt; *ptr &lt;&lt; endl;

ptr = &amp;value2;
cout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>

<p>Với khả năng truy cập đến vùng nhớ có địa chỉ cụ thể và thay đổi giá trị bên trong vùng nhớ của toán tử trỏ đến (<strong>dereference operator</strong>), chúng ta có thể sử dụng như sau:</p>

<pre><code>int value = 5;
int *ptr = &amp;value;

*ptr = 10;
cout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>

<p>Đoạn chương trình này sẽ in ra giá trị <strong>10</strong>.</p>

<p>Có thể giải thích dòng lệnh <code>*ptr = 10;</code> như sau:</p>

<p>Biến con trỏ <strong>ptr</strong> sau khi khai báo đã được khởi tạo bằng cách gán địa chỉ của biến <strong>value</strong>. Sử dụng <strong>dereference operator</strong> cho con trỏ <strong>ptr</strong> để truy cập đến địa chỉ ảo mà <strong>ptr</strong> đang nắm giữ, gán giá trị 10 vào vùng nhớ tại vị trí đó.</p>

<h5>Con trỏ chưa được gán địa chỉ</h5>

<p>Con trỏ trong ngôn ngữ C/C++ vốn không an toàn. Nếu sử dụng con trỏ không hợp lý có thể gây crash chương trình.</p>

<p>Khác với tham chiếu (<strong>reference</strong>), biến con trỏ có thể không cần khởi tạo giá trị ngay khi khai báo. Nhưng thực hiện truy xuất giá trị của con trỏ bằng dereference operator khi chưa gán địa chỉ cụ thể cho con trỏ, chương trình có thể bị đóng bởi hệ điều hành. Nguyên nhân là do con trỏ đang nắm giữ một giá trị rác, giá trị rác đó có thể là địa chỉ thuộc một vùng nhớ đang được ứng dụng khác sử dụng, hoặc giá trị vượt quá giới hạn của bộ nhớ ảo.</p>

<p>Trong chế độ <strong>Debug</strong> của Visual studio 2015, trường hợp này sẽ bị cảnh báo và ngăn chặn chương trình thực thi.</p>

<p>Ví dụ:</p>

<pre><code>int main()
{
	int *ptr; //declare an int pointer
	cout &lt;&lt; *ptr &lt;&lt; endl;

	system("pause");
	return 0;
}</code></pre>

<p>Nhấn F5 để Debug chương trình sẽ nhận được thông báo:</p>

<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/13.png?raw=true" width="559" height="318"></p>

<p>Do đó, khi khai báo con trỏ nhưng chưa có địa chỉ khởi tạo cụ thể, chúng ta nên gán cho con trỏ giá trị <strong>NULL</strong>.</p>

<hr>

<h3>NULL</h3>

<p><strong>NULL</strong> là một macro đã được định nghĩa sẵn trong ngôn ngữ C/C++.</p>

<pre><code>#define NULL 0</code></pre>

<p>Đối với con trỏ, <strong>NULL</strong> là một giá trị đặc biệt, khi gán <strong>NULL</strong> cho con trỏ, điều đó có nghĩa là con trỏ đó chưa trỏ đến địa chỉ nào cả. Con trỏ đang giữ giá trị <strong>NULL</strong> được gọi là con trỏ <strong>NULL</strong> (<strong>NULL pointer</strong>).</p>

<pre><code>int *ptr = NULL; //ptr is now a NULL pointer</code></pre>

<p>Lúc này, chúng ta có thể kiểm tra xem con trỏ đã được gán địa chỉ cụ thể hay chưa:</p>

<pre><code>int *ptr = NULL;

if(ptr == NULL)
{
	cout &lt;&lt; "Do nothing" &lt;&lt; endl;
}
else
{
	cout &lt;&lt; *ptr &lt;&lt; endl;
}</code></pre>

<p>Đoạn chương trình này sẽ giúp chương trình đảm bảo rằng con trỏ <strong>ptr</strong> sẽ không được sử dụng khi chưa được gán địa chỉ cụ thể.</p>

<p>Chuẩn <strong>C++11</strong> cung cấp cho chúng ta từ khóa <strong>nullptr</strong> tương tự như macro <strong>NULL</strong>. Chúng ta có thể sử dụng như sau:</p>

<pre><code>int *ptr = nullptr;</code></pre>

<p>Bên cạnh đó, <strong>C++11</strong> còn định nghĩa cho chúng ta kiểu dữ liệu <code>std::nullptr_t</code>, <code>nullptr_t</code> chỉ có thể lưu trữ giá trị <strong>nullptr</strong>. Nhưng chúng ta ít khi sử dụng kiểu dữ liệu này nên các bạn cũng không cần quan tâm lắm.</p>

<hr>

<h3>Tổng kết</h3>

<p>Trong bài học này, các bạn đã được tìm hiểu khái niệm con trỏ và một số khái niệm có liên quan. Việc sử dụng con trỏ thường có một số hoạt động chủ yếu: <strong>(a) khai báo một con trỏ, (b) gán địa chỉ cho con trỏ, (c) truy cập đến địa chỉ mà con trỏ đang nắm giữ bằng dereference operator</strong>.</p>

<p>Thử liên hệ một chút với cuộc sống thực tế, tưởng tượng rằng con đường nhà bạn (street) là bộ nhớ ảo, trên con đường đó có rất nhiều ngôi nhà (house), mỗi ngôi nhà đều được đánh số thứ tự gọi là địa chỉ nhà (house's address). Chúng ta tạm hình dung số người ở trong mỗi ngôi nhà (content) tương đương với nội dung của mỗi ô trên bộ nhớ ảo. Như vậy, address-of operator (&amp;house) sẽ trả về địa chỉ của ngôi nhà, dereference operator (*&amp;house) sẽ lấy ra số lượng người bên trong ngôi nhà có địa chỉ được xác định. Để sử dụng con trỏ trỏ đến mỗi ngôi nhà, chúng ta phải sử dụng một con trỏ kiểu <strong>House</strong> (giống với kiểu của từng ngôi nhà), giả sử con trỏ kiểu <strong>House</strong> được khai báo là <code>House *h_ptr;</code> thì con trỏ <code>h_ptr</code> có thể trỏ đến bất kì ngôi nhà nào trên con đường, và nó còn có thể thay đổi nội dung bên trong từng ngôi nhà mà nó trỏ đến.</p>

<p>Con trỏ (<strong>Pointer</strong>) là một công cụ mạnh mẽ đặc trưng của ngôn ngữ C/C++. Con trỏ cho phép chúng ta trực tiếp quản lý dung lượng của chương trình trên bộ nhớ ảo. Nhưng bên cạnh đó, việc sử dụng con trỏ không hợp lý có thể gây lãng phí tài nguyên của hệ thống máy tính. Chúng ta sẽ cùng tìm hiểu các kĩ thuật quản lý bộ nhớ ảo của chương trình trong các bài học tiếp theo.</p>

<hr>

<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>

<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>

<p><a title="DayNhauHoc" class="onebox" target="_blank">www.daynhauhoc.com</a></p>

<hr>

<h3>Link Videos khóa học</h3>

<p><a href="https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview" class="onebox" target="_blank" rel="nofollow">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>
</div></div></article></div></div></div><div class="_30zqN _1M-6l _7YJ7M" data-reactid="17"><div style="position:relative;overflow:hidden;width:100%;height:100%;" data-reactid="18"><div style="position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;-webkit-overflow-scrolling:touch;margin-right:0;margin-bottom:0;" data-reactid="19"><ul style="list-style:none;background-color:transparent;margin:0;padding:0;color:#242a31;font-family:lucida grande ,tahoma,verdana,arial,sans-serif;font-size:14px;" data-reactid="20"><li style="position:relative;" data-reactid="21"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="22"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="23"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="24"><svg height="14" width="14" data-reactid="25"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="26"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="27"><div style="line-height:24px;vertical-align:middle;font-size:1.5em;font-weight:300;font-family:Source Sans Pro,sans-serif;margin-bottom:1em;" data-reactid="28">Khóa học C++</div></div></div><span data-reactid="29"><ul style="list-style:none;padding-left:19px;" data-reactid="30"><li style="position:relative;" data-reactid="31"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="32"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="33"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="34"><svg height="14" width="14" data-reactid="35"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="36"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="37"><div style="line-height:24px;vertical-align:middle;" data-reactid="38">Giới thiệu tổng quan khóa học</div></div></div><span data-reactid="39"></span></li><li style="position:relative;" data-reactid="40"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="41"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="42"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="43"><svg height="14" width="14" data-reactid="44"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="45"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="46"><div style="line-height:24px;vertical-align:middle;" data-reactid="47">C++ cơ bản</div></div></div><span data-reactid="48"></span></li><li style="position:relative;" data-reactid="49"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="50"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="51"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="52"><svg height="14" width="14" data-reactid="53"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="54"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="55"><div style="line-height:24px;vertical-align:middle;" data-reactid="56">Cấu trúc rẽ nhánh</div></div></div><span data-reactid="57"></span></li><li style="position:relative;" data-reactid="58"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="59"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="60"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="61"><svg height="14" width="14" data-reactid="62"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="63"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="64"><div style="line-height:24px;vertical-align:middle;" data-reactid="65">Cấu trúc vòng lặp</div></div></div><span data-reactid="66"></span></li><li style="position:relative;" data-reactid="67"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="68"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="69"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="70"><svg height="14" width="14" data-reactid="71"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="72"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="73"><div style="line-height:24px;vertical-align:middle;" data-reactid="74">Nâng cao về biến, kiểu dữ liệu</div></div></div><span data-reactid="75"></span></li><li style="position:relative;" data-reactid="76"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="77"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="78"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="79"><svg height="14" width="14" data-reactid="80"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="81"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="82"><div style="line-height:24px;vertical-align:middle;" data-reactid="83">Kiểu dữ liệu mảng</div></div></div><span data-reactid="84"></span></li><li style="position:relative;" data-reactid="85"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="86"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="87"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="88"><svg height="14" width="14" data-reactid="89"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="90"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="91"><div style="line-height:24px;vertical-align:middle;" data-reactid="92">Kiểu chuỗi kí tự</div></div></div><span data-reactid="93"></span></li><li style="position:relative;" data-reactid="94"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="95"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="96"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="97"><svg height="14" width="14" data-reactid="98"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="99"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="100"><div style="line-height:24px;vertical-align:middle;" data-reactid="101">Cơ bản về Function</div></div></div><span data-reactid="102"></span></li><li style="position:relative;" data-reactid="103"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="104"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="105"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="106"><svg height="14" width="14" data-reactid="107"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="108"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="109"><div style="line-height:24px;vertical-align:middle;" data-reactid="110">Con trỏ</div></div></div><span data-reactid="111"></span></li><li style="position:relative;" data-reactid="112"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="113"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="114"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="115"><svg height="14" width="14" data-reactid="116"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="117"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="118"><div style="line-height:24px;vertical-align:middle;" data-reactid="119">Kiểu dữ liệu tự định nghĩa</div></div></div><span data-reactid="120"></span></li><li style="position:relative;" data-reactid="121"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="122"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="123"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="124"><svg height="14" width="14" data-reactid="125"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="126"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="127"><div style="line-height:24px;vertical-align:middle;" data-reactid="128">Nhập, xuất (Input &amp; Output)</div></div></div><span data-reactid="129"></span></li><li style="position:relative;" data-reactid="130"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="131"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="132"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="133"><svg height="14" width="14" data-reactid="134"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="135"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="136"><div style="line-height:24px;vertical-align:middle;" data-reactid="137">Một số thư viện thường dùng trong STL</div></div></div><span data-reactid="138"></span></li><li style="position:relative;" data-reactid="139"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="140"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="141"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="142"><svg height="14" width="14" data-reactid="143"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="144"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="145"><div style="line-height:24px;vertical-align:middle;" data-reactid="146">Auto pointer</div></div></div><span data-reactid="147"></span></li><li style="position:relative;" data-reactid="148"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="149"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="150"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="151"><svg height="14" width="14" data-reactid="152"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="153"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="154"><div style="line-height:24px;vertical-align:middle;" data-reactid="155">Quản lý mã nguồn</div></div></div><span data-reactid="156"></span></li><li style="position:relative;" data-reactid="157"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="158"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="159"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="160"><svg height="14" width="14" data-reactid="161"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="162"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="163"><div style="line-height:24px;vertical-align:middle;" data-reactid="164">Một số feature trong C++11, C++14</div></div></div><span data-reactid="165"></span></li></ul></span></li></ul></div><div style="position:absolute;height:6px;display:none;right:2px;bottom:2px;left:2px;border-radius:3px;" data-reactid="166"><div style="position:relative;display:block;height:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="167"></div></div><div style="position:absolute;width:6px;display:none;right:2px;bottom:2px;top:2px;border-radius:3px;" data-reactid="168"><div style="position:relative;display:block;width:100%;cursor:pointer;border-radius:inherit;background-color:rgba(0,0,0,.2);" data-reactid="169"></div></div></div></div><div class="_3eRtW _1tTpi" data-reactid="170"><span class="SVGInline" data-reactid="171"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 396.667 396.667" style="enable-background:new 0 0 396.667 396.667;" xml:space="preserve">
<g>
	<g>
		<path d="M17,87.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17C0,80.183,7.65,87.833,17,87.833z"/>
		<path d="M17,215.333h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,215.333,17,215.333z"/>
		<path d="M17,342.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,342.833,17,342.833z"/>
	</g>
</g>
</svg></span></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"title":"Cài đặt Code::blocks để lập trình C++ trên Ubuntu/Linux","route":"0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux","description":"int main() {   std::cout &lt;&lt; \"Hello World!\"; }","__filename":"generated/24563.md","__url":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/","__resourceUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html","__dataUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html.d7146b8f6b06f293bfd7d7072595786f.json"},{"title":"Cài đặt Xcode để lập trình C++ trên Mac OS X","route":"0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x","description":"int main() {     std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;     return 0; }","__filename":"generated/24606.md","__url":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/","__resourceUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html","__dataUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html.b267f6bba27c47a6fd8837792aa9ed05.json"},{"title":"Cài đặt Visual Studio 2015 để lập trình C++ trên Windows","route":"0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows","description":"","__filename":"generated/24768.md","__url":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/","__resourceUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html","__dataUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html.acf989adbfe293778195699d01ad0f77.json"},{"title":"0.0 Giới thiệu về series tutorial","route":"0/0-gioi-thieu-ve-series-tutorial","description":"Tóm tắt về bản thân  Minh tên Lê Trần Đạt, 28 tuổi, là lập trình viên lập trình nhúng, ngoài làm việc mình thích dạy học online và viết. Tự…","__filename":"generated/29402.md","__url":"/0/0-gioi-thieu-ve-series-tutorial/","__resourceUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html","__dataUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html.b3a9c7a55cfe71fb06282d41eb35a19e.json"},{"title":"0.1 Giới thiệu về ngôn ngữ lập trình","route":"0/1-gioi-thieu-ve-ngon-ngu-lap-trinh","description":"","__filename":"generated/29425.md","__url":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/","__resourceUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html","__dataUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html.ee05b7a2f09ce56983fe6ecdb5e2cae1.json"},{"title":"0.2 Giới thiệu về ngôn ngữ lập trình C++","route":"0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c","description":"","__filename":"generated/29448.md","__url":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/","__resourceUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html","__dataUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html.eb8440bdc067f39ed5ed01dcb67ec011.json"},{"title":"0.3 Các công đoạn phát triển của một chương trình C++","route":"0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c","description":"","__filename":"generated/29449.md","__url":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/","__resourceUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html.985676c594c63a65a27c349d01aba1c2.json"},{"title":"0.4 Giới thiệu môi trường phát triển ứng dụng C++","route":"0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c","description":"","__filename":"generated/29503.md","__url":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/","__resourceUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html","__dataUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html.4d09242acbe8c00d559a65dfa4e010c8.json"},{"title":"1.0 Viết chương trình đầu tiên","route":"1/0-viet-chuong-trinh-dau-tien","description":"Các bạn sẽ thấy nhiều hàm main có cách khai báo khác nhau. Nhưng với việc bạn là người mới bắt đầu học…","__filename":"generated/29504.md","__url":"/1/0-viet-chuong-trinh-dau-tien/","__resourceUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html","__dataUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html.6d8bc2f6cad6284e8e2fd1bef2562ea3.json"},{"title":"1.1 Cấu trúc cơ bản của một chương trình C++","route":"1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c","description":"\\#include &lt;iostream> using namespace std; int main()\t{ \t// We write some code inside main function. } } / We can put…","__filename":"generated/29527.md","__url":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/","__resourceUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html.1754c050053054d0d4962d6ed4069bcc.json"},{"title":"1.10 Độ ưu tiên của các toán tử","route":"1/10-do-uu-tien-cua-cac-toan-tu","description":"","__filename":"generated/29574.md","__url":"/1/10-do-uu-tien-cua-cac-toan-tu/","__resourceUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html","__dataUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html.2ed2467f55ba1f9faebf54445fa0e702.json"},{"title":"1.2 Lệnh, khối lệnh, từ khóa","route":"1/2-lenh-khoi-lenh-tu-khoa","description":"Những dòng lệnh bên trong thân hàm main. (Có thể có hoặc không) Những dòng comment. (Có thể có hoặc không) Tích hợp thư viện và không gian…","__filename":"generated/29575.md","__url":"/1/2-lenh-khoi-lenh-tu-khoa/","__resourceUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html","__dataUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html.bf958184eaea47730791808e2dc576df.json"},{"title":"1.3 Sử dụng các lệnh liên quan đến xuất dữ liệu","route":"1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu","description":"","__filename":"generated/29796.md","__url":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/","__resourceUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html","__dataUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html.764e0a3a06f81e99ab53a9ab17e892f9.json"},{"title":"1.4 Biến và các kiểu dữ liệu trong C++","route":"1/4-bien-va-cac-kieu-du-lieu-trong-c","description":"float valueFloat = 5.394; // (2) Xin hệ điều hành thêm một vùng nhớ để chứa 1 số thực string myName = \"Minh Vu\"; // (3) Biến này chứa được…","__filename":"generated/29935.md","__url":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/","__resourceUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html","__dataUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html.dffc5fbfdf664d44b3b28b7905117ee5.json"},{"title":"1.5 Nhập và xuất dữ liệu","route":"1/5-nhap-va-xuat-du-lieu","description":"","__filename":"generated/29936.md","__url":"/1/5-nhap-va-xuat-du-lieu/","__resourceUrl":"/1/5-nhap-va-xuat-du-lieu/index.html","__dataUrl":"/1/5-nhap-va-xuat-du-lieu/index.html.c56c9c3f92a8e8db1438ddde847a2a16.json"},{"title":"1.6 Hằng số","route":"1/6-hang-so","description":"","__filename":"generated/29938.md","__url":"/1/6-hang-so/","__resourceUrl":"/1/6-hang-so/index.html","__dataUrl":"/1/6-hang-so/index.html.a053963fb53e3188dd8ab0c9dac43085.json"},{"title":"1.7 Phạm vi của biến","route":"1/7-pham-vi-cua-bien","description":"int value = 1; int main()\t{ }","__filename":"generated/29939.md","__url":"/1/7-pham-vi-cua-bien/","__resourceUrl":"/1/7-pham-vi-cua-bien/index.html","__dataUrl":"/1/7-pham-vi-cua-bien/index.html.64607a2e78fc6b0159cfb3975ff151d6.json"},{"title":"1.8 Các phép toán cơ bản","route":"1/8-cac-phep-toan-co-ban","description":"int another_variable = 3; variable = another_variable \\* 2; variable = variable + 1; //tăng giá trị biến variable lên…","__filename":"generated/29944.md","__url":"/1/8-cac-phep-toan-co-ban/","__resourceUrl":"/1/8-cac-phep-toan-co-ban/index.html","__dataUrl":"/1/8-cac-phep-toan-co-ban/index.html.66e87835a401bc447f8384e79b564131.json"},{"title":"1.9 Toán tử tăng giảm","route":"1/9-toan-tu-tang-giam","description":"","__filename":"generated/29945.md","__url":"/1/9-toan-tu-tang-giam/","__resourceUrl":"/1/9-toan-tu-tang-giam/index.html","__dataUrl":"/1/9-toan-tu-tang-giam/index.html.abef97628c0b0b73bcc4d77d8d04b434.json"},{"title":"2.0 Boolean","route":"2/0-boolean","description":"int a = 2, b = 4; a \\* 3 != b; //đúng int main() { \tcout &lt;&lt; true &lt;&lt; endl; \tcout &lt;&lt; false &lt;&lt; endl; } int main…","__filename":"generated/29992.md","__url":"/2/0-boolean/","__resourceUrl":"/2/0-boolean/index.html","__dataUrl":"/2/0-boolean/index.html.68ed7d7b73e2f995c30477ffd2450120.json"},{"title":"2.1 Giới thiệu một số cấu trúc điều khiển","route":"2/1-gioi-thieu-mot-so-cau-truc-dieu-khien","description":"int main() { \tcout &lt;&lt; \"This line is printed out.\" &lt;&lt; endl; \texit(-1); //Terminate and return -1 to operating system.  \tcout &lt…","__filename":"generated/30007.md","__url":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/","__resourceUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html","__dataUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html.f922a5691cd782f11d83854853313a15.json"},{"title":"2.2 if statements","route":"2/2-if-statements","description":"} } if(value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; } if (value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl…","__filename":"generated/30008.md","__url":"/2/2-if-statements/","__resourceUrl":"/2/2-if-statements/index.html","__dataUrl":"/2/2-if-statements/index.html.7b04da482f36108555912c4dc0604cc1.json"},{"title":"2.3 switch case statements","route":"2/3-switch-case-statements","description":"} }","__filename":"generated/30009.md","__url":"/2/3-switch-case-statements/","__resourceUrl":"/2/3-switch-case-statements/index.html","__dataUrl":"/2/3-switch-case-statements/index.html.9fe094b93c2d8db3141fd46d847d467c.json"},{"title":"3.0 Vòng lặp while","route":"3/0-vong-lap-while","description":"} while (score &lt; 4) { \tcount++; \tcout &lt;&lt; \"Learn C++ programming language...\" &lt;&lt; endl; \tcout &lt;&lt; \"Enter your final score…","__filename":"generated/30011.md","__url":"/3/0-vong-lap-while/","__resourceUrl":"/3/0-vong-lap-while/index.html","__dataUrl":"/3/0-vong-lap-while/index.html.8611da6a5d3acd3ba1b3db2bccd4ded2.json"},{"title":"3.1 Vòng lặp do-while","route":"3/1-vong-lap-do-while","description":"} const int ID = 123; const int password = 123456; int main() { \t//................. }","__filename":"generated/30012.md","__url":"/3/1-vong-lap-do-while/","__resourceUrl":"/3/1-vong-lap-do-while/index.html","__dataUrl":"/3/1-vong-lap-do-while/index.html.8118d8e5f576f351b305bd20ccff339a.json"},{"title":"3.2 Vòng lặp for","route":"3/2-vong-lap-for","description":"}","__filename":"generated/30013.md","__url":"/3/2-vong-lap-for/","__resourceUrl":"/3/2-vong-lap-for/index.html","__dataUrl":"/3/2-vong-lap-for/index.html.d9f9bf135a584e44a623c43dc2a1d4b7.json"},{"title":"3.3 từ khóa break và continue","route":"3/3-tu-khoa-break-va-continue","description":"} } }","__filename":"generated/30014.md","__url":"/3/3-tu-khoa-break-va-continue/","__resourceUrl":"/3/3-tu-khoa-break-va-continue/index.html","__dataUrl":"/3/3-tu-khoa-break-va-continue/index.html.3b5d42b0f50995d27f54e8f8be5a4cc0.json"},{"title":"4.0 Sử dụng thư viện cstdint","route":"4/0-su-dung-thu-vien-cstdint","description":"int main()\t{ } //in ra kết quả là giá trị lớn nhất của 5 số vừa nhập //in ra kết quả là giá trị nhỏ nhất của 5 số vừa nhập int main…","__filename":"generated/30016.md","__url":"/4/0-su-dung-thu-vien-cstdint/","__resourceUrl":"/4/0-su-dung-thu-vien-cstdint/index.html","__dataUrl":"/4/0-su-dung-thu-vien-cstdint/index.html.aff7e4b68f74e27b2d9c9e8aabafb425.json"},{"title":"4.1 Kiểu kí tự","route":"4/1-kieu-ki-tu","description":"//check if there is any character exist in stdin file object if (!cin.eof())\t{ \tcout &lt;&lt; \"There are some character more in stdin file…","__filename":"generated/30018.md","__url":"/4/1-kieu-ki-tu/","__resourceUrl":"/4/1-kieu-ki-tu/index.html","__dataUrl":"/4/1-kieu-ki-tu/index.html.9982f009ee563c9838c9470e7bccce0d.json"},{"title":"4.2 Ép kiểu dữ liệu","route":"4/2-ep-kieu-du-lieu","description":"","__filename":"generated/30019.md","__url":"/4/2-ep-kieu-du-lieu/","__resourceUrl":"/4/2-ep-kieu-du-lieu/index.html","__dataUrl":"/4/2-ep-kieu-du-lieu/index.html.9093a9b251652c3f0d9c518a05058b3c.json"},{"title":"4.3 auto và decltype","route":"4/3-auto-va-decltype","description":"// compare the type of n with type int32_t if (typeid(int32_t) == typeid(n)) \tcout &lt;&lt; \"n is an object of type int32_t\" &lt;&lt; endl…","__filename":"generated/30020.md","__url":"/4/3-auto-va-decltype/","__resourceUrl":"/4/3-auto-va-decltype/index.html","__dataUrl":"/4/3-auto-va-decltype/index.html.6492a2c327eec109328a4f36f875b5ec.json"},{"title":"4.4 Địa chỉ của biến","route":"4/4-dia-chi-cua-bien","description":"cout &lt;&lt; \"Value of var: \" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; \"Value of var_reference: \" &lt;&lt; var_reference &lt;&lt; endl…","__filename":"generated/30022.md","__url":"/4/4-dia-chi-cua-bien/","__resourceUrl":"/4/4-dia-chi-cua-bien/index.html","__dataUrl":"/4/4-dia-chi-cua-bien/index.html.ec3e9179d8d83f7637aea29c682e42c9.json"},{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements &lt…","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.db023247931fdd0e22e4bdf7ad1c7ff1.json"},{"title":"5.1 Các thao tác cơ bản với mảng một chiều","route":"5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu","description":"int32_t arr[ARRAY_SIZE];\t int32_t arr_clone[ARRAY_SIZE]; } } int main() { \tchar ch_array\\[] = { 'L', 'e', 'T', 'r', 'a', 'n', 'D', 'a…","__filename":"generated/30082.md","__url":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/","__resourceUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html","__dataUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html.8a635c59a7efecc14b6166c240ef06ff.json"},{"title":"5.2 Thư viện array trong STL","route":"5/2-thu-vien-array-trong-stl","description":"//Access to all of elements of arr object for (int32_t index = 0; index &lt;= arr.size() - 1; index++) { \tcout &lt;&lt; arr[index] &lt;&lt…","__filename":"generated/30083.md","__url":"/5/2-thu-vien-array-trong-stl/","__resourceUrl":"/5/2-thu-vien-array-trong-stl/index.html","__dataUrl":"/5/2-thu-vien-array-trong-stl/index.html.4d2fcee9d1d839fa510361a92690a625.json"},{"title":"5.3 Mảng hai chiều","route":"5/3-mang-hai-chieu","description":"for(int row = 0; row &lt; 3; row++) { \tfor(int col = 0; col &lt; 4; col++) \t{ \t\tcout &lt;&lt; board[row][col] &lt;&lt; \" \"; \t} \tcout &lt;&lt…","__filename":"generated/30085.md","__url":"/5/3-mang-hai-chieu/","__resourceUrl":"/5/3-mang-hai-chieu/index.html","__dataUrl":"/5/3-mang-hai-chieu/index.html.b5c4d6bd648ebce96975afc0a540003c.json"},{"title":"5.4 Các thao tác cơ bản với mảng hai chiều","route":"5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu","description":"} }","__filename":"generated/30086.md","__url":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/","__resourceUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html","__dataUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html.6e869616a193f204da370ff6042afac3.json"},{"title":"6.0 Mảng kí tự","route":"6/0-mang-ki-tu","description":"cout &lt;&lt; \"Enter your full name: \"; cin >> full_name; cout &lt;&lt; \"Your full name is \" &lt;&lt; full_name &lt;&lt; endl; cout &lt…","__filename":"generated/30090.md","__url":"/6/0-mang-ki-tu/","__resourceUrl":"/6/0-mang-ki-tu/index.html","__dataUrl":"/6/0-mang-ki-tu/index.html.e00029e1f168f1d138caba46b0257e9f.json"},{"title":"6.1 Các thao tác cơ bản với mảng kí tự","route":"6/1-cac-thao-tac-co-ban-voi-mang-ki-tu","description":"memset(foo, '-', 7); cout &lt;&lt; foo &lt;&lt; endl; \\-------every programmer should know memset! strcpy(str_destination, str_source…","__filename":"generated/30091.md","__url":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/","__resourceUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html","__dataUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html.b7aa8fed8d72491d018cc1daa25b8509.json"},{"title":"6.2 Thư viện string trong C++","route":"6/2-thu-vien-string-trong-c","description":"//......... string my_string; string temp_string(\"What the hell is going on?\"); string one_more = temp_string; string it_just_began(temp…","__filename":"generated/30092.md","__url":"/6/2-thu-vien-string-trong-c/","__resourceUrl":"/6/2-thu-vien-string-trong-c/index.html","__dataUrl":"/6/2-thu-vien-string-trong-c/index.html.fa8f82230a15f56f06af44a5d465f939.json"},{"title":"7.0 Làm quen với khái niệm function","route":"7/0-lam-quen-voi-khai-niem-function","description":"if(strlen(str1) == strlen(str2))\t{ \t//do something } void introduce() { \tcout &lt;&lt; \"Hello!\" &lt;&lt; endl; \tcout &lt;&lt; \"I'm a…","__filename":"generated/30132.md","__url":"/7/0-lam-quen-voi-khai-niem-function/","__resourceUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html","__dataUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html.65f217e229d77ce8b2497175dceac24f.json"},{"title":"7.1 Thiết kế chương trình dựa trên khái niệm function","route":"7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function","description":"} } float subtraction(float value1, float value2) { \treturn value1 - value2; } float multiplication(float value1, float value2) { \treturn…","__filename":"generated/30133.md","__url":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/","__resourceUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html","__dataUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html.709c05b00b2bae84c7baad49de176dbd.json"},{"title":"7.2 Truyền đối số cho hàm là giá trị hoặc tham chiếu","route":"7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu","description":"} } int main() { \tint argument; \tcout &lt;&lt; \"Address of argument: \" &lt;&lt; &argument &lt;&lt; endl; \tprintAddressOfParameter(argument…","__filename":"generated/30319.md","__url":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html.9f6c74d5d714f90dd4eb8741c7848e47.json"},{"title":"7.3 Hàm trả về giá trị hoặc tham chiếu","route":"7/3-ham-tra-ve-gia-tri-hoac-tham-chieu","description":"// .............. // function call int result = doubleValue(10); // ................ // function call int & myRef = returnReference(); for…","__filename":"generated/30381.md","__url":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html.461ae9d757da250cc59984265501a866.json"},{"title":"7.4 Tham số mặc định, tham số hằng","route":"7/4-tham-so-mac-dinh-tham-so-hang","description":"int main() { \tstring non_const_msg = \"This is non-const message\"; \tconst string const_msg = \"This is const message\"; } int main() { }","__filename":"generated/30382.md","__url":"/7/4-tham-so-mac-dinh-tham-so-hang/","__resourceUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html","__dataUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html.9d8d265a84d637c3c05004f404728474.json"},{"title":"7.5 Function overloading","route":"7/5-function-overloading","description":"float addFloat(float f1, float f2) { \treturn f1 + f2; } float add(float f1, float f2) { \treturn f1 + f2; } print(0); print('a'); print…","__filename":"generated/30477.md","__url":"/7/5-function-overloading/","__resourceUrl":"/7/5-function-overloading/index.html","__dataUrl":"/7/5-function-overloading/index.html.2290b48f00a85929ef4aba00f5401e08.json"},{"title":"8.0 Con trỏ","route":"8/0-con-tr","description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt…","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.c96a1fa2938a6be431d4ca1446f891e1.json"},{"title":"8.1 Toán tử tăng, giảm dùng cho con trỏ","route":"8/1-toan-tu-tang-giam-dung-cho-con-tr","description":"cout &lt;&lt; \"Before decreased: \" &lt;&lt; ptr &lt;&lt; endl; ptr--; cout &lt;&lt; \" After decreased: \" &lt;&lt; ptr &lt;&lt; endl; cout…","__filename":"generated/30699.md","__url":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/","__resourceUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html","__dataUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html.b0629507a79bd1a3061af63f38b13ff9.json"},{"title":"8.2 Con trỏ và mảng một chiều","route":"8/2-con-tr-va-mang-mot-chieu","description":"//show address of the first element of arr cout &lt;&lt; &arr[0] &lt;&lt; endl; //show address of the first element of arr cout &lt;&lt…","__filename":"generated/30788.md","__url":"/8/2-con-tr-va-mang-mot-chieu/","__resourceUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html","__dataUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html.b5e8e82e62fce2b9e1353768b39948ca.json"},{"title":"8.3 Con trỏ và mảng kí tự","route":"8/3-con-tr-va-mang-ki-tu","description":"p_name[1] = 'E'; cout &lt;&lt; my_name &lt;&lt; endl; cout &lt;&lt; p_name &lt;&lt; endl; } \"Le Tran Dat\"[1] = 'E'; //this line will make…","__filename":"generated/30876.md","__url":"/8/3-con-tr-va-mang-ki-tu/","__resourceUrl":"/8/3-con-tr-va-mang-ki-tu/index.html","__dataUrl":"/8/3-con-tr-va-mang-ki-tu/index.html.5583c492247883ef973e567716a9ec31.json"},{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt…","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.eb83f8a3bbb96ccc9afb58a885bbae19.json"},{"title":"8.5 Con trỏ và hằng","route":"8/5-con-tr-va-hang","description":"int value1 = 5; ptr = &value1; int value2 = 10; ptr = &value2; &ptr = 10; //compile error int otherValue = 10; ptr = &otherValue…","__filename":"generated/31355.md","__url":"/8/5-con-tr-va-hang/","__resourceUrl":"/8/5-con-tr-va-hang/index.html","__dataUrl":"/8/5-con-tr-va-hang/index.html.db6a1713c09e060e1515fabd7a42c5d4.json"},{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int…","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.792da3c393bbac25881f92a268beee71.json"},{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl…","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.054dae5e872a1f2c75e3062bd577174a.json"},{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue…","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.bc2b8ac23d5e828477e2e837d3519fd7.json"},{"title":"8.10 Phân loại các vùng nhớ (stack & heap ...)","route":"8/10-phan-loai-cac-vung-nho-stack-va-heap","description":"","__filename":"generated/32101.md","__url":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/","__resourceUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html","__dataUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html.ee65b1f85a502eb43fca51c20ed8fb57.json"},{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int…","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.6e1574bcefc94d2d2e3a4ef309681497.json"},{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i…","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/8/7-con-tr-tr-den-con-tr/index.html.d07a86154a6961984bd2566d041f6e1e.json"},{"title":"9.0 Kiểu liệt kê (enum)","route":"9/0-kieu-liet-ke-enum","description":"enum Color { \tRED, \tGREEN, \tBLUE, \tWHITE }; enum Animal { \tCAT, \tDOG, \tHORSE, \tMONKEY, \tCHICKEN }; } int iValue = LETTER_A; cout &lt;&lt…","__filename":"generated/32760.md","__url":"/9/0-kieu-liet-ke-enum/","__resourceUrl":"/9/0-kieu-liet-ke-enum/index.html","__dataUrl":"/9/0-kieu-liet-ke-enum/index.html.860576a918a655f1f53e822bc51c8bf5.json"},{"title":"9.1 Structs","route":"9/1-structs","description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent…","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.3a2cb4930e4325d583c56db63e3817bf.json"},{"title":"9.2 Structs and pointer","route":"9/2-structs-and-pointer","description":"int main() { \tBankAccount myAccount = { 123456789, 50 }; // $50 \tBankAccount \\*pAccount = &myAccount;  } int main() { \tBankAccount…","__filename":"generated/33521.md","__url":"/9/2-structs-and-pointer/","__resourceUrl":"/9/2-structs-and-pointer/index.html","__dataUrl":"/9/2-structs-and-pointer/index.html.670178e35e40d08eb17402bbc3b5d4c3.json"},{"title":"Khóa học C++","description":"","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.6be0918faeb891a3ade9da07ef33c29b.json"}];window.__INITIAL_STATE__ = {"pages":{"/8/0-con-tr/":{"head":{"title":"8.0 Con trỏ","route":"8/0-con-tr","description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt…"},"body":"\n<h4>Chào các bạn học viên đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong chương này, chúng ta sẽ cùng nhau tìm hiểu về khái niệm con trỏ (<strong>Pointer</strong>) - một đặc trưng của ngôn ngữ lập trình C/C++.</p>\n\n<p>Trước khi vào bài học này, chúng ta cùng nhau xem lại một số khái niệm liên quan đến vùng nhớ, địa chỉ của biến, tham chiếu...</p>\n\n<h5>Variable</h5>\n\n<p>Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình C++ nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu.</p>\n\n<p>Khi thao tác với các biến thông thường, chúng ta không cần quan tâm đến địa chỉ vùng nhớ của biến. Khi cần truy xuất giá trị của biến, chúng ta chỉ cần gọi định danh (hay thường gọi là tên biến).</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int money;</code></pre>\n\n<p>Khi dòng lệnh này được CPU thực thi, một vùng nhớ có kích thước 4 bytes sẽ được cấp phát. Lấy ví dụ biến money này được đặt tại ô nhớ 1224 (trong địa chỉ ảo của máy tính).</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/0.png?raw=true\" width=\"400\" height=\"300\"></p>\n\n<p>Bất cứ khi nào chương trình thấy các bạn sử dụng biến money trong câu lệnh, chương trình hiểu rằng cần tìm đến ô nhớ 1224 để lấy giá trị đó ra.</p>\n\n<h5>Virtual memory &amp; Physical memory</h5>\n\n<p>Việc truy xuất dữ liệu trên bộ nhớ máy tính cần phải thông qua một số bước trung gian, người dùng không thể trực tiếp truy xuất vào các ô nhớ trên các thiết bị lưu trữ. Chúng ta chỉ có thể trỏ đến vùng nhớ ảo (virtual memory) trên máy tính, còn việc truy xuất đến bộ nhớ vật lý (physical memory) từ bộ nhớ ảo phải được thực hiện bởi thiết bị phần cứng có tên là <strong>Memory management unit (MMU)</strong> và một chương trình định vị địa chỉ bộ nhớ gọi là <strong>Virtual address space</strong>.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true\" width=\"690\" height=\"373\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">1045x566</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Virtual memory làm che giấu sự phân mảnh của bộ nhớ vật lý, khiến chúng ta có cảm giác đang thao tác với các vùng nhớ liên tục. Trong hình trên, từ phía Virtual memory cho đến Physical memory thuộc về phần quản lý của hệ điều hành, lập trình viên và người dùng chúng ta không thể can thiệp trực tiếp đến trong quá trình máy tính đang hoạt động.</p>\n\n<h5>Variable address &amp; address-of operator</h5>\n\n<p>Địa chỉ của biến mà chúng ta nhìn thấy thật ra chỉ là những giá trị đã được đánh số thứ tự đặt trên Virtual memory. Để lấy được địa chỉ ảo của biến trong chương trình, chúng ta sử dụng toán tử <strong>'&amp;'</strong> đặt trước tên biến.</p>\n\n<pre><code>int x = 5;\nstd::cout &lt;&lt; x &lt;&lt; '\\n'; // print the value of variable x\nstd::cout &lt;&lt; &amp;x &lt;&lt; '\\n'; // print the memory address of variable x</code></pre>\n\n<p>Trên máy tính của mình, kết quả của đoạn chương trình trên được in ra như sau:</p>\n\n<pre><code>5\n0027FEA0</code></pre>\n\n<p>Dòng đầu tiên là kết quả của việc truy xuất giá trị của biến thông qua định danh (tên biến). Dòng thứ hai là kết quả của việc truy xuất đến địa chỉ ảo của biến.</p>\n\n<h5>Tham chiếu (Reference)</h5>\n\n<p>Mục đích của tham chiếu trong C++ là tạo ra một biến khác có cùng kiểu dữ liệu nhưng sử dụng chung vùng nhớ với biến được tham chiếu đến.</p>\n\n<pre><code>int i1 = 10;\nint &amp;i_ref = i1;        //reference to i1, not means address of i1\n\ncout &lt;&lt; &amp;i1 &lt;&lt; endl;    //get address of i1\ncout &lt;&lt; &amp;i_ref &lt;&lt; endl; //get address of i_ref</code></pre>\n\n<p>Kết quả chúng ta được:</p>\n\n<pre><code>0xBFEB475C\n0xBFEB475C</code></pre>\n\n<p>Như vậy, mọi hành vi thay đổi giá trị của <code>i_ref</code> đều tác động trực tiếp đến <code>i1</code>.</p>\n\n<p><strong><em>Lưu ý: Biến tham chiếu sẽ có địa chỉ cố định sau khi khởi tạo. Chúng ta không thể tham chiếu lại lần nữa.</em></strong></p>\n\n<h5>Dereference operator</h5>\n\n<p>Toán tử trỏ đến (<strong>dereference operator</strong>) hay còn gọi là <strong>indirection operator</strong> (toán tử điều hành gián tiếp) được kí hiệu bằng dấu sao <strong>\" * \"</strong> cho phép chúng ta lấy ra giá trị của vùng nhớ có địa chỉ cụ thể.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int n = 5;\n\ncout &lt;&lt; n &lt;&lt; endl;     //print the value of variable n\ncout &lt;&lt; &amp;n &lt;&lt; endl;    //print the virtual memory address of variable n\ncout &lt;&lt; *(&amp;n) &lt;&lt; endl; //print the value at the virtual memory address of variable n</code></pre>\n\n<ul>\n<li><p>Dòng lệnh cout đầu tiên khá dễ hiểu, nó thực hiện in ra giá trị của biến n bằng cách gọi định danh n, còn lại phần truy xuất đến địa chỉ ảo của biến n sẽ do chương trình đảm nhiệm.</p></li>\n<li><p>Dòng lệnh cout thứ hai không dùng để lấy ra giá trị bên trong vùng nhớ mà biến n đang nắm giữ, mà nó lấy ra địa chỉ ảo của biến n.</p></li>\n<li><p>Dòng lệnh cout thứ ba chúng ta sử dụng toán tử trỏ đến <strong>\" * \"</strong> đặt trước toán tử <strong>address-of</strong>. Khi đó, <strong>(&amp;n)</strong> sẽ lấy ra địa chỉ ảo của biến n, và toán tử * sẽ truy xuất giá trị bên trong địa chỉ đó.</p></li>\n</ul>\n\n<p>Kết quả của đoạn chương trình trên là:</p>\n\n<pre><code>5\n0xBFD181AC\n5</code></pre>\n\n<p>Ngoài việc truy xuất giá trị trong vùng nhớ của một địa chỉ cụ thể, toán tử trỏ đến (<strong>dereference operator</strong>) còn có thể dùng để thay đổi giá trị bên trong vùng nhớ đó.</p>\n\n<pre><code>int n = 5;\ncout &lt;&lt; n &lt;&lt; endl;\n*(&amp;n) = 10;\ncout &lt;&lt; n &lt;&lt; endl;</code></pre>\n\n<p>Kết quả đoạn chương trình này là:</p>\n\n<pre><code>5\n10</code></pre>\n\n<p>Như vậy, <strong>dereference operator</strong> cho phép chúng ta thao tác trực tiếp trên <strong>Virtual memory</strong> mà không cần thông qua định danh (tên biến).</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true\" class=\"lightbox\" title=\"2.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true\" width=\"690\" height=\"430\"><div class=\"meta\">\n<span class=\"filename\">2.png?raw=true</span><span class=\"informations\">786x490</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Mặc dù <strong>dereference operator</strong> có kí hiệu giống <strong>multiplication operator</strong>, nhưng các bạn có thể phân biệt được vì <strong>dereference operator</strong> là toán tử một ngôi, trong khi đó, <strong>multiplication operator</strong> là toán tử hai ngôi.</p>\n\n<p>Khác với tham chiếu (<strong>reference</strong>), toán tử trỏ đến (<strong>dereference operator</strong>) không tạo ra một tên biến khác, mà nó truy xuất trực tiếp đến vùng nhớ có địa chỉ cụ thể trên <strong>Virtual memory</strong>.</p>\n\n<hr>\n\n<h3>Con trỏ (Pointer)</h3>\n\n<p>Với những khái niệm mình trình bày ở trên (một số khái niệm các bạn đã được học), bây giờ chúng ta có thể nói đến con trỏ (<strong>pointer</strong>).</p>\n\n<blockquote><p>Một con trỏ (a <strong>pointer</strong>) là một biến được dùng để lưu trữ địa chỉ của biến khác.</p></blockquote>\n\n<p>Khác với tham chiếu, con trỏ là một biến có địa chỉ độc lập so với vùng nhớ mà nó trỏ đến, nhưng giá trị bên trong vùng nhớ của con trỏ chính là địa chỉ của biến (hoặc địa chỉ ảo) mà nó trỏ tới.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true\" class=\"lightbox\" title=\"3.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true\" width=\"690\" height=\"411\"><div class=\"meta\">\n<span class=\"filename\">3.png?raw=true</span><span class=\"informations\">983x586</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Trong ví dụ trên, một con trỏ sau khi khai báo đã được cấp phát vùng nhớ tại địa chỉ 3255, và nó trỏ đến địa chỉ 1224, do đó, giá trị bên trong vùng nhớ của con trỏ là 1224.</p>\n\n<h5>Khai báo con trỏ</h5>\n\n<p>Cũng giống như biến thông thường, biến con trỏ cần được khai báo trước khi sử dụng. Con trỏ yêu cầu cú pháp khai báo mới hơn một chút so với biến thông thường.</p>\n\n<pre><code>&lt;data_type&gt; *&lt;name_of_pointer&gt;;</code></pre>\n\n<p>Khác với biến thông thường, chúng ta cần đặt thêm dấu sao giữa kiểu dữ liệu và tên biến của con trỏ.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int *iPtr;\nfloat *fPtr;\ndouble *dPtr;\n\nint *iPtr1, *iPtr2;</code></pre>\n\n<p><strong><em>Lưu ý: Dấu sao trong khai báo con trỏ không phải là toán tử trỏ đến (dereference operator), nó chỉ là cú pháp được ngôn ngữ C/C++ quy định.</em></strong></p>\n\n<h5>Cách khai báo dễ gây nhầm lẫn</h5>\n\n<p>Ngôn ngữ C/C++ yêu cầu đặt dấu sao giữa kiểu dữ liệu và tên con trỏ nhưng không bắt buộc phải đặt nó gần với kiểu dữ liệu hay gần với tên con trỏ. Do đó, những cách khai báo dưới đây đều được cho phép:</p>\n\n<pre><code>int *iPtr1; //We recommended you use this way to declare pointers\nint* iPtr2;</code></pre>\n\n<p>Nhưng mình khuyến nghị các bạn sử dụng cách khai báo đặt dấu sao ngay trước tên con trỏ vì cách thứ hai có thể gây nhầm lẫn.</p>\n\n<pre><code>int* iPtr1, iPtr2;</code></pre>\n\n<p>Với cách khai báo này, <strong>iPtr1</strong> là một con trỏ kiểu <strong>int</strong>, trong khi đó, <strong>iPtr2</strong> là một biến kiểu <strong>int</strong>. Để có được hai con trỏ, chúng ta cần khai báo như sau:</p>\n\n<pre><code>int *iPtr1, *iPtr2;</code></pre>\n\n<h5>Kích thước của con trỏ trong bộ nhớ</h5>\n\n<p>Các bạn cùng chạy thử đoạn chương trình dưới đây:</p>\n\n<pre><code>cout &lt;&lt; sizeof(char*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(int*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(double*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(string*) &lt;&lt; endl;</code></pre>\n\n<p>Đoạn chương trình trên cho ra kết quả như sau:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/4.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Tại cửa sổ giao diện của Visual studio 2015, chúng ta chuyển sang Debug trên nền tảng 64 bits.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true\" class=\"lightbox\" title=\"5.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true\" width=\"690\" height=\"321\"><div class=\"meta\">\n<span class=\"filename\">5.png?raw=true</span><span class=\"informations\">901x420</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Nhấn F5 lại lần nữa và xem lại kết quả:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/6.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p><strong><em>Như vậy, chúng ta thấy rằng khi chạy trên nền tảng hệ điều hành 32 bits con trỏ sẽ có kích thước 4 bytes, khi chạy trên nền tảng hệ điều hành 64 bits con trỏ sẽ có kích thước 8 bytes.</em></strong></p>\n\n<p>Kiểu dữ liệu của con trỏ thay đổi không hề tác động đến kích thước bộ nhớ của con trỏ. Bởi vì giá trị thực sự của con trỏ là kiểu số nguyên không dấu (<strong>unsigned int</strong>), trong nền tảng hệ điều hành <strong>32 bits</strong>, giá trị mà con trỏ lưu trữ sẽ là <code>unsigned __int32</code>, và trong nền tảng hệ điều hành <strong>64 bits</strong>, giá trị của con trỏ lưu trữ có kiểu <code>unsigned __int64</code>.</p>\n\n<p><strong><em>Kiểu dữ liệu của con trỏ không mô tả giá trị địa chỉ được lưu trữ bên trong con trỏ, mà kiểu dữ liệu của con trỏ dùng để xác định kiểu dữ liệu của biến mà nó trỏ đến trên bộ nhớ ảo.</em></strong></p>\n\n<p>Vậy tại sao lại cần 4 bytes cho một con trỏ trong hệ điều hành 32 bits, và cần 8 bytes cho một con trỏ trong hệ điều hành 64 bits?</p>\n\n<p>Phạm vi giá trị của <code>unsigned __int32</code> là từ 0 đến 4294967295, phạm vi giá trị này đủ để đánh dấu địa chỉ tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>32 bits</strong>. Tương tự, phạm vi giá trị của <code>unsigned __int64</code> là tử 0 đến 18446744073709551615, đủ để đánh dấu địa chỉ của tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>64 bits</strong>.</p>\n\n<p>Dưới đây là thông tin Virtual memory trên máy tính của mình:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/virtual_memory.png?raw=true\" width=\"354\" height=\"465\"></p>\n\n<p>Dung lượng bộ nhớ ảo hiện tại của máy mình là <strong>1960MB</strong>, tương đương với <strong>2055208960 bytes</strong>. Trong khi đó, con trỏ trong nền tảng hệ điều hành <strong>32 bits</strong> có kích thước <strong>4 bytes</strong>, giá trị địa chỉ lớn nhất mà con trỏ <strong>4 bytes</strong> có thể lưu trữ được là <strong>4294967295</strong>, nên nó đủ để lưu trữ bất kì địa chỉ của biến nào được cấp phát trên bộ nhớ ảo.</p>\n\n<h5>Gán giá trị cho con trỏ</h5>\n\n<p>Giá trị mà biến con trỏ lưu trữ là địa chỉ của biến khác có cùng kiểu dữ liệu với biến con trỏ.</p>\n\n<pre><code>int *ptr;\nint value = 5;\n\nptr = &amp;value;</code></pre>\n\n<p>Do đó, chúng ta cần sử dụng <strong>address-of operator</strong> để lấy ra địa chỉ ảo của biến rồi mới gán cho con trỏ được. Lúc này, biến ptr sẽ lưu trữ địa chỉ ảo của biến value.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/7.png?raw=true\" width=\"409\" height=\"145\"></p>\n\n<p>(Nguồn: <a href=\"http://www.learncpp.com\" rel=\"nofollow\">www.learncpp.com</a>)</p>\n\n<p>Chúng ta có thể nói rằng con trỏ <strong>ptr</strong> đang nắm giữ địa chỉ của biến <strong>value</strong>, cũng có thể nói con trỏ <strong>ptr</strong> trỏ đến biến <strong>value</strong>.</p>\n\n<p>Đoạn chương trình sau sẽ in ra địa chỉ của biến value và giá trị được lưu bởi con trỏ ptr sau khi trỏ đến biến value:</p>\n\n<pre><code>int main()\n{\n\tint value = 5;\n\tint *ptr = &amp;value;\n\t\n\tcout &lt;&lt; &amp;value &lt;&lt; endl;\n\tcout &lt;&lt; ptr &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả thu được trên màn hình console:</p>\n\n<pre><code>0012FF7C\n0012FF7C</code></pre>\n\n<p>Lý do mà chúng ta gán được địa chỉ của biến <strong>value</strong> cho con trỏ kiểu <strong>int</strong> (int *) là vì <strong>address-of operator</strong> của một biến kiểu <strong>int</strong> trả về giá trị kiểu con trỏ kiểu <strong>int</strong> (int *).</p>\n\n<p>Thử xem xét đoạn chương trình sau:</p>\n\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\t\n\tint value = 5;\n\tcout &lt;&lt; typeid(&amp;value).name() &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả in ra màn hình của toán tử lấy địa chỉ ở trên là:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/8.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Do đó, chúng ta có thể gán <code>&amp;value</code> cho con trỏ kiểu <strong>int</strong> (int *).</p>\n\n<p>Bên cạnh đó, khi có hai con trỏ cùng kiểu thì chúng ta có thể gán trực tiếp mà không cần sử dụng <strong>address-of operator</strong>.</p>\n\n<pre><code>int main()\n{\n\tint value = 5;\n\tint *ptr1, *ptr2;\n\n\tptr1 = &amp;value; //ptr1 point to value\n\tptr2 = ptr1;   //assign value of ptr1 to ptr2\n\n\tcout &lt;&lt; ptr1 &lt;&lt; endl;\n\tcout &lt;&lt; ptr2 &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lúc này, <strong>ptr1</strong> và <strong>ptr2</strong> cùng giữ địa chỉ của biến <strong>value</strong>.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/9.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p><strong><em>Khác với tham chiếu (reference), một con trỏ có thể trỏ đến địa chỉ khác trong bộ nhớ ảo sau khi đã được gán giá trị. Tham chiếu (reference) không thể thay đổi địa chỉ sau lần tham chiếu đầu tiên.</em></strong></p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int main()\n{\n\tint *ptr;\n\n\tint arr[5] = { 1, 2, 3, 4, 5 };\n\n\tfor(int i = 0; i &lt; 5; i++)\n\t{\n\t\tptr = &amp;arr[i];\n\t\tcout &lt;&lt; ptr &lt;&lt; endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả của đoạn chương trình này là:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/10.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Con trỏ <strong>ptr</strong> đã trỏ đến lần lượt 5 phần tử của mảng <strong>arr</strong>. Nếu các bạn để ý sẽ thấy 5 địa chỉ này liên tiếp nhau trên bộ nhớ ảo. Mình sẽ trình bày vấn đề này trong các bài học sau.</p>\n\n<h5>Các phép gán không hợp lệ khi sử dụng con trỏ</h5>\n\n<p>Phép gán của con trỏ chỉ thực hiện được khi kiểu dữ liệu của con trỏ phù hợp kiểu dữ liệu của biến mà nó sẽ trỏ tới. Do đó, các phép gán dưới đây là không hợp lệ:</p>\n\n<pre><code>int iValue = 0;\nfloat fValue = 0.0;\n\nint *i_ptr = fValue;   //wrong! int pointer cannot point to the address of a double variable\nfloat *f_ptr = iValue; //wrong! float pointer cannot point to the address of an int variable</code></pre>\n\n<p>Mặc dù giá trị mà con trỏ lưu trữ có kiểu <strong>unsigned int</strong>, nhưng chúng ta không thể gán trực tiếp một giá trị địa chỉ cho con trỏ được.</p>\n\n<pre><code>int *ptr = 1245052; //wrong!</code></pre>\n\n<p>Giá trị 1245052 không có địa chỉ cụ thể, trong khi đó, con trỏ chỉ nhận giá trị là địa chỉ nên phép gán trên là sai. Mặc dù giá trị được chuyển về dạng cơ số thập lục phân để tương xứng với định dạng giá trị mà con trỏ in ra, điều này cũng không được cho phép.</p>\n\n<pre><code>int *ptr = 0012FF7C; //wrong!</code></pre>\n\n<p><strong><em>Chỉ có giá trị kiểu con trỏ (có được nhờ toán tử address-of, hoặc từ một biến con trỏ cùng kiểu khác) mới có thể gán được cho biến con trỏ.</em></strong></p>\n\n<h5>Truy xuất giá trị bên trong vùng nhớ mà con trỏ trỏ đến</h5>\n\n<p>Khi chúng ta có một con trỏ đã được trỏ đến địa chỉ nào đó trong bộ nhớ ảo, chúng ta có thể truy xuất giá trị tại địa chỉ đó bằng <strong>dereference operator</strong>. <strong>Dereference operator</strong> sẽ đánh giá nội dung địa chỉ được trỏ đến.</p>\n\n<pre><code>int *ptr; //declare an int pointer\nint value = 5;\n\nptr = &amp;value; //ptr point to value\n\ncout &lt;&lt; &amp;value &lt;&lt; endl; //print the address of value\ncout &lt;&lt; ptr &lt;&lt; endl;    //print the address of value which is held in ptr\n\ncout &lt;&lt; value &lt;&lt; endl;  //print the content of value\ncout &lt;&lt; *(&amp;value) &lt;&lt; endl; //print the content of value\ncout &lt;&lt; *ptr &lt;&lt; endl;\t//print the content of value</code></pre>\n\n<p>Kết quả của đoạn chương trình trên như sau:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/11.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Toán tử trỏ đến (<strong>dereference operator</strong>) được dùng để truy cập trực tiếp vào vùng nhớ có địa chỉ cụ thể trên bộ nhớ ảo (<strong>virtual memory</strong>), vì biến con trỏ <strong>ptr</strong> đang giữ địa chỉ của biến <strong>value</strong> nên khi đặt toán tử trỏ đến (<strong>dereference operator</strong>) trước con trỏ <strong>ptr</strong>, nó sẽ truy xuất giá trị tại địa chỉ mà con trỏ <strong>ptr</strong> đang giữ.</p>\n\n<p>Vì <strong>ptr</strong> có kiểu dữ liệu <strong>con trỏ int</strong> (int *), <strong>ptr</strong> chỉ có thể trỏ đến biến kiểu <strong>int</strong>. Lúc này, <strong>compiler</strong> hiểu rằng cần phân tích <strong>4 bytes</strong> (đúng bằng kích thước kiểu <strong>int</strong>) trên bộ nhớ ảo tại địa chỉ mà <strong>ptr</strong> đang lưu trữ.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true\" class=\"lightbox\" title=\"12.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true\" width=\"690\" height=\"328\"><div class=\"meta\">\n<span class=\"filename\">12.png?raw=true</span><span class=\"informations\">764x364</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Đây là lý do tại sao chúng ta cần khai báo kiểu dữ liệu của con trỏ. Nếu không khai báo kiểu dữ liệu cho con trỏ, toán tử trỏ đến (<strong>dereference operator</strong>) sẽ không biết phải phân tích bao nhiêu bytes tại địa chỉ con trỏ trỏ đến để tính toán được giá trị của vùng nhớ đó. Không những thế, đây còn là lý do kiểu dữ liệu của biến phải tương xứng với kiểu dữ liệu được khai báo cho con trỏ.</p>\n\n<p>Vì chúng ta có thể gán lại địa chỉ mới cho một con trỏ, nên chúng ta có thể truy xuất được giá trị của nhiều vùng nhớ khác nhau chỉ với một con trỏ:</p>\n\n<pre><code>int value1 = 1;\nint value2 = 2;\n\nint *ptr = &amp;value1;\ncout &lt;&lt; *ptr &lt;&lt; endl;\n\nptr = &amp;value2;\ncout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>\n\n<p>Với khả năng truy cập đến vùng nhớ có địa chỉ cụ thể và thay đổi giá trị bên trong vùng nhớ của toán tử trỏ đến (<strong>dereference operator</strong>), chúng ta có thể sử dụng như sau:</p>\n\n<pre><code>int value = 5;\nint *ptr = &amp;value;\n\n*ptr = 10;\ncout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>\n\n<p>Đoạn chương trình này sẽ in ra giá trị <strong>10</strong>.</p>\n\n<p>Có thể giải thích dòng lệnh <code>*ptr = 10;</code> như sau:</p>\n\n<p>Biến con trỏ <strong>ptr</strong> sau khi khai báo đã được khởi tạo bằng cách gán địa chỉ của biến <strong>value</strong>. Sử dụng <strong>dereference operator</strong> cho con trỏ <strong>ptr</strong> để truy cập đến địa chỉ ảo mà <strong>ptr</strong> đang nắm giữ, gán giá trị 10 vào vùng nhớ tại vị trí đó.</p>\n\n<h5>Con trỏ chưa được gán địa chỉ</h5>\n\n<p>Con trỏ trong ngôn ngữ C/C++ vốn không an toàn. Nếu sử dụng con trỏ không hợp lý có thể gây crash chương trình.</p>\n\n<p>Khác với tham chiếu (<strong>reference</strong>), biến con trỏ có thể không cần khởi tạo giá trị ngay khi khai báo. Nhưng thực hiện truy xuất giá trị của con trỏ bằng dereference operator khi chưa gán địa chỉ cụ thể cho con trỏ, chương trình có thể bị đóng bởi hệ điều hành. Nguyên nhân là do con trỏ đang nắm giữ một giá trị rác, giá trị rác đó có thể là địa chỉ thuộc một vùng nhớ đang được ứng dụng khác sử dụng, hoặc giá trị vượt quá giới hạn của bộ nhớ ảo.</p>\n\n<p>Trong chế độ <strong>Debug</strong> của Visual studio 2015, trường hợp này sẽ bị cảnh báo và ngăn chặn chương trình thực thi.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int main()\n{\n\tint *ptr; //declare an int pointer\n\tcout &lt;&lt; *ptr &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Nhấn F5 để Debug chương trình sẽ nhận được thông báo:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/13.png?raw=true\" width=\"559\" height=\"318\"></p>\n\n<p>Do đó, khi khai báo con trỏ nhưng chưa có địa chỉ khởi tạo cụ thể, chúng ta nên gán cho con trỏ giá trị <strong>NULL</strong>.</p>\n\n<hr>\n\n<h3>NULL</h3>\n\n<p><strong>NULL</strong> là một macro đã được định nghĩa sẵn trong ngôn ngữ C/C++.</p>\n\n<pre><code>#define NULL 0</code></pre>\n\n<p>Đối với con trỏ, <strong>NULL</strong> là một giá trị đặc biệt, khi gán <strong>NULL</strong> cho con trỏ, điều đó có nghĩa là con trỏ đó chưa trỏ đến địa chỉ nào cả. Con trỏ đang giữ giá trị <strong>NULL</strong> được gọi là con trỏ <strong>NULL</strong> (<strong>NULL pointer</strong>).</p>\n\n<pre><code>int *ptr = NULL; //ptr is now a NULL pointer</code></pre>\n\n<p>Lúc này, chúng ta có thể kiểm tra xem con trỏ đã được gán địa chỉ cụ thể hay chưa:</p>\n\n<pre><code>int *ptr = NULL;\n\nif(ptr == NULL)\n{\n\tcout &lt;&lt; \"Do nothing\" &lt;&lt; endl;\n}\nelse\n{\n\tcout &lt;&lt; *ptr &lt;&lt; endl;\n}</code></pre>\n\n<p>Đoạn chương trình này sẽ giúp chương trình đảm bảo rằng con trỏ <strong>ptr</strong> sẽ không được sử dụng khi chưa được gán địa chỉ cụ thể.</p>\n\n<p>Chuẩn <strong>C++11</strong> cung cấp cho chúng ta từ khóa <strong>nullptr</strong> tương tự như macro <strong>NULL</strong>. Chúng ta có thể sử dụng như sau:</p>\n\n<pre><code>int *ptr = nullptr;</code></pre>\n\n<p>Bên cạnh đó, <strong>C++11</strong> còn định nghĩa cho chúng ta kiểu dữ liệu <code>std::nullptr_t</code>, <code>nullptr_t</code> chỉ có thể lưu trữ giá trị <strong>nullptr</strong>. Nhưng chúng ta ít khi sử dụng kiểu dữ liệu này nên các bạn cũng không cần quan tâm lắm.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, các bạn đã được tìm hiểu khái niệm con trỏ và một số khái niệm có liên quan. Việc sử dụng con trỏ thường có một số hoạt động chủ yếu: <strong>(a) khai báo một con trỏ, (b) gán địa chỉ cho con trỏ, (c) truy cập đến địa chỉ mà con trỏ đang nắm giữ bằng dereference operator</strong>.</p>\n\n<p>Thử liên hệ một chút với cuộc sống thực tế, tưởng tượng rằng con đường nhà bạn (street) là bộ nhớ ảo, trên con đường đó có rất nhiều ngôi nhà (house), mỗi ngôi nhà đều được đánh số thứ tự gọi là địa chỉ nhà (house's address). Chúng ta tạm hình dung số người ở trong mỗi ngôi nhà (content) tương đương với nội dung của mỗi ô trên bộ nhớ ảo. Như vậy, address-of operator (&amp;house) sẽ trả về địa chỉ của ngôi nhà, dereference operator (*&amp;house) sẽ lấy ra số lượng người bên trong ngôi nhà có địa chỉ được xác định. Để sử dụng con trỏ trỏ đến mỗi ngôi nhà, chúng ta phải sử dụng một con trỏ kiểu <strong>House</strong> (giống với kiểu của từng ngôi nhà), giả sử con trỏ kiểu <strong>House</strong> được khai báo là <code>House *h_ptr;</code> thì con trỏ <code>h_ptr</code> có thể trỏ đến bất kì ngôi nhà nào trên con đường, và nó còn có thể thay đổi nội dung bên trong từng ngôi nhà mà nó trỏ đến.</p>\n\n<p>Con trỏ (<strong>Pointer</strong>) là một công cụ mạnh mẽ đặc trưng của ngôn ngữ C/C++. Con trỏ cho phép chúng ta trực tiếp quản lý dung lượng của chương trình trên bộ nhớ ảo. Nhưng bên cạnh đó, việc sử dụng con trỏ không hợp lý có thể gây lãng phí tài nguyên của hệ thống máy tính. Chúng ta sẽ cùng tìm hiểu các kĩ thuật quản lý bộ nhớ ảo của chương trình trong các bài học tiếp theo.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","rawBody":"\n<h4>Chào các bạn học viên đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong chương này, chúng ta sẽ cùng nhau tìm hiểu về khái niệm con trỏ (<strong>Pointer</strong>) - một đặc trưng của ngôn ngữ lập trình C/C++.</p>\n\n<p>Trước khi vào bài học này, chúng ta cùng nhau xem lại một số khái niệm liên quan đến vùng nhớ, địa chỉ của biến, tham chiếu...</p>\n\n<h5>Variable</h5>\n\n<p>Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình C++ nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu.</p>\n\n<p>Khi thao tác với các biến thông thường, chúng ta không cần quan tâm đến địa chỉ vùng nhớ của biến. Khi cần truy xuất giá trị của biến, chúng ta chỉ cần gọi định danh (hay thường gọi là tên biến).</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int money;</code></pre>\n\n<p>Khi dòng lệnh này được CPU thực thi, một vùng nhớ có kích thước 4 bytes sẽ được cấp phát. Lấy ví dụ biến money này được đặt tại ô nhớ 1224 (trong địa chỉ ảo của máy tính).</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/0.png?raw=true\" width=\"400\" height=\"300\"></p>\n\n<p>Bất cứ khi nào chương trình thấy các bạn sử dụng biến money trong câu lệnh, chương trình hiểu rằng cần tìm đến ô nhớ 1224 để lấy giá trị đó ra.</p>\n\n<h5>Virtual memory &amp; Physical memory</h5>\n\n<p>Việc truy xuất dữ liệu trên bộ nhớ máy tính cần phải thông qua một số bước trung gian, người dùng không thể trực tiếp truy xuất vào các ô nhớ trên các thiết bị lưu trữ. Chúng ta chỉ có thể trỏ đến vùng nhớ ảo (virtual memory) trên máy tính, còn việc truy xuất đến bộ nhớ vật lý (physical memory) từ bộ nhớ ảo phải được thực hiện bởi thiết bị phần cứng có tên là <strong>Memory management unit (MMU)</strong> và một chương trình định vị địa chỉ bộ nhớ gọi là <strong>Virtual address space</strong>.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true\" width=\"690\" height=\"373\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">1045x566</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Virtual memory làm che giấu sự phân mảnh của bộ nhớ vật lý, khiến chúng ta có cảm giác đang thao tác với các vùng nhớ liên tục. Trong hình trên, từ phía Virtual memory cho đến Physical memory thuộc về phần quản lý của hệ điều hành, lập trình viên và người dùng chúng ta không thể can thiệp trực tiếp đến trong quá trình máy tính đang hoạt động.</p>\n\n<h5>Variable address &amp; address-of operator</h5>\n\n<p>Địa chỉ của biến mà chúng ta nhìn thấy thật ra chỉ là những giá trị đã được đánh số thứ tự đặt trên Virtual memory. Để lấy được địa chỉ ảo của biến trong chương trình, chúng ta sử dụng toán tử <strong>'&amp;'</strong> đặt trước tên biến.</p>\n\n<pre><code>int x = 5;\nstd::cout &lt;&lt; x &lt;&lt; '\\n'; // print the value of variable x\nstd::cout &lt;&lt; &amp;x &lt;&lt; '\\n'; // print the memory address of variable x</code></pre>\n\n<p>Trên máy tính của mình, kết quả của đoạn chương trình trên được in ra như sau:</p>\n\n<pre><code>5\n0027FEA0</code></pre>\n\n<p>Dòng đầu tiên là kết quả của việc truy xuất giá trị của biến thông qua định danh (tên biến). Dòng thứ hai là kết quả của việc truy xuất đến địa chỉ ảo của biến.</p>\n\n<h5>Tham chiếu (Reference)</h5>\n\n<p>Mục đích của tham chiếu trong C++ là tạo ra một biến khác có cùng kiểu dữ liệu nhưng sử dụng chung vùng nhớ với biến được tham chiếu đến.</p>\n\n<pre><code>int i1 = 10;\nint &amp;i_ref = i1;        //reference to i1, not means address of i1\n\ncout &lt;&lt; &amp;i1 &lt;&lt; endl;    //get address of i1\ncout &lt;&lt; &amp;i_ref &lt;&lt; endl; //get address of i_ref</code></pre>\n\n<p>Kết quả chúng ta được:</p>\n\n<pre><code>0xBFEB475C\n0xBFEB475C</code></pre>\n\n<p>Như vậy, mọi hành vi thay đổi giá trị của <code>i_ref</code> đều tác động trực tiếp đến <code>i1</code>.</p>\n\n<p><strong><em>Lưu ý: Biến tham chiếu sẽ có địa chỉ cố định sau khi khởi tạo. Chúng ta không thể tham chiếu lại lần nữa.</em></strong></p>\n\n<h5>Dereference operator</h5>\n\n<p>Toán tử trỏ đến (<strong>dereference operator</strong>) hay còn gọi là <strong>indirection operator</strong> (toán tử điều hành gián tiếp) được kí hiệu bằng dấu sao <strong>\" * \"</strong> cho phép chúng ta lấy ra giá trị của vùng nhớ có địa chỉ cụ thể.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int n = 5;\n\ncout &lt;&lt; n &lt;&lt; endl;     //print the value of variable n\ncout &lt;&lt; &amp;n &lt;&lt; endl;    //print the virtual memory address of variable n\ncout &lt;&lt; *(&amp;n) &lt;&lt; endl; //print the value at the virtual memory address of variable n</code></pre>\n\n<ul>\n<li><p>Dòng lệnh cout đầu tiên khá dễ hiểu, nó thực hiện in ra giá trị của biến n bằng cách gọi định danh n, còn lại phần truy xuất đến địa chỉ ảo của biến n sẽ do chương trình đảm nhiệm.</p></li>\n<li><p>Dòng lệnh cout thứ hai không dùng để lấy ra giá trị bên trong vùng nhớ mà biến n đang nắm giữ, mà nó lấy ra địa chỉ ảo của biến n.</p></li>\n<li><p>Dòng lệnh cout thứ ba chúng ta sử dụng toán tử trỏ đến <strong>\" * \"</strong> đặt trước toán tử <strong>address-of</strong>. Khi đó, <strong>(&amp;n)</strong> sẽ lấy ra địa chỉ ảo của biến n, và toán tử * sẽ truy xuất giá trị bên trong địa chỉ đó.</p></li>\n</ul>\n\n<p>Kết quả của đoạn chương trình trên là:</p>\n\n<pre><code>5\n0xBFD181AC\n5</code></pre>\n\n<p>Ngoài việc truy xuất giá trị trong vùng nhớ của một địa chỉ cụ thể, toán tử trỏ đến (<strong>dereference operator</strong>) còn có thể dùng để thay đổi giá trị bên trong vùng nhớ đó.</p>\n\n<pre><code>int n = 5;\ncout &lt;&lt; n &lt;&lt; endl;\n*(&amp;n) = 10;\ncout &lt;&lt; n &lt;&lt; endl;</code></pre>\n\n<p>Kết quả đoạn chương trình này là:</p>\n\n<pre><code>5\n10</code></pre>\n\n<p>Như vậy, <strong>dereference operator</strong> cho phép chúng ta thao tác trực tiếp trên <strong>Virtual memory</strong> mà không cần thông qua định danh (tên biến).</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true\" class=\"lightbox\" title=\"2.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true\" width=\"690\" height=\"430\"><div class=\"meta\">\n<span class=\"filename\">2.png?raw=true</span><span class=\"informations\">786x490</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Mặc dù <strong>dereference operator</strong> có kí hiệu giống <strong>multiplication operator</strong>, nhưng các bạn có thể phân biệt được vì <strong>dereference operator</strong> là toán tử một ngôi, trong khi đó, <strong>multiplication operator</strong> là toán tử hai ngôi.</p>\n\n<p>Khác với tham chiếu (<strong>reference</strong>), toán tử trỏ đến (<strong>dereference operator</strong>) không tạo ra một tên biến khác, mà nó truy xuất trực tiếp đến vùng nhớ có địa chỉ cụ thể trên <strong>Virtual memory</strong>.</p>\n\n<hr>\n\n<h3>Con trỏ (Pointer)</h3>\n\n<p>Với những khái niệm mình trình bày ở trên (một số khái niệm các bạn đã được học), bây giờ chúng ta có thể nói đến con trỏ (<strong>pointer</strong>).</p>\n\n<blockquote><p>Một con trỏ (a <strong>pointer</strong>) là một biến được dùng để lưu trữ địa chỉ của biến khác.</p></blockquote>\n\n<p>Khác với tham chiếu, con trỏ là một biến có địa chỉ độc lập so với vùng nhớ mà nó trỏ đến, nhưng giá trị bên trong vùng nhớ của con trỏ chính là địa chỉ của biến (hoặc địa chỉ ảo) mà nó trỏ tới.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true\" class=\"lightbox\" title=\"3.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true\" width=\"690\" height=\"411\"><div class=\"meta\">\n<span class=\"filename\">3.png?raw=true</span><span class=\"informations\">983x586</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Trong ví dụ trên, một con trỏ sau khi khai báo đã được cấp phát vùng nhớ tại địa chỉ 3255, và nó trỏ đến địa chỉ 1224, do đó, giá trị bên trong vùng nhớ của con trỏ là 1224.</p>\n\n<h5>Khai báo con trỏ</h5>\n\n<p>Cũng giống như biến thông thường, biến con trỏ cần được khai báo trước khi sử dụng. Con trỏ yêu cầu cú pháp khai báo mới hơn một chút so với biến thông thường.</p>\n\n<pre><code>&lt;data_type&gt; *&lt;name_of_pointer&gt;;</code></pre>\n\n<p>Khác với biến thông thường, chúng ta cần đặt thêm dấu sao giữa kiểu dữ liệu và tên biến của con trỏ.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int *iPtr;\nfloat *fPtr;\ndouble *dPtr;\n\nint *iPtr1, *iPtr2;</code></pre>\n\n<p><strong><em>Lưu ý: Dấu sao trong khai báo con trỏ không phải là toán tử trỏ đến (dereference operator), nó chỉ là cú pháp được ngôn ngữ C/C++ quy định.</em></strong></p>\n\n<h5>Cách khai báo dễ gây nhầm lẫn</h5>\n\n<p>Ngôn ngữ C/C++ yêu cầu đặt dấu sao giữa kiểu dữ liệu và tên con trỏ nhưng không bắt buộc phải đặt nó gần với kiểu dữ liệu hay gần với tên con trỏ. Do đó, những cách khai báo dưới đây đều được cho phép:</p>\n\n<pre><code>int *iPtr1; //We recommended you use this way to declare pointers\nint* iPtr2;</code></pre>\n\n<p>Nhưng mình khuyến nghị các bạn sử dụng cách khai báo đặt dấu sao ngay trước tên con trỏ vì cách thứ hai có thể gây nhầm lẫn.</p>\n\n<pre><code>int* iPtr1, iPtr2;</code></pre>\n\n<p>Với cách khai báo này, <strong>iPtr1</strong> là một con trỏ kiểu <strong>int</strong>, trong khi đó, <strong>iPtr2</strong> là một biến kiểu <strong>int</strong>. Để có được hai con trỏ, chúng ta cần khai báo như sau:</p>\n\n<pre><code>int *iPtr1, *iPtr2;</code></pre>\n\n<h5>Kích thước của con trỏ trong bộ nhớ</h5>\n\n<p>Các bạn cùng chạy thử đoạn chương trình dưới đây:</p>\n\n<pre><code>cout &lt;&lt; sizeof(char*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(int*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(double*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(string*) &lt;&lt; endl;</code></pre>\n\n<p>Đoạn chương trình trên cho ra kết quả như sau:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/4.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Tại cửa sổ giao diện của Visual studio 2015, chúng ta chuyển sang Debug trên nền tảng 64 bits.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true\" class=\"lightbox\" title=\"5.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true\" width=\"690\" height=\"321\"><div class=\"meta\">\n<span class=\"filename\">5.png?raw=true</span><span class=\"informations\">901x420</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Nhấn F5 lại lần nữa và xem lại kết quả:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/6.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p><strong><em>Như vậy, chúng ta thấy rằng khi chạy trên nền tảng hệ điều hành 32 bits con trỏ sẽ có kích thước 4 bytes, khi chạy trên nền tảng hệ điều hành 64 bits con trỏ sẽ có kích thước 8 bytes.</em></strong></p>\n\n<p>Kiểu dữ liệu của con trỏ thay đổi không hề tác động đến kích thước bộ nhớ của con trỏ. Bởi vì giá trị thực sự của con trỏ là kiểu số nguyên không dấu (<strong>unsigned int</strong>), trong nền tảng hệ điều hành <strong>32 bits</strong>, giá trị mà con trỏ lưu trữ sẽ là <code>unsigned __int32</code>, và trong nền tảng hệ điều hành <strong>64 bits</strong>, giá trị của con trỏ lưu trữ có kiểu <code>unsigned __int64</code>.</p>\n\n<p><strong><em>Kiểu dữ liệu của con trỏ không mô tả giá trị địa chỉ được lưu trữ bên trong con trỏ, mà kiểu dữ liệu của con trỏ dùng để xác định kiểu dữ liệu của biến mà nó trỏ đến trên bộ nhớ ảo.</em></strong></p>\n\n<p>Vậy tại sao lại cần 4 bytes cho một con trỏ trong hệ điều hành 32 bits, và cần 8 bytes cho một con trỏ trong hệ điều hành 64 bits?</p>\n\n<p>Phạm vi giá trị của <code>unsigned __int32</code> là từ 0 đến 4294967295, phạm vi giá trị này đủ để đánh dấu địa chỉ tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>32 bits</strong>. Tương tự, phạm vi giá trị của <code>unsigned __int64</code> là tử 0 đến 18446744073709551615, đủ để đánh dấu địa chỉ của tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>64 bits</strong>.</p>\n\n<p>Dưới đây là thông tin Virtual memory trên máy tính của mình:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/virtual_memory.png?raw=true\" width=\"354\" height=\"465\"></p>\n\n<p>Dung lượng bộ nhớ ảo hiện tại của máy mình là <strong>1960MB</strong>, tương đương với <strong>2055208960 bytes</strong>. Trong khi đó, con trỏ trong nền tảng hệ điều hành <strong>32 bits</strong> có kích thước <strong>4 bytes</strong>, giá trị địa chỉ lớn nhất mà con trỏ <strong>4 bytes</strong> có thể lưu trữ được là <strong>4294967295</strong>, nên nó đủ để lưu trữ bất kì địa chỉ của biến nào được cấp phát trên bộ nhớ ảo.</p>\n\n<h5>Gán giá trị cho con trỏ</h5>\n\n<p>Giá trị mà biến con trỏ lưu trữ là địa chỉ của biến khác có cùng kiểu dữ liệu với biến con trỏ.</p>\n\n<pre><code>int *ptr;\nint value = 5;\n\nptr = &amp;value;</code></pre>\n\n<p>Do đó, chúng ta cần sử dụng <strong>address-of operator</strong> để lấy ra địa chỉ ảo của biến rồi mới gán cho con trỏ được. Lúc này, biến ptr sẽ lưu trữ địa chỉ ảo của biến value.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/7.png?raw=true\" width=\"409\" height=\"145\"></p>\n\n<p>(Nguồn: <a href=\"http://www.learncpp.com\" rel=\"nofollow\">www.learncpp.com</a>)</p>\n\n<p>Chúng ta có thể nói rằng con trỏ <strong>ptr</strong> đang nắm giữ địa chỉ của biến <strong>value</strong>, cũng có thể nói con trỏ <strong>ptr</strong> trỏ đến biến <strong>value</strong>.</p>\n\n<p>Đoạn chương trình sau sẽ in ra địa chỉ của biến value và giá trị được lưu bởi con trỏ ptr sau khi trỏ đến biến value:</p>\n\n<pre><code>int main()\n{\n\tint value = 5;\n\tint *ptr = &amp;value;\n\t\n\tcout &lt;&lt; &amp;value &lt;&lt; endl;\n\tcout &lt;&lt; ptr &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả thu được trên màn hình console:</p>\n\n<pre><code>0012FF7C\n0012FF7C</code></pre>\n\n<p>Lý do mà chúng ta gán được địa chỉ của biến <strong>value</strong> cho con trỏ kiểu <strong>int</strong> (int *) là vì <strong>address-of operator</strong> của một biến kiểu <strong>int</strong> trả về giá trị kiểu con trỏ kiểu <strong>int</strong> (int *).</p>\n\n<p>Thử xem xét đoạn chương trình sau:</p>\n\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\t\n\tint value = 5;\n\tcout &lt;&lt; typeid(&amp;value).name() &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả in ra màn hình của toán tử lấy địa chỉ ở trên là:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/8.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Do đó, chúng ta có thể gán <code>&amp;value</code> cho con trỏ kiểu <strong>int</strong> (int *).</p>\n\n<p>Bên cạnh đó, khi có hai con trỏ cùng kiểu thì chúng ta có thể gán trực tiếp mà không cần sử dụng <strong>address-of operator</strong>.</p>\n\n<pre><code>int main()\n{\n\tint value = 5;\n\tint *ptr1, *ptr2;\n\n\tptr1 = &amp;value; //ptr1 point to value\n\tptr2 = ptr1;   //assign value of ptr1 to ptr2\n\n\tcout &lt;&lt; ptr1 &lt;&lt; endl;\n\tcout &lt;&lt; ptr2 &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lúc này, <strong>ptr1</strong> và <strong>ptr2</strong> cùng giữ địa chỉ của biến <strong>value</strong>.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/9.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p><strong><em>Khác với tham chiếu (reference), một con trỏ có thể trỏ đến địa chỉ khác trong bộ nhớ ảo sau khi đã được gán giá trị. Tham chiếu (reference) không thể thay đổi địa chỉ sau lần tham chiếu đầu tiên.</em></strong></p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int main()\n{\n\tint *ptr;\n\n\tint arr[5] = { 1, 2, 3, 4, 5 };\n\n\tfor(int i = 0; i &lt; 5; i++)\n\t{\n\t\tptr = &amp;arr[i];\n\t\tcout &lt;&lt; ptr &lt;&lt; endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả của đoạn chương trình này là:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/10.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Con trỏ <strong>ptr</strong> đã trỏ đến lần lượt 5 phần tử của mảng <strong>arr</strong>. Nếu các bạn để ý sẽ thấy 5 địa chỉ này liên tiếp nhau trên bộ nhớ ảo. Mình sẽ trình bày vấn đề này trong các bài học sau.</p>\n\n<h5>Các phép gán không hợp lệ khi sử dụng con trỏ</h5>\n\n<p>Phép gán của con trỏ chỉ thực hiện được khi kiểu dữ liệu của con trỏ phù hợp kiểu dữ liệu của biến mà nó sẽ trỏ tới. Do đó, các phép gán dưới đây là không hợp lệ:</p>\n\n<pre><code>int iValue = 0;\nfloat fValue = 0.0;\n\nint *i_ptr = fValue;   //wrong! int pointer cannot point to the address of a double variable\nfloat *f_ptr = iValue; //wrong! float pointer cannot point to the address of an int variable</code></pre>\n\n<p>Mặc dù giá trị mà con trỏ lưu trữ có kiểu <strong>unsigned int</strong>, nhưng chúng ta không thể gán trực tiếp một giá trị địa chỉ cho con trỏ được.</p>\n\n<pre><code>int *ptr = 1245052; //wrong!</code></pre>\n\n<p>Giá trị 1245052 không có địa chỉ cụ thể, trong khi đó, con trỏ chỉ nhận giá trị là địa chỉ nên phép gán trên là sai. Mặc dù giá trị được chuyển về dạng cơ số thập lục phân để tương xứng với định dạng giá trị mà con trỏ in ra, điều này cũng không được cho phép.</p>\n\n<pre><code>int *ptr = 0012FF7C; //wrong!</code></pre>\n\n<p><strong><em>Chỉ có giá trị kiểu con trỏ (có được nhờ toán tử address-of, hoặc từ một biến con trỏ cùng kiểu khác) mới có thể gán được cho biến con trỏ.</em></strong></p>\n\n<h5>Truy xuất giá trị bên trong vùng nhớ mà con trỏ trỏ đến</h5>\n\n<p>Khi chúng ta có một con trỏ đã được trỏ đến địa chỉ nào đó trong bộ nhớ ảo, chúng ta có thể truy xuất giá trị tại địa chỉ đó bằng <strong>dereference operator</strong>. <strong>Dereference operator</strong> sẽ đánh giá nội dung địa chỉ được trỏ đến.</p>\n\n<pre><code>int *ptr; //declare an int pointer\nint value = 5;\n\nptr = &amp;value; //ptr point to value\n\ncout &lt;&lt; &amp;value &lt;&lt; endl; //print the address of value\ncout &lt;&lt; ptr &lt;&lt; endl;    //print the address of value which is held in ptr\n\ncout &lt;&lt; value &lt;&lt; endl;  //print the content of value\ncout &lt;&lt; *(&amp;value) &lt;&lt; endl; //print the content of value\ncout &lt;&lt; *ptr &lt;&lt; endl;\t//print the content of value</code></pre>\n\n<p>Kết quả của đoạn chương trình trên như sau:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/11.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Toán tử trỏ đến (<strong>dereference operator</strong>) được dùng để truy cập trực tiếp vào vùng nhớ có địa chỉ cụ thể trên bộ nhớ ảo (<strong>virtual memory</strong>), vì biến con trỏ <strong>ptr</strong> đang giữ địa chỉ của biến <strong>value</strong> nên khi đặt toán tử trỏ đến (<strong>dereference operator</strong>) trước con trỏ <strong>ptr</strong>, nó sẽ truy xuất giá trị tại địa chỉ mà con trỏ <strong>ptr</strong> đang giữ.</p>\n\n<p>Vì <strong>ptr</strong> có kiểu dữ liệu <strong>con trỏ int</strong> (int *), <strong>ptr</strong> chỉ có thể trỏ đến biến kiểu <strong>int</strong>. Lúc này, <strong>compiler</strong> hiểu rằng cần phân tích <strong>4 bytes</strong> (đúng bằng kích thước kiểu <strong>int</strong>) trên bộ nhớ ảo tại địa chỉ mà <strong>ptr</strong> đang lưu trữ.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true\" class=\"lightbox\" title=\"12.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true\" width=\"690\" height=\"328\"><div class=\"meta\">\n<span class=\"filename\">12.png?raw=true</span><span class=\"informations\">764x364</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Đây là lý do tại sao chúng ta cần khai báo kiểu dữ liệu của con trỏ. Nếu không khai báo kiểu dữ liệu cho con trỏ, toán tử trỏ đến (<strong>dereference operator</strong>) sẽ không biết phải phân tích bao nhiêu bytes tại địa chỉ con trỏ trỏ đến để tính toán được giá trị của vùng nhớ đó. Không những thế, đây còn là lý do kiểu dữ liệu của biến phải tương xứng với kiểu dữ liệu được khai báo cho con trỏ.</p>\n\n<p>Vì chúng ta có thể gán lại địa chỉ mới cho một con trỏ, nên chúng ta có thể truy xuất được giá trị của nhiều vùng nhớ khác nhau chỉ với một con trỏ:</p>\n\n<pre><code>int value1 = 1;\nint value2 = 2;\n\nint *ptr = &amp;value1;\ncout &lt;&lt; *ptr &lt;&lt; endl;\n\nptr = &amp;value2;\ncout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>\n\n<p>Với khả năng truy cập đến vùng nhớ có địa chỉ cụ thể và thay đổi giá trị bên trong vùng nhớ của toán tử trỏ đến (<strong>dereference operator</strong>), chúng ta có thể sử dụng như sau:</p>\n\n<pre><code>int value = 5;\nint *ptr = &amp;value;\n\n*ptr = 10;\ncout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>\n\n<p>Đoạn chương trình này sẽ in ra giá trị <strong>10</strong>.</p>\n\n<p>Có thể giải thích dòng lệnh <code>*ptr = 10;</code> như sau:</p>\n\n<p>Biến con trỏ <strong>ptr</strong> sau khi khai báo đã được khởi tạo bằng cách gán địa chỉ của biến <strong>value</strong>. Sử dụng <strong>dereference operator</strong> cho con trỏ <strong>ptr</strong> để truy cập đến địa chỉ ảo mà <strong>ptr</strong> đang nắm giữ, gán giá trị 10 vào vùng nhớ tại vị trí đó.</p>\n\n<h5>Con trỏ chưa được gán địa chỉ</h5>\n\n<p>Con trỏ trong ngôn ngữ C/C++ vốn không an toàn. Nếu sử dụng con trỏ không hợp lý có thể gây crash chương trình.</p>\n\n<p>Khác với tham chiếu (<strong>reference</strong>), biến con trỏ có thể không cần khởi tạo giá trị ngay khi khai báo. Nhưng thực hiện truy xuất giá trị của con trỏ bằng dereference operator khi chưa gán địa chỉ cụ thể cho con trỏ, chương trình có thể bị đóng bởi hệ điều hành. Nguyên nhân là do con trỏ đang nắm giữ một giá trị rác, giá trị rác đó có thể là địa chỉ thuộc một vùng nhớ đang được ứng dụng khác sử dụng, hoặc giá trị vượt quá giới hạn của bộ nhớ ảo.</p>\n\n<p>Trong chế độ <strong>Debug</strong> của Visual studio 2015, trường hợp này sẽ bị cảnh báo và ngăn chặn chương trình thực thi.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int main()\n{\n\tint *ptr; //declare an int pointer\n\tcout &lt;&lt; *ptr &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Nhấn F5 để Debug chương trình sẽ nhận được thông báo:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/13.png?raw=true\" width=\"559\" height=\"318\"></p>\n\n<p>Do đó, khi khai báo con trỏ nhưng chưa có địa chỉ khởi tạo cụ thể, chúng ta nên gán cho con trỏ giá trị <strong>NULL</strong>.</p>\n\n<hr>\n\n<h3>NULL</h3>\n\n<p><strong>NULL</strong> là một macro đã được định nghĩa sẵn trong ngôn ngữ C/C++.</p>\n\n<pre><code>#define NULL 0</code></pre>\n\n<p>Đối với con trỏ, <strong>NULL</strong> là một giá trị đặc biệt, khi gán <strong>NULL</strong> cho con trỏ, điều đó có nghĩa là con trỏ đó chưa trỏ đến địa chỉ nào cả. Con trỏ đang giữ giá trị <strong>NULL</strong> được gọi là con trỏ <strong>NULL</strong> (<strong>NULL pointer</strong>).</p>\n\n<pre><code>int *ptr = NULL; //ptr is now a NULL pointer</code></pre>\n\n<p>Lúc này, chúng ta có thể kiểm tra xem con trỏ đã được gán địa chỉ cụ thể hay chưa:</p>\n\n<pre><code>int *ptr = NULL;\n\nif(ptr == NULL)\n{\n\tcout &lt;&lt; \"Do nothing\" &lt;&lt; endl;\n}\nelse\n{\n\tcout &lt;&lt; *ptr &lt;&lt; endl;\n}</code></pre>\n\n<p>Đoạn chương trình này sẽ giúp chương trình đảm bảo rằng con trỏ <strong>ptr</strong> sẽ không được sử dụng khi chưa được gán địa chỉ cụ thể.</p>\n\n<p>Chuẩn <strong>C++11</strong> cung cấp cho chúng ta từ khóa <strong>nullptr</strong> tương tự như macro <strong>NULL</strong>. Chúng ta có thể sử dụng như sau:</p>\n\n<pre><code>int *ptr = nullptr;</code></pre>\n\n<p>Bên cạnh đó, <strong>C++11</strong> còn định nghĩa cho chúng ta kiểu dữ liệu <code>std::nullptr_t</code>, <code>nullptr_t</code> chỉ có thể lưu trữ giá trị <strong>nullptr</strong>. Nhưng chúng ta ít khi sử dụng kiểu dữ liệu này nên các bạn cũng không cần quan tâm lắm.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, các bạn đã được tìm hiểu khái niệm con trỏ và một số khái niệm có liên quan. Việc sử dụng con trỏ thường có một số hoạt động chủ yếu: <strong>(a) khai báo một con trỏ, (b) gán địa chỉ cho con trỏ, (c) truy cập đến địa chỉ mà con trỏ đang nắm giữ bằng dereference operator</strong>.</p>\n\n<p>Thử liên hệ một chút với cuộc sống thực tế, tưởng tượng rằng con đường nhà bạn (street) là bộ nhớ ảo, trên con đường đó có rất nhiều ngôi nhà (house), mỗi ngôi nhà đều được đánh số thứ tự gọi là địa chỉ nhà (house's address). Chúng ta tạm hình dung số người ở trong mỗi ngôi nhà (content) tương đương với nội dung của mỗi ô trên bộ nhớ ảo. Như vậy, address-of operator (&amp;house) sẽ trả về địa chỉ của ngôi nhà, dereference operator (*&amp;house) sẽ lấy ra số lượng người bên trong ngôi nhà có địa chỉ được xác định. Để sử dụng con trỏ trỏ đến mỗi ngôi nhà, chúng ta phải sử dụng một con trỏ kiểu <strong>House</strong> (giống với kiểu của từng ngôi nhà), giả sử con trỏ kiểu <strong>House</strong> được khai báo là <code>House *h_ptr;</code> thì con trỏ <code>h_ptr</code> có thể trỏ đến bất kì ngôi nhà nào trên con đường, và nó còn có thể thay đổi nội dung bên trong từng ngôi nhà mà nó trỏ đến.</p>\n\n<p>Con trỏ (<strong>Pointer</strong>) là một công cụ mạnh mẽ đặc trưng của ngôn ngữ C/C++. Con trỏ cho phép chúng ta trực tiếp quản lý dung lượng của chương trình trên bộ nhớ ảo. Nhưng bên cạnh đó, việc sử dụng con trỏ không hợp lý có thể gây lãng phí tài nguyên của hệ thống máy tính. Chúng ta sẽ cùng tìm hiểu các kĩ thuật quản lý bộ nhớ ảo của chương trình trong các bài học tiếp theo.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","raw":"---json\n{\"title\":\"8.0 Con trỏ\",\"route\":\"8/0-con-tr\"}\n---\n\n<h4>Chào các bạn học viên đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong chương này, chúng ta sẽ cùng nhau tìm hiểu về khái niệm con trỏ (<strong>Pointer</strong>) - một đặc trưng của ngôn ngữ lập trình C/C++.</p>\n\n<p>Trước khi vào bài học này, chúng ta cùng nhau xem lại một số khái niệm liên quan đến vùng nhớ, địa chỉ của biến, tham chiếu...</p>\n\n<h5>Variable</h5>\n\n<p>Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình C++ nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu.</p>\n\n<p>Khi thao tác với các biến thông thường, chúng ta không cần quan tâm đến địa chỉ vùng nhớ của biến. Khi cần truy xuất giá trị của biến, chúng ta chỉ cần gọi định danh (hay thường gọi là tên biến).</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int money;</code></pre>\n\n<p>Khi dòng lệnh này được CPU thực thi, một vùng nhớ có kích thước 4 bytes sẽ được cấp phát. Lấy ví dụ biến money này được đặt tại ô nhớ 1224 (trong địa chỉ ảo của máy tính).</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/0.png?raw=true\" width=\"400\" height=\"300\"></p>\n\n<p>Bất cứ khi nào chương trình thấy các bạn sử dụng biến money trong câu lệnh, chương trình hiểu rằng cần tìm đến ô nhớ 1224 để lấy giá trị đó ra.</p>\n\n<h5>Virtual memory &amp; Physical memory</h5>\n\n<p>Việc truy xuất dữ liệu trên bộ nhớ máy tính cần phải thông qua một số bước trung gian, người dùng không thể trực tiếp truy xuất vào các ô nhớ trên các thiết bị lưu trữ. Chúng ta chỉ có thể trỏ đến vùng nhớ ảo (virtual memory) trên máy tính, còn việc truy xuất đến bộ nhớ vật lý (physical memory) từ bộ nhớ ảo phải được thực hiện bởi thiết bị phần cứng có tên là <strong>Memory management unit (MMU)</strong> và một chương trình định vị địa chỉ bộ nhớ gọi là <strong>Virtual address space</strong>.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true\" class=\"lightbox\" title=\"1.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/1.png?raw=true\" width=\"690\" height=\"373\"><div class=\"meta\">\n<span class=\"filename\">1.png?raw=true</span><span class=\"informations\">1045x566</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Virtual memory làm che giấu sự phân mảnh của bộ nhớ vật lý, khiến chúng ta có cảm giác đang thao tác với các vùng nhớ liên tục. Trong hình trên, từ phía Virtual memory cho đến Physical memory thuộc về phần quản lý của hệ điều hành, lập trình viên và người dùng chúng ta không thể can thiệp trực tiếp đến trong quá trình máy tính đang hoạt động.</p>\n\n<h5>Variable address &amp; address-of operator</h5>\n\n<p>Địa chỉ của biến mà chúng ta nhìn thấy thật ra chỉ là những giá trị đã được đánh số thứ tự đặt trên Virtual memory. Để lấy được địa chỉ ảo của biến trong chương trình, chúng ta sử dụng toán tử <strong>'&amp;'</strong> đặt trước tên biến.</p>\n\n<pre><code>int x = 5;\nstd::cout &lt;&lt; x &lt;&lt; '\\n'; // print the value of variable x\nstd::cout &lt;&lt; &amp;x &lt;&lt; '\\n'; // print the memory address of variable x</code></pre>\n\n<p>Trên máy tính của mình, kết quả của đoạn chương trình trên được in ra như sau:</p>\n\n<pre><code>5\n0027FEA0</code></pre>\n\n<p>Dòng đầu tiên là kết quả của việc truy xuất giá trị của biến thông qua định danh (tên biến). Dòng thứ hai là kết quả của việc truy xuất đến địa chỉ ảo của biến.</p>\n\n<h5>Tham chiếu (Reference)</h5>\n\n<p>Mục đích của tham chiếu trong C++ là tạo ra một biến khác có cùng kiểu dữ liệu nhưng sử dụng chung vùng nhớ với biến được tham chiếu đến.</p>\n\n<pre><code>int i1 = 10;\nint &amp;i_ref = i1;        //reference to i1, not means address of i1\n\ncout &lt;&lt; &amp;i1 &lt;&lt; endl;    //get address of i1\ncout &lt;&lt; &amp;i_ref &lt;&lt; endl; //get address of i_ref</code></pre>\n\n<p>Kết quả chúng ta được:</p>\n\n<pre><code>0xBFEB475C\n0xBFEB475C</code></pre>\n\n<p>Như vậy, mọi hành vi thay đổi giá trị của <code>i_ref</code> đều tác động trực tiếp đến <code>i1</code>.</p>\n\n<p><strong><em>Lưu ý: Biến tham chiếu sẽ có địa chỉ cố định sau khi khởi tạo. Chúng ta không thể tham chiếu lại lần nữa.</em></strong></p>\n\n<h5>Dereference operator</h5>\n\n<p>Toán tử trỏ đến (<strong>dereference operator</strong>) hay còn gọi là <strong>indirection operator</strong> (toán tử điều hành gián tiếp) được kí hiệu bằng dấu sao <strong>\" * \"</strong> cho phép chúng ta lấy ra giá trị của vùng nhớ có địa chỉ cụ thể.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int n = 5;\n\ncout &lt;&lt; n &lt;&lt; endl;     //print the value of variable n\ncout &lt;&lt; &amp;n &lt;&lt; endl;    //print the virtual memory address of variable n\ncout &lt;&lt; *(&amp;n) &lt;&lt; endl; //print the value at the virtual memory address of variable n</code></pre>\n\n<ul>\n<li><p>Dòng lệnh cout đầu tiên khá dễ hiểu, nó thực hiện in ra giá trị của biến n bằng cách gọi định danh n, còn lại phần truy xuất đến địa chỉ ảo của biến n sẽ do chương trình đảm nhiệm.</p></li>\n<li><p>Dòng lệnh cout thứ hai không dùng để lấy ra giá trị bên trong vùng nhớ mà biến n đang nắm giữ, mà nó lấy ra địa chỉ ảo của biến n.</p></li>\n<li><p>Dòng lệnh cout thứ ba chúng ta sử dụng toán tử trỏ đến <strong>\" * \"</strong> đặt trước toán tử <strong>address-of</strong>. Khi đó, <strong>(&amp;n)</strong> sẽ lấy ra địa chỉ ảo của biến n, và toán tử * sẽ truy xuất giá trị bên trong địa chỉ đó.</p></li>\n</ul>\n\n<p>Kết quả của đoạn chương trình trên là:</p>\n\n<pre><code>5\n0xBFD181AC\n5</code></pre>\n\n<p>Ngoài việc truy xuất giá trị trong vùng nhớ của một địa chỉ cụ thể, toán tử trỏ đến (<strong>dereference operator</strong>) còn có thể dùng để thay đổi giá trị bên trong vùng nhớ đó.</p>\n\n<pre><code>int n = 5;\ncout &lt;&lt; n &lt;&lt; endl;\n*(&amp;n) = 10;\ncout &lt;&lt; n &lt;&lt; endl;</code></pre>\n\n<p>Kết quả đoạn chương trình này là:</p>\n\n<pre><code>5\n10</code></pre>\n\n<p>Như vậy, <strong>dereference operator</strong> cho phép chúng ta thao tác trực tiếp trên <strong>Virtual memory</strong> mà không cần thông qua định danh (tên biến).</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true\" class=\"lightbox\" title=\"2.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/2.png?raw=true\" width=\"690\" height=\"430\"><div class=\"meta\">\n<span class=\"filename\">2.png?raw=true</span><span class=\"informations\">786x490</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Mặc dù <strong>dereference operator</strong> có kí hiệu giống <strong>multiplication operator</strong>, nhưng các bạn có thể phân biệt được vì <strong>dereference operator</strong> là toán tử một ngôi, trong khi đó, <strong>multiplication operator</strong> là toán tử hai ngôi.</p>\n\n<p>Khác với tham chiếu (<strong>reference</strong>), toán tử trỏ đến (<strong>dereference operator</strong>) không tạo ra một tên biến khác, mà nó truy xuất trực tiếp đến vùng nhớ có địa chỉ cụ thể trên <strong>Virtual memory</strong>.</p>\n\n<hr>\n\n<h3>Con trỏ (Pointer)</h3>\n\n<p>Với những khái niệm mình trình bày ở trên (một số khái niệm các bạn đã được học), bây giờ chúng ta có thể nói đến con trỏ (<strong>pointer</strong>).</p>\n\n<blockquote><p>Một con trỏ (a <strong>pointer</strong>) là một biến được dùng để lưu trữ địa chỉ của biến khác.</p></blockquote>\n\n<p>Khác với tham chiếu, con trỏ là một biến có địa chỉ độc lập so với vùng nhớ mà nó trỏ đến, nhưng giá trị bên trong vùng nhớ của con trỏ chính là địa chỉ của biến (hoặc địa chỉ ảo) mà nó trỏ tới.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true\" class=\"lightbox\" title=\"3.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/3.png?raw=true\" width=\"690\" height=\"411\"><div class=\"meta\">\n<span class=\"filename\">3.png?raw=true</span><span class=\"informations\">983x586</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Trong ví dụ trên, một con trỏ sau khi khai báo đã được cấp phát vùng nhớ tại địa chỉ 3255, và nó trỏ đến địa chỉ 1224, do đó, giá trị bên trong vùng nhớ của con trỏ là 1224.</p>\n\n<h5>Khai báo con trỏ</h5>\n\n<p>Cũng giống như biến thông thường, biến con trỏ cần được khai báo trước khi sử dụng. Con trỏ yêu cầu cú pháp khai báo mới hơn một chút so với biến thông thường.</p>\n\n<pre><code>&lt;data_type&gt; *&lt;name_of_pointer&gt;;</code></pre>\n\n<p>Khác với biến thông thường, chúng ta cần đặt thêm dấu sao giữa kiểu dữ liệu và tên biến của con trỏ.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int *iPtr;\nfloat *fPtr;\ndouble *dPtr;\n\nint *iPtr1, *iPtr2;</code></pre>\n\n<p><strong><em>Lưu ý: Dấu sao trong khai báo con trỏ không phải là toán tử trỏ đến (dereference operator), nó chỉ là cú pháp được ngôn ngữ C/C++ quy định.</em></strong></p>\n\n<h5>Cách khai báo dễ gây nhầm lẫn</h5>\n\n<p>Ngôn ngữ C/C++ yêu cầu đặt dấu sao giữa kiểu dữ liệu và tên con trỏ nhưng không bắt buộc phải đặt nó gần với kiểu dữ liệu hay gần với tên con trỏ. Do đó, những cách khai báo dưới đây đều được cho phép:</p>\n\n<pre><code>int *iPtr1; //We recommended you use this way to declare pointers\nint* iPtr2;</code></pre>\n\n<p>Nhưng mình khuyến nghị các bạn sử dụng cách khai báo đặt dấu sao ngay trước tên con trỏ vì cách thứ hai có thể gây nhầm lẫn.</p>\n\n<pre><code>int* iPtr1, iPtr2;</code></pre>\n\n<p>Với cách khai báo này, <strong>iPtr1</strong> là một con trỏ kiểu <strong>int</strong>, trong khi đó, <strong>iPtr2</strong> là một biến kiểu <strong>int</strong>. Để có được hai con trỏ, chúng ta cần khai báo như sau:</p>\n\n<pre><code>int *iPtr1, *iPtr2;</code></pre>\n\n<h5>Kích thước của con trỏ trong bộ nhớ</h5>\n\n<p>Các bạn cùng chạy thử đoạn chương trình dưới đây:</p>\n\n<pre><code>cout &lt;&lt; sizeof(char*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(int*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(double*) &lt;&lt; endl;\ncout &lt;&lt; sizeof(string*) &lt;&lt; endl;</code></pre>\n\n<p>Đoạn chương trình trên cho ra kết quả như sau:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/4.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Tại cửa sổ giao diện của Visual studio 2015, chúng ta chuyển sang Debug trên nền tảng 64 bits.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true\" class=\"lightbox\" title=\"5.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/5.png?raw=true\" width=\"690\" height=\"321\"><div class=\"meta\">\n<span class=\"filename\">5.png?raw=true</span><span class=\"informations\">901x420</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Nhấn F5 lại lần nữa và xem lại kết quả:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/6.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p><strong><em>Như vậy, chúng ta thấy rằng khi chạy trên nền tảng hệ điều hành 32 bits con trỏ sẽ có kích thước 4 bytes, khi chạy trên nền tảng hệ điều hành 64 bits con trỏ sẽ có kích thước 8 bytes.</em></strong></p>\n\n<p>Kiểu dữ liệu của con trỏ thay đổi không hề tác động đến kích thước bộ nhớ của con trỏ. Bởi vì giá trị thực sự của con trỏ là kiểu số nguyên không dấu (<strong>unsigned int</strong>), trong nền tảng hệ điều hành <strong>32 bits</strong>, giá trị mà con trỏ lưu trữ sẽ là <code>unsigned __int32</code>, và trong nền tảng hệ điều hành <strong>64 bits</strong>, giá trị của con trỏ lưu trữ có kiểu <code>unsigned __int64</code>.</p>\n\n<p><strong><em>Kiểu dữ liệu của con trỏ không mô tả giá trị địa chỉ được lưu trữ bên trong con trỏ, mà kiểu dữ liệu của con trỏ dùng để xác định kiểu dữ liệu của biến mà nó trỏ đến trên bộ nhớ ảo.</em></strong></p>\n\n<p>Vậy tại sao lại cần 4 bytes cho một con trỏ trong hệ điều hành 32 bits, và cần 8 bytes cho một con trỏ trong hệ điều hành 64 bits?</p>\n\n<p>Phạm vi giá trị của <code>unsigned __int32</code> là từ 0 đến 4294967295, phạm vi giá trị này đủ để đánh dấu địa chỉ tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>32 bits</strong>. Tương tự, phạm vi giá trị của <code>unsigned __int64</code> là tử 0 đến 18446744073709551615, đủ để đánh dấu địa chỉ của tất cả ô nhớ trong <strong>Virtual memory</strong> của nền tảng hệ điều hành <strong>64 bits</strong>.</p>\n\n<p>Dưới đây là thông tin Virtual memory trên máy tính của mình:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/virtual_memory.png?raw=true\" width=\"354\" height=\"465\"></p>\n\n<p>Dung lượng bộ nhớ ảo hiện tại của máy mình là <strong>1960MB</strong>, tương đương với <strong>2055208960 bytes</strong>. Trong khi đó, con trỏ trong nền tảng hệ điều hành <strong>32 bits</strong> có kích thước <strong>4 bytes</strong>, giá trị địa chỉ lớn nhất mà con trỏ <strong>4 bytes</strong> có thể lưu trữ được là <strong>4294967295</strong>, nên nó đủ để lưu trữ bất kì địa chỉ của biến nào được cấp phát trên bộ nhớ ảo.</p>\n\n<h5>Gán giá trị cho con trỏ</h5>\n\n<p>Giá trị mà biến con trỏ lưu trữ là địa chỉ của biến khác có cùng kiểu dữ liệu với biến con trỏ.</p>\n\n<pre><code>int *ptr;\nint value = 5;\n\nptr = &amp;value;</code></pre>\n\n<p>Do đó, chúng ta cần sử dụng <strong>address-of operator</strong> để lấy ra địa chỉ ảo của biến rồi mới gán cho con trỏ được. Lúc này, biến ptr sẽ lưu trữ địa chỉ ảo của biến value.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/7.png?raw=true\" width=\"409\" height=\"145\"></p>\n\n<p>(Nguồn: <a href=\"http://www.learncpp.com\" rel=\"nofollow\">www.learncpp.com</a>)</p>\n\n<p>Chúng ta có thể nói rằng con trỏ <strong>ptr</strong> đang nắm giữ địa chỉ của biến <strong>value</strong>, cũng có thể nói con trỏ <strong>ptr</strong> trỏ đến biến <strong>value</strong>.</p>\n\n<p>Đoạn chương trình sau sẽ in ra địa chỉ của biến value và giá trị được lưu bởi con trỏ ptr sau khi trỏ đến biến value:</p>\n\n<pre><code>int main()\n{\n\tint value = 5;\n\tint *ptr = &amp;value;\n\t\n\tcout &lt;&lt; &amp;value &lt;&lt; endl;\n\tcout &lt;&lt; ptr &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả thu được trên màn hình console:</p>\n\n<pre><code>0012FF7C\n0012FF7C</code></pre>\n\n<p>Lý do mà chúng ta gán được địa chỉ của biến <strong>value</strong> cho con trỏ kiểu <strong>int</strong> (int *) là vì <strong>address-of operator</strong> của một biến kiểu <strong>int</strong> trả về giá trị kiểu con trỏ kiểu <strong>int</strong> (int *).</p>\n\n<p>Thử xem xét đoạn chương trình sau:</p>\n\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\t\n\tint value = 5;\n\tcout &lt;&lt; typeid(&amp;value).name() &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả in ra màn hình của toán tử lấy địa chỉ ở trên là:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/8.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Do đó, chúng ta có thể gán <code>&amp;value</code> cho con trỏ kiểu <strong>int</strong> (int *).</p>\n\n<p>Bên cạnh đó, khi có hai con trỏ cùng kiểu thì chúng ta có thể gán trực tiếp mà không cần sử dụng <strong>address-of operator</strong>.</p>\n\n<pre><code>int main()\n{\n\tint value = 5;\n\tint *ptr1, *ptr2;\n\n\tptr1 = &amp;value; //ptr1 point to value\n\tptr2 = ptr1;   //assign value of ptr1 to ptr2\n\n\tcout &lt;&lt; ptr1 &lt;&lt; endl;\n\tcout &lt;&lt; ptr2 &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Lúc này, <strong>ptr1</strong> và <strong>ptr2</strong> cùng giữ địa chỉ của biến <strong>value</strong>.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/9.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p><strong><em>Khác với tham chiếu (reference), một con trỏ có thể trỏ đến địa chỉ khác trong bộ nhớ ảo sau khi đã được gán giá trị. Tham chiếu (reference) không thể thay đổi địa chỉ sau lần tham chiếu đầu tiên.</em></strong></p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int main()\n{\n\tint *ptr;\n\n\tint arr[5] = { 1, 2, 3, 4, 5 };\n\n\tfor(int i = 0; i &lt; 5; i++)\n\t{\n\t\tptr = &amp;arr[i];\n\t\tcout &lt;&lt; ptr &lt;&lt; endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Kết quả của đoạn chương trình này là:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/10.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Con trỏ <strong>ptr</strong> đã trỏ đến lần lượt 5 phần tử của mảng <strong>arr</strong>. Nếu các bạn để ý sẽ thấy 5 địa chỉ này liên tiếp nhau trên bộ nhớ ảo. Mình sẽ trình bày vấn đề này trong các bài học sau.</p>\n\n<h5>Các phép gán không hợp lệ khi sử dụng con trỏ</h5>\n\n<p>Phép gán của con trỏ chỉ thực hiện được khi kiểu dữ liệu của con trỏ phù hợp kiểu dữ liệu của biến mà nó sẽ trỏ tới. Do đó, các phép gán dưới đây là không hợp lệ:</p>\n\n<pre><code>int iValue = 0;\nfloat fValue = 0.0;\n\nint *i_ptr = fValue;   //wrong! int pointer cannot point to the address of a double variable\nfloat *f_ptr = iValue; //wrong! float pointer cannot point to the address of an int variable</code></pre>\n\n<p>Mặc dù giá trị mà con trỏ lưu trữ có kiểu <strong>unsigned int</strong>, nhưng chúng ta không thể gán trực tiếp một giá trị địa chỉ cho con trỏ được.</p>\n\n<pre><code>int *ptr = 1245052; //wrong!</code></pre>\n\n<p>Giá trị 1245052 không có địa chỉ cụ thể, trong khi đó, con trỏ chỉ nhận giá trị là địa chỉ nên phép gán trên là sai. Mặc dù giá trị được chuyển về dạng cơ số thập lục phân để tương xứng với định dạng giá trị mà con trỏ in ra, điều này cũng không được cho phép.</p>\n\n<pre><code>int *ptr = 0012FF7C; //wrong!</code></pre>\n\n<p><strong><em>Chỉ có giá trị kiểu con trỏ (có được nhờ toán tử address-of, hoặc từ một biến con trỏ cùng kiểu khác) mới có thể gán được cho biến con trỏ.</em></strong></p>\n\n<h5>Truy xuất giá trị bên trong vùng nhớ mà con trỏ trỏ đến</h5>\n\n<p>Khi chúng ta có một con trỏ đã được trỏ đến địa chỉ nào đó trong bộ nhớ ảo, chúng ta có thể truy xuất giá trị tại địa chỉ đó bằng <strong>dereference operator</strong>. <strong>Dereference operator</strong> sẽ đánh giá nội dung địa chỉ được trỏ đến.</p>\n\n<pre><code>int *ptr; //declare an int pointer\nint value = 5;\n\nptr = &amp;value; //ptr point to value\n\ncout &lt;&lt; &amp;value &lt;&lt; endl; //print the address of value\ncout &lt;&lt; ptr &lt;&lt; endl;    //print the address of value which is held in ptr\n\ncout &lt;&lt; value &lt;&lt; endl;  //print the content of value\ncout &lt;&lt; *(&amp;value) &lt;&lt; endl; //print the content of value\ncout &lt;&lt; *ptr &lt;&lt; endl;\t//print the content of value</code></pre>\n\n<p>Kết quả của đoạn chương trình trên như sau:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/11.png?raw=true\" width=\"677\" height=\"343\"></p>\n\n<p>Toán tử trỏ đến (<strong>dereference operator</strong>) được dùng để truy cập trực tiếp vào vùng nhớ có địa chỉ cụ thể trên bộ nhớ ảo (<strong>virtual memory</strong>), vì biến con trỏ <strong>ptr</strong> đang giữ địa chỉ của biến <strong>value</strong> nên khi đặt toán tử trỏ đến (<strong>dereference operator</strong>) trước con trỏ <strong>ptr</strong>, nó sẽ truy xuất giá trị tại địa chỉ mà con trỏ <strong>ptr</strong> đang giữ.</p>\n\n<p>Vì <strong>ptr</strong> có kiểu dữ liệu <strong>con trỏ int</strong> (int *), <strong>ptr</strong> chỉ có thể trỏ đến biến kiểu <strong>int</strong>. Lúc này, <strong>compiler</strong> hiểu rằng cần phân tích <strong>4 bytes</strong> (đúng bằng kích thước kiểu <strong>int</strong>) trên bộ nhớ ảo tại địa chỉ mà <strong>ptr</strong> đang lưu trữ.</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true\" class=\"lightbox\" title=\"12.png?raw=true\" rel=\"nofollow\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/12.png?raw=true\" width=\"690\" height=\"328\"><div class=\"meta\">\n<span class=\"filename\">12.png?raw=true</span><span class=\"informations\">764x364</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Đây là lý do tại sao chúng ta cần khai báo kiểu dữ liệu của con trỏ. Nếu không khai báo kiểu dữ liệu cho con trỏ, toán tử trỏ đến (<strong>dereference operator</strong>) sẽ không biết phải phân tích bao nhiêu bytes tại địa chỉ con trỏ trỏ đến để tính toán được giá trị của vùng nhớ đó. Không những thế, đây còn là lý do kiểu dữ liệu của biến phải tương xứng với kiểu dữ liệu được khai báo cho con trỏ.</p>\n\n<p>Vì chúng ta có thể gán lại địa chỉ mới cho một con trỏ, nên chúng ta có thể truy xuất được giá trị của nhiều vùng nhớ khác nhau chỉ với một con trỏ:</p>\n\n<pre><code>int value1 = 1;\nint value2 = 2;\n\nint *ptr = &amp;value1;\ncout &lt;&lt; *ptr &lt;&lt; endl;\n\nptr = &amp;value2;\ncout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>\n\n<p>Với khả năng truy cập đến vùng nhớ có địa chỉ cụ thể và thay đổi giá trị bên trong vùng nhớ của toán tử trỏ đến (<strong>dereference operator</strong>), chúng ta có thể sử dụng như sau:</p>\n\n<pre><code>int value = 5;\nint *ptr = &amp;value;\n\n*ptr = 10;\ncout &lt;&lt; *ptr &lt;&lt; endl;</code></pre>\n\n<p>Đoạn chương trình này sẽ in ra giá trị <strong>10</strong>.</p>\n\n<p>Có thể giải thích dòng lệnh <code>*ptr = 10;</code> như sau:</p>\n\n<p>Biến con trỏ <strong>ptr</strong> sau khi khai báo đã được khởi tạo bằng cách gán địa chỉ của biến <strong>value</strong>. Sử dụng <strong>dereference operator</strong> cho con trỏ <strong>ptr</strong> để truy cập đến địa chỉ ảo mà <strong>ptr</strong> đang nắm giữ, gán giá trị 10 vào vùng nhớ tại vị trí đó.</p>\n\n<h5>Con trỏ chưa được gán địa chỉ</h5>\n\n<p>Con trỏ trong ngôn ngữ C/C++ vốn không an toàn. Nếu sử dụng con trỏ không hợp lý có thể gây crash chương trình.</p>\n\n<p>Khác với tham chiếu (<strong>reference</strong>), biến con trỏ có thể không cần khởi tạo giá trị ngay khi khai báo. Nhưng thực hiện truy xuất giá trị của con trỏ bằng dereference operator khi chưa gán địa chỉ cụ thể cho con trỏ, chương trình có thể bị đóng bởi hệ điều hành. Nguyên nhân là do con trỏ đang nắm giữ một giá trị rác, giá trị rác đó có thể là địa chỉ thuộc một vùng nhớ đang được ứng dụng khác sử dụng, hoặc giá trị vượt quá giới hạn của bộ nhớ ảo.</p>\n\n<p>Trong chế độ <strong>Debug</strong> của Visual studio 2015, trường hợp này sẽ bị cảnh báo và ngăn chặn chương trình thực thi.</p>\n\n<p>Ví dụ:</p>\n\n<pre><code>int main()\n{\n\tint *ptr; //declare an int pointer\n\tcout &lt;&lt; *ptr &lt;&lt; endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n\n<p>Nhấn F5 để Debug chương trình sẽ nhận được thông báo:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/8-con-tro/8-0-con-tro/13.png?raw=true\" width=\"559\" height=\"318\"></p>\n\n<p>Do đó, khi khai báo con trỏ nhưng chưa có địa chỉ khởi tạo cụ thể, chúng ta nên gán cho con trỏ giá trị <strong>NULL</strong>.</p>\n\n<hr>\n\n<h3>NULL</h3>\n\n<p><strong>NULL</strong> là một macro đã được định nghĩa sẵn trong ngôn ngữ C/C++.</p>\n\n<pre><code>#define NULL 0</code></pre>\n\n<p>Đối với con trỏ, <strong>NULL</strong> là một giá trị đặc biệt, khi gán <strong>NULL</strong> cho con trỏ, điều đó có nghĩa là con trỏ đó chưa trỏ đến địa chỉ nào cả. Con trỏ đang giữ giá trị <strong>NULL</strong> được gọi là con trỏ <strong>NULL</strong> (<strong>NULL pointer</strong>).</p>\n\n<pre><code>int *ptr = NULL; //ptr is now a NULL pointer</code></pre>\n\n<p>Lúc này, chúng ta có thể kiểm tra xem con trỏ đã được gán địa chỉ cụ thể hay chưa:</p>\n\n<pre><code>int *ptr = NULL;\n\nif(ptr == NULL)\n{\n\tcout &lt;&lt; \"Do nothing\" &lt;&lt; endl;\n}\nelse\n{\n\tcout &lt;&lt; *ptr &lt;&lt; endl;\n}</code></pre>\n\n<p>Đoạn chương trình này sẽ giúp chương trình đảm bảo rằng con trỏ <strong>ptr</strong> sẽ không được sử dụng khi chưa được gán địa chỉ cụ thể.</p>\n\n<p>Chuẩn <strong>C++11</strong> cung cấp cho chúng ta từ khóa <strong>nullptr</strong> tương tự như macro <strong>NULL</strong>. Chúng ta có thể sử dụng như sau:</p>\n\n<pre><code>int *ptr = nullptr;</code></pre>\n\n<p>Bên cạnh đó, <strong>C++11</strong> còn định nghĩa cho chúng ta kiểu dữ liệu <code>std::nullptr_t</code>, <code>nullptr_t</code> chỉ có thể lưu trữ giá trị <strong>nullptr</strong>. Nhưng chúng ta ít khi sử dụng kiểu dữ liệu này nên các bạn cũng không cần quan tâm lắm.</p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, các bạn đã được tìm hiểu khái niệm con trỏ và một số khái niệm có liên quan. Việc sử dụng con trỏ thường có một số hoạt động chủ yếu: <strong>(a) khai báo một con trỏ, (b) gán địa chỉ cho con trỏ, (c) truy cập đến địa chỉ mà con trỏ đang nắm giữ bằng dereference operator</strong>.</p>\n\n<p>Thử liên hệ một chút với cuộc sống thực tế, tưởng tượng rằng con đường nhà bạn (street) là bộ nhớ ảo, trên con đường đó có rất nhiều ngôi nhà (house), mỗi ngôi nhà đều được đánh số thứ tự gọi là địa chỉ nhà (house's address). Chúng ta tạm hình dung số người ở trong mỗi ngôi nhà (content) tương đương với nội dung của mỗi ô trên bộ nhớ ảo. Như vậy, address-of operator (&amp;house) sẽ trả về địa chỉ của ngôi nhà, dereference operator (*&amp;house) sẽ lấy ra số lượng người bên trong ngôi nhà có địa chỉ được xác định. Để sử dụng con trỏ trỏ đến mỗi ngôi nhà, chúng ta phải sử dụng một con trỏ kiểu <strong>House</strong> (giống với kiểu của từng ngôi nhà), giả sử con trỏ kiểu <strong>House</strong> được khai báo là <code>House *h_ptr;</code> thì con trỏ <code>h_ptr</code> có thể trỏ đến bất kì ngôi nhà nào trên con đường, và nó còn có thể thay đổi nội dung bên trong từng ngôi nhà mà nó trỏ đến.</p>\n\n<p>Con trỏ (<strong>Pointer</strong>) là một công cụ mạnh mẽ đặc trưng của ngôn ngữ C/C++. Con trỏ cho phép chúng ta trực tiếp quản lý dung lượng của chương trình trên bộ nhớ ảo. Nhưng bên cạnh đó, việc sử dụng con trỏ không hợp lý có thể gây lãng phí tài nguyên của hệ thống máy tính. Chúng ta sẽ cùng tìm hiểu các kĩ thuật quản lý bộ nhớ ảo của chương trình trong các bài học tiếp theo.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n\n<hr>\n\n<h3>Link Videos khóa học</h3>\n\n<p><a href=\"https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview\" class=\"onebox\" target=\"_blank\" rel=\"nofollow\">https://www.udemy.com/c-co-ban-danh-cho-nguoi-moi-hoc-lap-trinh/learn/v4/overview</a></p>\n","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.c96a1fa2938a6be431d4ca1446f891e1.json"}}}</script><script src="/dnh-cpp/phenomic.browser.9aef6afea50b2450360e.js"></script></body></html>