{"head":{"title":"9.1 Structs","route":"9/1-structs","description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent…"},"body":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến C++.</h4>\n\n<p>Như các bạn đã biết, việc lập trình ứng dụng phần mềm chỉ đơn giản là tạo ra chương trình máy tính dùng để giải quyết một vấn đề nào đó trong cuộc sống. Để giải quyết được vấn đề, chúng ta cần cung cấp cho chương trình một lượng dữ liệu cần thiết, các câu lệnh sẽ xử lý các dữ liệu được đưa vào và cho ra kết quả mà người dùng mong muốn.</p>\n\n<p>Dữ liệu chúng ta thu thập được trong cuộc sống cần được biểu diễn theo một định dạng nào đó mà máy tính có thể hiểu được, và ngôn ngữ lập trình cung cấp cho chúng ta điều này, đó chính là kiểu dữ liệu. Mỗi kiểu dữ liệu sẽ có một định dạng khác nhau, và khi tạo ra những thực thể từ những kiểu dữ liệu khác nhau, chúng sẽ có định dạng khác nhau dựa trên kiểu dữ liệu mô tả chúng. Ví dụ kiểu số thực (float, double) sẽ có định dạng phần thập phân trong khi kiểu số nguyên (int, long, ...) thì không có.</p>\n\n<p>Việc chọn kiểu dữ liệu phù hợp để lưu trữ dữ liệu cần xử lý là rất quan trọng. Nhưng số lượng kiểu dữ liệu mà một ngôn ngữ lập trình (trong đó có C++) hổ trợ sẵn là khá hạn chế trong khi có những dữ liệu đặc tả cho vấn đề trong cuộc sống lại rất phức tạp. Ví dụ mình muốn biểu diễn một vài thông tin cá nhân của mình trên máy tính, mình có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::string name;\nstd::string currentJob;\nstd::string homeAddress;\nint birthYear;\nint birthMonth;\nint birthDay;\nfloat height;\nfloat weight;\n//...............</code></pre>\n\n<p>Nhìn vào đoạn chương trình trên, các bạn có thể thấy mình cần sử dụng đến 3 kiểu dữ liệu khác nhau để tạo ra 8 biến chỉ để lưu trữ một lượng thông tin cá nhân không đầy đủ của một cá thể nào đó. Những biến này hoàn toàn độc lập với nhau, giả sử những biến này được khai báo tại những vị trí khác nhau trong chương trình sẽ rất khó quản lý. Và sẽ rắc rối hơn nếu chúng ta muốn lưu trữ thông tin cá nhân của nhiều hơn một người, lúc này chúng ta cần khai báo thêm 8 biến tương tự như trên, hoặc sử dụng mảng một chiều như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::string name[10];\nstd::string currentJob[10];\nstd::string homeAddress[10];\nint birthYear[10];\nint birthMonth[10];\nint birthDay[10];\nfloat height[10];\nfloat weight[10];\n//...............</code></pre>\n\n<p>Như các bạn thấy, việc quản lý chương trình trở nên phức tạp so với những người mới học lập trình. Do đó, việc tự định nghĩa một kiểu dữ liệu mới phù hợp cho đặc thù của chương trình của mỗi người là điều cần thiết. Rất may mắn, ngôn ngữ C++ hổ trợ chúng ta tự định nghĩa kiểu dữ liệu mới từ những kiểu dữ liệu built-in. Kiểu dữ liệu mới mà chúng ta sẽ định nghĩa được tạo thành từ một hoặc một nhóm kiểu dữ liệu xây dựng sẵn để tạo ra một tập hợp các biến thuộc cùng nhóm, những biến cùng nhóm này dùng để lưu trữ các dữ liệu có liên quan với nhau trong kiểu dữ liệu mới. Chúng ta gọi kiểu dữ liệu tập hợp này là <strong>struct</strong>.</p>\n\n<h3>Struct</h3>\n\n<p>Một struct (viết tắt của structure) cho phép chúng ta nhóm nhiều biến của nhiều kiểu dữ liệu khác nhau để lưu trữ một tập hợp các dữ liệu cần thiết cho việc mô tả một đơn vị nào đó.</p>\n\n<h5>Khai báo struct</h5>\n\n<p>Để khai báo một cấu trúc mới (kiểu dữ liệu mới), chúng ta sử dụng từ khóa <strong>struct</strong>. Mặc dù một struct là một kiểu dữ liệu do lập trình viên tự định nghĩa, nó cũng cần được khai báo theo một cú pháp nhất định để compiler có thể hiểu được. Dưới đây là cú pháp để tạo ra một struct mới:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct &lt;name_of_new_type&gt;\n{\n\t&lt;variables&gt;;\n};</code></pre>\n\n<p>Trong đó:</p>\n\n<ul>\n<li>struct là từ khóa mà ngôn ngữ C++ cung cấp.</li>\n<li>\n<code>name_of_new_type</code> sẽ là tên của kiểu dữ liệu mới. Sau khi khai báo xong một struct, chúng ta có thể dùng tên struct để khai báo biến như những kiểu dữ liệu thông thường.</li>\n<li>\n<code>variables</code> là danh sách các biến dùng để lưu trữ dữ liệu phù hợp với yêu cầu lưu trữ dữ liệu của một đơn vị nào đó.</li>\n</ul>\n\n<p>Mình lấy một ví dụ để các bạn có thể dễ hình dung hơn:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct VietNamPeople\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int16 age;\n\tfloat height;\n\tfloat weight;\n\tbool isStudent;\n};</code></pre>\n\n<p>Như vậy, mình vừa định nghĩa xong một struct có tên là VietNamPeople, struct này bây giờ được coi là một kiểu dữ liệu mới là một tập hợp các biến ID, name, age, height, weight và isStudent. Những biến này được đặt vào chung một nhóm và mỗi biến sẽ lưu trữ một phần thông tin của một đơn vị là một con người Việt Nam.</p>\n\n<blockquote><p>Các bạn cần lưu ý về phạm vi sử dụng của kiểu dữ liệu tự định nghĩa cũng tương tự phạm vi sử dụng của biến trong chương trình, nhưng việc định nghĩa kiểu dữ liệu không yêu cầu hệ điều hành cấp phát bộ nhớ nên hoàn toàn không làm ảnh hưởng đến tài nguyên của hệ thống. Do đó, chúng ta nên định nghĩa kiểu dữ liệu mới cho phạm vi toàn cục (global scope) để kiểu dữ liệu mới này có thể được sử dụng trong toàn bộ file, thậm chí là sử dụng trong những file mã nguồn khác trong cùng project.</p></blockquote>\n\n<p>Khi các biến được đặt trong struct, chúng ta gọi chúng là trường dữ liệu của struct (fields). Một trường dữ liệu là một thành phần trong tập hợp các biến lưu trữ dữ liệu cần thiết cho một đơn vị. Ví dụ kiểu dữ liệu VietNamPeople có 6 trường dữ liệu là ID, name, age, height, weight và isStudent. Compiler có thể hiểu rằng khi một biến được tạo ra từ kiểu dữ liệu VietNamPeople, ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;</code></pre>\n\n<p>thì lúc này, leTranDat chỉ là một cái tên của một đơn vị được tạo thành từ tập hợp các trường dữ liệu ID, name, age, height, weight và isStudent mà mình đã định nghĩa cho kiểu dữ liệu VietNamPeople. Các bạn có thể hình dung như thế này:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" width=\"690\" height=\"326\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">825x390</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Đây chỉ là hình ảnh minh họa cho việc tổ chức dữ liệu các trường bên trong một biến kiểu VietNamPeople sau khi được tạo ra. Trên thực tế các trường sẽ có kích thước khác so với dự đoán (khi đến phần nâng cao của struct mình sẽ trình bày về vấn đề này), nhưng đối với các bạn mới học thì chưa cần quan tâm những điều này.</p>\n\n<p>Chúng ta có thể sử dụng kiểu dữ liệu VietNamPeople mà mình định nghĩa ở trên để tạo ra nhiều biến struct khác nhau:</p>\n\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;\nVietNamPeople dayNhauHoc;\nVietNamPeople ngoDoanTuan;\n//.....................</code></pre>\n\n<p>Như những biến thông thường, các biến struct này sẽ được cấp phát bộ nhớ tùy vào cách chọn kỹ thuật cấp phát.</p>\n\n<h5>Khởi tạo cho biến struct</h5>\n\n<p>Khởi tạo giá trị cho các trường dữ liệu trong một biến struct rắc rối hơn khởi tạo giá trị cho biến thông thường một chút. Ngôn ngữ C++ đã hổ trợ cho chúng ta một cách nhanh hơn là sử dụng một <strong>initializer list</strong>. Nó cho phép các bạn khởi tạo một hoặc nhiều trường dữ liệu trong một khai báo biến struct. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};\n\n//................\n\nEmployee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };</code></pre>\n\n<p>Các trường dữ liệu được khởi tạo lần lượt từ trên xuống dưới như trong phần định nghĩa struct có tên Employee. Lúc này, biến leTranDat sẽ chứa các thông tin được khởi tạo lần lượt là: <code>ID</code> = 1, <code>name</code> = \"Le Tran Dat\", <code>age</code> = 28 và <code>year_of_exp</code> = 5.</p>\n\n<p>Nếu initializer list không cung cấp đủ dữ liệu cho các trường dữ liệu, giá trị mặc định sẽ được dùng để khởi tạo. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee newEmp = { 1, \"new employee\" }; //age = 0, year_of_exp = 0 by default</code></pre>\n\n<p>Một tập hợp các giá trị của một biến struct được gọi là một Record (bản ghi).</p>\n\n<h5>Truy cập các trường dữ liệu của biến struct</h5>\n\n<p>Xem xét về struct Employee mình đã định nghĩa ở trên:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};</code></pre>\n\n<p>Kiểu dữ liệu Employee mô tả rằng mỗi biến kiểu Employee được tạo ra sẽ bao gồm 4 trường dữ liệu là <code>ID, name, age và year_of_exp</code>. Như vậy, bất kỳ biến nào có kiểu Employee đều có đủ 4 trường dữ liệu trên.</p>\n\n<p>Muốn truy xuất đến các trường dữ liệu của một biến struct, chúng ta sử dụng <strong>member selection operator</strong> (dấu chấm). Dưới đây là một ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat;\nleTranDat.ID = 1;\nleTranDat.name = \"Le Tran Dat\";\nleTranDat.age = 28;\nleTranDat.year_of_exp = 5;</code></pre>\n\n<p>Visual studio sẽ hổ trợ chúng ta liệt kê tất cả các trường dữ liệu của một biến struct khi sử dụng <strong>member selection operator</strong>.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/1.png?raw=true\" width=\"651\" height=\"285\"></p>\n\n<p>Các trường dữ liệu của một biến struct cũng là những biến thông thường, nhưng nó được gói gọn bên trong một biến struct, nên chúng ta phải sử dụng tên của biến struct và <strong>member selection operator</strong> để truy xuất đến chúng.</p>\n\n<p>Như vậy, thông qua tên biến struct, các trường dữ liệu được nhóm lại giúp chúng ta biết được trường dữ liệu đó được dùng cho đơn vị nào, điều này giúp chúng ta dễ dàng tổ chức chương trình ở quy mô lớn hơn.</p>\n\n<p>Vì các trường dữ liệu của một biến struct cũng là những biến thông thường, chúng ta cũng có thể sử dụng chúng để tính toán, so sánh, ...</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };\nEmployee juniorEmp = { 2, \"New employee\", 25, 1 };\n\nif (leTranDat.year_of_exp &gt; juniorEmp.year_of_exp)\n{\n\tstd::cout &lt;&lt; leTranDat.name &lt;&lt; \" has more experience than \" &lt;&lt; juniorEmp.name &lt;&lt; std::endl;\n}</code></pre>\n\n<p>Các trường dữ liệu của một struct sẽ tồn tại cùng với biến struct cho đến khi biến struct ra khỏi phạm vi sử dụng và bị hủy. Do đó, khi biến struct còn tồn tại, chúng ta vẫn có thể truy xuất đến các trường dữ liệu của nó.</p>\n\n<h5>Nhập và xuất dữ liệu cho biến struct</h5>\n\n<p>Cũng tương tự như nhập xuất dữ liệu cho biến thông thường, chỉ khác là chúng ta cần sử dụng thêm tên biến struct và <strong>member selection operator</strong> để compiler biết chúng ta nhập xuất cho trường dữ liệu của đơn vị nào. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp;\n\n//Input\nstd::cout &lt;&lt; \"Enter ID: \";\nstd::cin &gt;&gt; emp.ID;\n\nstd::cout &lt;&lt; \"Enter name: \";\nstd::getline(std::cin, emp.name);\n\nstd::cout &lt;&lt; \"Enter age: \";\nstd::cin &gt;&gt; emp.age;\n\nstd::cout &lt;&lt; \"Enter year of experience: \";\nstd::cin &gt;&gt; emp.year_of_exp;\n\n//Output\nstd::cout &lt;&lt; \"===================================\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.ID &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.name &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.age &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.year_of_exp &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"===================================\" &lt;&lt; std::endl;</code></pre>\n\n<h5>Structs và function</h5>\n\n<p>Một ưu điểm khi sử dụng struct là chúng ta không cần truyền tất cả các trường dữ liệu của một đơn vị nào đó mà chỉ cần sử dụng một biến struct làm tham số cho hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n};\n\nvoid printVector2D(Vector2D vec)\n{\n\tstd::cout &lt;&lt; \"(\" &lt;&lt; vec.x &lt;&lt; \",\" &lt;&lt; vec.y &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n\tVector2D vec = { 1, 4 };\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Trong ví dụ trên, mình sử dụng kiểu truyền dữ liệu giá trị nên tham số <code>Vector2D vec</code> của hàm printVector2D không làm thay đổi giá trị gốc của đối số. Các bạn cũng có thể thử truyền đối số là biến struct theo kiểu tham chiếu hoặc con trỏ, về mặt cơ bản, biến struct cũng là một biến có địa chỉ cụ thể nên chúng ta làm hoàn toàn tương tự như biến thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">void normalize(Vector2D &amp;vec)\n{\n\tfloat length = sqrt((vec.x * vec.x) + (vec.y * vec.y));\n\tvec.x = vec.x / length;\n\tvec.y = vec.y / length;\n}\n\nint main()\n{\n\tVector2D vec = { 1, 4 };\n\tprintVector2D(vec);\n\n\tnormalize(vec);\n\tprintVector2D(vec);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kiểu struct cũng có thể được dùng làm kiểu trả về của hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Vector2D addTwoVector(Vector2D vec1, Vector2D vec2)\n{\n\tVector2D result = { vec1.x + vec2.x, vec1.y + vec2.y };\n\treturn result;\n}\n\nint main()\n{\n\tVector2D vec1 = { 1, 2 };\n\tVector2D vec2 = { 2, 2 };\n\n\tVector2D result = addTwoVector(vec1, vec2);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể làm như trên vì ngôn ngữ C++ cho phép chúng ta gán biến struct cho một biến cùng kiểu struct khác. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Vector2D vec1 = { 1, 2 };\nVector2D vec2 = vec1;</code></pre>\n\n<p>Nhưng chúng ta không nên sử dụng phép gán trực tiếp như vậy, vì có thể trong struct còn có các yếu tố phức tạp khác như con trỏ, hoặc struct khác, ... và dễ gây ra sai sót. Quay trở lại với chủ đề mình đang trình bày.</p>\n\n<p>Chúng ta còn có thể định nghĩa các hàm bên trong phần định nghĩa của struct. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n\n<p>Trong ví dụ trên, hàm normalize được định nghĩa trong cùng khối lệnh của struct Vector2D, nên nó có thể trực tiếp truy cập đến biến x và y và thao tác với chúng. Nhưng x và y của struct Vector2D vẫn đang còn ở mức khái niệm, chỉ khi nào struct Vector2D được dùng để khai báo biến, biến x và y cũng như hàm normalize mới được tạo ra. Như mình đã nói ở trên, việc định nghĩa một kiểu dữ liệu mới chỉ là định nghĩa những dữ liệu sẽ tồn tại trong biến struct nếu nó được tạo ra.</p>\n\n<p>Hàm normalize được tạo ra nhưng chỉ được sử dụng khi một biến struct cụ thể gọi đến nó bằng <strong>member selection operator</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec = { 1, 4 };\n\tvec.normalize();\n\t\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Hàm normalize trong struct Vector2D chỉ có thể được gọi thông qua một biến struct cụ thể. Như vậy, khi chúng ta muốn chuẩn hóa một Vector2D, chúng ta không cần truyền biến struct kiểu Vector2D vào hàm <code>normalize(Vector2D)</code> nữa mà chỉ cần gọi hàm <code>normalize</code> được định nghĩa trong chính nó. Đây cũng là một ưu điểm khi sử dụng struct.</p>\n\n<p>Mình lấy thêm một ví dụ nữa về hàm được định nghĩa bên trong struct để các bạn dễ hình dung:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid setPosition(float X, float Y)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t}\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n\n<p>Mình vừa thêm vào struct Vector2D hàm <code>setPosition(float, float)</code>, lúc này mình không cần sử dụng <strong>initializer list</strong> để khởi tạo cho một biến kiểu Vector2D nữa, mà mình sẽ gọi hàm <code>setPosition(float, float)</code>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec;\n\tvec.setPosition(1, 4);\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Điều này cũng làm tăng thêm ý nghĩa cho mã nguồn chương trình, giúp code của các bạn dễ đọc hơn. Chúng ta sẽ còn nói đến việc định nghĩa hàm bên trong struct trong những bài học tiếp theo.</p>\n\n<h5>Nested structs</h5>\n\n<p>Struct là một tập hợp các kiểu dữ liệu dùng để tạo nên một kiểu dữ liệu mới, và một kiểu struct cũng là một kiểu dữ liệu, nên chúng ta có thể sử dụng một kiểu struct khác để làm một trường dữ liệu cho struct cần tạo ra. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Birthday\n{\n\t__int32 day;\n\t__int32 month;\n\t__int32 year;\n};\n\nstruct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\tBirthday birthday;\n\t__int32 year_of_exp;\n};</code></pre>\n\n<p>Trong trường hợp này, mình thay thế trường dữ liệu age bằng một trường dữ liệu kiểu Birthday đã được định nghĩa ở trên. Chúng ta có thể khởi tạo giá trị cho nested struct trên như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };</code></pre>\n\n<p>Để truy xuất đến giá trị thực của trường dữ liệu birthday, chúng ta cần sử dụng thêm 1 lần <strong>member selection operator</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };\n\nstd::cout &lt;&lt; emp.ID &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.name &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.birthday.day &lt;&lt; \"/\" &lt;&lt; emp.birthday.month &lt;&lt; \"/\" &lt;&lt;emp.birthday.year &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.year_of_exp &lt;&lt; std::endl;</code></pre>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã cùng nhau tìm hiểu cách để tạo ra một kiểu dữ liệu mới bằng từ khóa struct cung cấp bởi ngôn ngữ C++, một số thao tác cơ bản với biến struct.</p>\n\n<p>Struct là một khái niệm quan trọng trong ngôn ngữ C/C++, hiểu được structs là một bước quan trọng để tiếp cận hướng phát triển chương trình theo mô hình hướng đối tượng. Struct giúp chúng ta tổ chức chương trình hiệu quả hơn.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Các bạn hãy định nghĩa kiểu dữ liệu PhanSo đại diện cho kiểu phân số. Qua đó, viết chương trình cho phép người dùng thực hiện các phép cộng, trừ, nhân, chia 2 phân số.</p>\n\n<p>2/ Viết chương trình thực hiện phân tích thống kê cho một lớp học khoảng 20 sinh viên. Thông tin của mỗi sinh viên bao gồm ID, tên, tuổi, điểm tổng kết học kì 1, điểm tổng kết học kì 2. Những thông tin cần thống kê bao gồm:</p>\n\n<ul>\n<li>Điểm trung bình cuối năm của cả lớp.</li>\n<li>Điểm tổng kết cuối năm của sinh viên nào là cao nhất.</li>\n<li>Liệt kê danh sách những sinh viên có tiến bộ trong học tập (điểm tổng kết học kì 2 cao hơn điểm tổng kết học kì 1).</li>\n</ul>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","rawBody":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến C++.</h4>\n\n<p>Như các bạn đã biết, việc lập trình ứng dụng phần mềm chỉ đơn giản là tạo ra chương trình máy tính dùng để giải quyết một vấn đề nào đó trong cuộc sống. Để giải quyết được vấn đề, chúng ta cần cung cấp cho chương trình một lượng dữ liệu cần thiết, các câu lệnh sẽ xử lý các dữ liệu được đưa vào và cho ra kết quả mà người dùng mong muốn.</p>\n\n<p>Dữ liệu chúng ta thu thập được trong cuộc sống cần được biểu diễn theo một định dạng nào đó mà máy tính có thể hiểu được, và ngôn ngữ lập trình cung cấp cho chúng ta điều này, đó chính là kiểu dữ liệu. Mỗi kiểu dữ liệu sẽ có một định dạng khác nhau, và khi tạo ra những thực thể từ những kiểu dữ liệu khác nhau, chúng sẽ có định dạng khác nhau dựa trên kiểu dữ liệu mô tả chúng. Ví dụ kiểu số thực (float, double) sẽ có định dạng phần thập phân trong khi kiểu số nguyên (int, long, ...) thì không có.</p>\n\n<p>Việc chọn kiểu dữ liệu phù hợp để lưu trữ dữ liệu cần xử lý là rất quan trọng. Nhưng số lượng kiểu dữ liệu mà một ngôn ngữ lập trình (trong đó có C++) hổ trợ sẵn là khá hạn chế trong khi có những dữ liệu đặc tả cho vấn đề trong cuộc sống lại rất phức tạp. Ví dụ mình muốn biểu diễn một vài thông tin cá nhân của mình trên máy tính, mình có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::string name;\nstd::string currentJob;\nstd::string homeAddress;\nint birthYear;\nint birthMonth;\nint birthDay;\nfloat height;\nfloat weight;\n//...............</code></pre>\n\n<p>Nhìn vào đoạn chương trình trên, các bạn có thể thấy mình cần sử dụng đến 3 kiểu dữ liệu khác nhau để tạo ra 8 biến chỉ để lưu trữ một lượng thông tin cá nhân không đầy đủ của một cá thể nào đó. Những biến này hoàn toàn độc lập với nhau, giả sử những biến này được khai báo tại những vị trí khác nhau trong chương trình sẽ rất khó quản lý. Và sẽ rắc rối hơn nếu chúng ta muốn lưu trữ thông tin cá nhân của nhiều hơn một người, lúc này chúng ta cần khai báo thêm 8 biến tương tự như trên, hoặc sử dụng mảng một chiều như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::string name[10];\nstd::string currentJob[10];\nstd::string homeAddress[10];\nint birthYear[10];\nint birthMonth[10];\nint birthDay[10];\nfloat height[10];\nfloat weight[10];\n//...............</code></pre>\n\n<p>Như các bạn thấy, việc quản lý chương trình trở nên phức tạp so với những người mới học lập trình. Do đó, việc tự định nghĩa một kiểu dữ liệu mới phù hợp cho đặc thù của chương trình của mỗi người là điều cần thiết. Rất may mắn, ngôn ngữ C++ hổ trợ chúng ta tự định nghĩa kiểu dữ liệu mới từ những kiểu dữ liệu built-in. Kiểu dữ liệu mới mà chúng ta sẽ định nghĩa được tạo thành từ một hoặc một nhóm kiểu dữ liệu xây dựng sẵn để tạo ra một tập hợp các biến thuộc cùng nhóm, những biến cùng nhóm này dùng để lưu trữ các dữ liệu có liên quan với nhau trong kiểu dữ liệu mới. Chúng ta gọi kiểu dữ liệu tập hợp này là <strong>struct</strong>.</p>\n\n<h3>Struct</h3>\n\n<p>Một struct (viết tắt của structure) cho phép chúng ta nhóm nhiều biến của nhiều kiểu dữ liệu khác nhau để lưu trữ một tập hợp các dữ liệu cần thiết cho việc mô tả một đơn vị nào đó.</p>\n\n<h5>Khai báo struct</h5>\n\n<p>Để khai báo một cấu trúc mới (kiểu dữ liệu mới), chúng ta sử dụng từ khóa <strong>struct</strong>. Mặc dù một struct là một kiểu dữ liệu do lập trình viên tự định nghĩa, nó cũng cần được khai báo theo một cú pháp nhất định để compiler có thể hiểu được. Dưới đây là cú pháp để tạo ra một struct mới:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct &lt;name_of_new_type&gt;\n{\n\t&lt;variables&gt;;\n};</code></pre>\n\n<p>Trong đó:</p>\n\n<ul>\n<li>struct là từ khóa mà ngôn ngữ C++ cung cấp.</li>\n<li>\n<code>name_of_new_type</code> sẽ là tên của kiểu dữ liệu mới. Sau khi khai báo xong một struct, chúng ta có thể dùng tên struct để khai báo biến như những kiểu dữ liệu thông thường.</li>\n<li>\n<code>variables</code> là danh sách các biến dùng để lưu trữ dữ liệu phù hợp với yêu cầu lưu trữ dữ liệu của một đơn vị nào đó.</li>\n</ul>\n\n<p>Mình lấy một ví dụ để các bạn có thể dễ hình dung hơn:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct VietNamPeople\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int16 age;\n\tfloat height;\n\tfloat weight;\n\tbool isStudent;\n};</code></pre>\n\n<p>Như vậy, mình vừa định nghĩa xong một struct có tên là VietNamPeople, struct này bây giờ được coi là một kiểu dữ liệu mới là một tập hợp các biến ID, name, age, height, weight và isStudent. Những biến này được đặt vào chung một nhóm và mỗi biến sẽ lưu trữ một phần thông tin của một đơn vị là một con người Việt Nam.</p>\n\n<blockquote><p>Các bạn cần lưu ý về phạm vi sử dụng của kiểu dữ liệu tự định nghĩa cũng tương tự phạm vi sử dụng của biến trong chương trình, nhưng việc định nghĩa kiểu dữ liệu không yêu cầu hệ điều hành cấp phát bộ nhớ nên hoàn toàn không làm ảnh hưởng đến tài nguyên của hệ thống. Do đó, chúng ta nên định nghĩa kiểu dữ liệu mới cho phạm vi toàn cục (global scope) để kiểu dữ liệu mới này có thể được sử dụng trong toàn bộ file, thậm chí là sử dụng trong những file mã nguồn khác trong cùng project.</p></blockquote>\n\n<p>Khi các biến được đặt trong struct, chúng ta gọi chúng là trường dữ liệu của struct (fields). Một trường dữ liệu là một thành phần trong tập hợp các biến lưu trữ dữ liệu cần thiết cho một đơn vị. Ví dụ kiểu dữ liệu VietNamPeople có 6 trường dữ liệu là ID, name, age, height, weight và isStudent. Compiler có thể hiểu rằng khi một biến được tạo ra từ kiểu dữ liệu VietNamPeople, ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;</code></pre>\n\n<p>thì lúc này, leTranDat chỉ là một cái tên của một đơn vị được tạo thành từ tập hợp các trường dữ liệu ID, name, age, height, weight và isStudent mà mình đã định nghĩa cho kiểu dữ liệu VietNamPeople. Các bạn có thể hình dung như thế này:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" width=\"690\" height=\"326\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">825x390</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Đây chỉ là hình ảnh minh họa cho việc tổ chức dữ liệu các trường bên trong một biến kiểu VietNamPeople sau khi được tạo ra. Trên thực tế các trường sẽ có kích thước khác so với dự đoán (khi đến phần nâng cao của struct mình sẽ trình bày về vấn đề này), nhưng đối với các bạn mới học thì chưa cần quan tâm những điều này.</p>\n\n<p>Chúng ta có thể sử dụng kiểu dữ liệu VietNamPeople mà mình định nghĩa ở trên để tạo ra nhiều biến struct khác nhau:</p>\n\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;\nVietNamPeople dayNhauHoc;\nVietNamPeople ngoDoanTuan;\n//.....................</code></pre>\n\n<p>Như những biến thông thường, các biến struct này sẽ được cấp phát bộ nhớ tùy vào cách chọn kỹ thuật cấp phát.</p>\n\n<h5>Khởi tạo cho biến struct</h5>\n\n<p>Khởi tạo giá trị cho các trường dữ liệu trong một biến struct rắc rối hơn khởi tạo giá trị cho biến thông thường một chút. Ngôn ngữ C++ đã hổ trợ cho chúng ta một cách nhanh hơn là sử dụng một <strong>initializer list</strong>. Nó cho phép các bạn khởi tạo một hoặc nhiều trường dữ liệu trong một khai báo biến struct. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};\n\n//................\n\nEmployee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };</code></pre>\n\n<p>Các trường dữ liệu được khởi tạo lần lượt từ trên xuống dưới như trong phần định nghĩa struct có tên Employee. Lúc này, biến leTranDat sẽ chứa các thông tin được khởi tạo lần lượt là: <code>ID</code> = 1, <code>name</code> = \"Le Tran Dat\", <code>age</code> = 28 và <code>year_of_exp</code> = 5.</p>\n\n<p>Nếu initializer list không cung cấp đủ dữ liệu cho các trường dữ liệu, giá trị mặc định sẽ được dùng để khởi tạo. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee newEmp = { 1, \"new employee\" }; //age = 0, year_of_exp = 0 by default</code></pre>\n\n<p>Một tập hợp các giá trị của một biến struct được gọi là một Record (bản ghi).</p>\n\n<h5>Truy cập các trường dữ liệu của biến struct</h5>\n\n<p>Xem xét về struct Employee mình đã định nghĩa ở trên:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};</code></pre>\n\n<p>Kiểu dữ liệu Employee mô tả rằng mỗi biến kiểu Employee được tạo ra sẽ bao gồm 4 trường dữ liệu là <code>ID, name, age và year_of_exp</code>. Như vậy, bất kỳ biến nào có kiểu Employee đều có đủ 4 trường dữ liệu trên.</p>\n\n<p>Muốn truy xuất đến các trường dữ liệu của một biến struct, chúng ta sử dụng <strong>member selection operator</strong> (dấu chấm). Dưới đây là một ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat;\nleTranDat.ID = 1;\nleTranDat.name = \"Le Tran Dat\";\nleTranDat.age = 28;\nleTranDat.year_of_exp = 5;</code></pre>\n\n<p>Visual studio sẽ hổ trợ chúng ta liệt kê tất cả các trường dữ liệu của một biến struct khi sử dụng <strong>member selection operator</strong>.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/1.png?raw=true\" width=\"651\" height=\"285\"></p>\n\n<p>Các trường dữ liệu của một biến struct cũng là những biến thông thường, nhưng nó được gói gọn bên trong một biến struct, nên chúng ta phải sử dụng tên của biến struct và <strong>member selection operator</strong> để truy xuất đến chúng.</p>\n\n<p>Như vậy, thông qua tên biến struct, các trường dữ liệu được nhóm lại giúp chúng ta biết được trường dữ liệu đó được dùng cho đơn vị nào, điều này giúp chúng ta dễ dàng tổ chức chương trình ở quy mô lớn hơn.</p>\n\n<p>Vì các trường dữ liệu của một biến struct cũng là những biến thông thường, chúng ta cũng có thể sử dụng chúng để tính toán, so sánh, ...</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };\nEmployee juniorEmp = { 2, \"New employee\", 25, 1 };\n\nif (leTranDat.year_of_exp &gt; juniorEmp.year_of_exp)\n{\n\tstd::cout &lt;&lt; leTranDat.name &lt;&lt; \" has more experience than \" &lt;&lt; juniorEmp.name &lt;&lt; std::endl;\n}</code></pre>\n\n<p>Các trường dữ liệu của một struct sẽ tồn tại cùng với biến struct cho đến khi biến struct ra khỏi phạm vi sử dụng và bị hủy. Do đó, khi biến struct còn tồn tại, chúng ta vẫn có thể truy xuất đến các trường dữ liệu của nó.</p>\n\n<h5>Nhập và xuất dữ liệu cho biến struct</h5>\n\n<p>Cũng tương tự như nhập xuất dữ liệu cho biến thông thường, chỉ khác là chúng ta cần sử dụng thêm tên biến struct và <strong>member selection operator</strong> để compiler biết chúng ta nhập xuất cho trường dữ liệu của đơn vị nào. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp;\n\n//Input\nstd::cout &lt;&lt; \"Enter ID: \";\nstd::cin &gt;&gt; emp.ID;\n\nstd::cout &lt;&lt; \"Enter name: \";\nstd::getline(std::cin, emp.name);\n\nstd::cout &lt;&lt; \"Enter age: \";\nstd::cin &gt;&gt; emp.age;\n\nstd::cout &lt;&lt; \"Enter year of experience: \";\nstd::cin &gt;&gt; emp.year_of_exp;\n\n//Output\nstd::cout &lt;&lt; \"===================================\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.ID &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.name &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.age &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.year_of_exp &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"===================================\" &lt;&lt; std::endl;</code></pre>\n\n<h5>Structs và function</h5>\n\n<p>Một ưu điểm khi sử dụng struct là chúng ta không cần truyền tất cả các trường dữ liệu của một đơn vị nào đó mà chỉ cần sử dụng một biến struct làm tham số cho hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n};\n\nvoid printVector2D(Vector2D vec)\n{\n\tstd::cout &lt;&lt; \"(\" &lt;&lt; vec.x &lt;&lt; \",\" &lt;&lt; vec.y &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n\tVector2D vec = { 1, 4 };\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Trong ví dụ trên, mình sử dụng kiểu truyền dữ liệu giá trị nên tham số <code>Vector2D vec</code> của hàm printVector2D không làm thay đổi giá trị gốc của đối số. Các bạn cũng có thể thử truyền đối số là biến struct theo kiểu tham chiếu hoặc con trỏ, về mặt cơ bản, biến struct cũng là một biến có địa chỉ cụ thể nên chúng ta làm hoàn toàn tương tự như biến thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">void normalize(Vector2D &amp;vec)\n{\n\tfloat length = sqrt((vec.x * vec.x) + (vec.y * vec.y));\n\tvec.x = vec.x / length;\n\tvec.y = vec.y / length;\n}\n\nint main()\n{\n\tVector2D vec = { 1, 4 };\n\tprintVector2D(vec);\n\n\tnormalize(vec);\n\tprintVector2D(vec);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kiểu struct cũng có thể được dùng làm kiểu trả về của hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Vector2D addTwoVector(Vector2D vec1, Vector2D vec2)\n{\n\tVector2D result = { vec1.x + vec2.x, vec1.y + vec2.y };\n\treturn result;\n}\n\nint main()\n{\n\tVector2D vec1 = { 1, 2 };\n\tVector2D vec2 = { 2, 2 };\n\n\tVector2D result = addTwoVector(vec1, vec2);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể làm như trên vì ngôn ngữ C++ cho phép chúng ta gán biến struct cho một biến cùng kiểu struct khác. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Vector2D vec1 = { 1, 2 };\nVector2D vec2 = vec1;</code></pre>\n\n<p>Nhưng chúng ta không nên sử dụng phép gán trực tiếp như vậy, vì có thể trong struct còn có các yếu tố phức tạp khác như con trỏ, hoặc struct khác, ... và dễ gây ra sai sót. Quay trở lại với chủ đề mình đang trình bày.</p>\n\n<p>Chúng ta còn có thể định nghĩa các hàm bên trong phần định nghĩa của struct. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n\n<p>Trong ví dụ trên, hàm normalize được định nghĩa trong cùng khối lệnh của struct Vector2D, nên nó có thể trực tiếp truy cập đến biến x và y và thao tác với chúng. Nhưng x và y của struct Vector2D vẫn đang còn ở mức khái niệm, chỉ khi nào struct Vector2D được dùng để khai báo biến, biến x và y cũng như hàm normalize mới được tạo ra. Như mình đã nói ở trên, việc định nghĩa một kiểu dữ liệu mới chỉ là định nghĩa những dữ liệu sẽ tồn tại trong biến struct nếu nó được tạo ra.</p>\n\n<p>Hàm normalize được tạo ra nhưng chỉ được sử dụng khi một biến struct cụ thể gọi đến nó bằng <strong>member selection operator</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec = { 1, 4 };\n\tvec.normalize();\n\t\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Hàm normalize trong struct Vector2D chỉ có thể được gọi thông qua một biến struct cụ thể. Như vậy, khi chúng ta muốn chuẩn hóa một Vector2D, chúng ta không cần truyền biến struct kiểu Vector2D vào hàm <code>normalize(Vector2D)</code> nữa mà chỉ cần gọi hàm <code>normalize</code> được định nghĩa trong chính nó. Đây cũng là một ưu điểm khi sử dụng struct.</p>\n\n<p>Mình lấy thêm một ví dụ nữa về hàm được định nghĩa bên trong struct để các bạn dễ hình dung:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid setPosition(float X, float Y)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t}\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n\n<p>Mình vừa thêm vào struct Vector2D hàm <code>setPosition(float, float)</code>, lúc này mình không cần sử dụng <strong>initializer list</strong> để khởi tạo cho một biến kiểu Vector2D nữa, mà mình sẽ gọi hàm <code>setPosition(float, float)</code>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec;\n\tvec.setPosition(1, 4);\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Điều này cũng làm tăng thêm ý nghĩa cho mã nguồn chương trình, giúp code của các bạn dễ đọc hơn. Chúng ta sẽ còn nói đến việc định nghĩa hàm bên trong struct trong những bài học tiếp theo.</p>\n\n<h5>Nested structs</h5>\n\n<p>Struct là một tập hợp các kiểu dữ liệu dùng để tạo nên một kiểu dữ liệu mới, và một kiểu struct cũng là một kiểu dữ liệu, nên chúng ta có thể sử dụng một kiểu struct khác để làm một trường dữ liệu cho struct cần tạo ra. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Birthday\n{\n\t__int32 day;\n\t__int32 month;\n\t__int32 year;\n};\n\nstruct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\tBirthday birthday;\n\t__int32 year_of_exp;\n};</code></pre>\n\n<p>Trong trường hợp này, mình thay thế trường dữ liệu age bằng một trường dữ liệu kiểu Birthday đã được định nghĩa ở trên. Chúng ta có thể khởi tạo giá trị cho nested struct trên như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };</code></pre>\n\n<p>Để truy xuất đến giá trị thực của trường dữ liệu birthday, chúng ta cần sử dụng thêm 1 lần <strong>member selection operator</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };\n\nstd::cout &lt;&lt; emp.ID &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.name &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.birthday.day &lt;&lt; \"/\" &lt;&lt; emp.birthday.month &lt;&lt; \"/\" &lt;&lt;emp.birthday.year &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.year_of_exp &lt;&lt; std::endl;</code></pre>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã cùng nhau tìm hiểu cách để tạo ra một kiểu dữ liệu mới bằng từ khóa struct cung cấp bởi ngôn ngữ C++, một số thao tác cơ bản với biến struct.</p>\n\n<p>Struct là một khái niệm quan trọng trong ngôn ngữ C/C++, hiểu được structs là một bước quan trọng để tiếp cận hướng phát triển chương trình theo mô hình hướng đối tượng. Struct giúp chúng ta tổ chức chương trình hiệu quả hơn.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Các bạn hãy định nghĩa kiểu dữ liệu PhanSo đại diện cho kiểu phân số. Qua đó, viết chương trình cho phép người dùng thực hiện các phép cộng, trừ, nhân, chia 2 phân số.</p>\n\n<p>2/ Viết chương trình thực hiện phân tích thống kê cho một lớp học khoảng 20 sinh viên. Thông tin của mỗi sinh viên bao gồm ID, tên, tuổi, điểm tổng kết học kì 1, điểm tổng kết học kì 2. Những thông tin cần thống kê bao gồm:</p>\n\n<ul>\n<li>Điểm trung bình cuối năm của cả lớp.</li>\n<li>Điểm tổng kết cuối năm của sinh viên nào là cao nhất.</li>\n<li>Liệt kê danh sách những sinh viên có tiến bộ trong học tập (điểm tổng kết học kì 2 cao hơn điểm tổng kết học kì 1).</li>\n</ul>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","raw":"---json\n{\"title\":\"9.1 Structs\",\"route\":\"9/1-structs\"}\n---\n\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến C++.</h4>\n\n<p>Như các bạn đã biết, việc lập trình ứng dụng phần mềm chỉ đơn giản là tạo ra chương trình máy tính dùng để giải quyết một vấn đề nào đó trong cuộc sống. Để giải quyết được vấn đề, chúng ta cần cung cấp cho chương trình một lượng dữ liệu cần thiết, các câu lệnh sẽ xử lý các dữ liệu được đưa vào và cho ra kết quả mà người dùng mong muốn.</p>\n\n<p>Dữ liệu chúng ta thu thập được trong cuộc sống cần được biểu diễn theo một định dạng nào đó mà máy tính có thể hiểu được, và ngôn ngữ lập trình cung cấp cho chúng ta điều này, đó chính là kiểu dữ liệu. Mỗi kiểu dữ liệu sẽ có một định dạng khác nhau, và khi tạo ra những thực thể từ những kiểu dữ liệu khác nhau, chúng sẽ có định dạng khác nhau dựa trên kiểu dữ liệu mô tả chúng. Ví dụ kiểu số thực (float, double) sẽ có định dạng phần thập phân trong khi kiểu số nguyên (int, long, ...) thì không có.</p>\n\n<p>Việc chọn kiểu dữ liệu phù hợp để lưu trữ dữ liệu cần xử lý là rất quan trọng. Nhưng số lượng kiểu dữ liệu mà một ngôn ngữ lập trình (trong đó có C++) hổ trợ sẵn là khá hạn chế trong khi có những dữ liệu đặc tả cho vấn đề trong cuộc sống lại rất phức tạp. Ví dụ mình muốn biểu diễn một vài thông tin cá nhân của mình trên máy tính, mình có thể làm như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::string name;\nstd::string currentJob;\nstd::string homeAddress;\nint birthYear;\nint birthMonth;\nint birthDay;\nfloat height;\nfloat weight;\n//...............</code></pre>\n\n<p>Nhìn vào đoạn chương trình trên, các bạn có thể thấy mình cần sử dụng đến 3 kiểu dữ liệu khác nhau để tạo ra 8 biến chỉ để lưu trữ một lượng thông tin cá nhân không đầy đủ của một cá thể nào đó. Những biến này hoàn toàn độc lập với nhau, giả sử những biến này được khai báo tại những vị trí khác nhau trong chương trình sẽ rất khó quản lý. Và sẽ rắc rối hơn nếu chúng ta muốn lưu trữ thông tin cá nhân của nhiều hơn một người, lúc này chúng ta cần khai báo thêm 8 biến tương tự như trên, hoặc sử dụng mảng một chiều như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::string name[10];\nstd::string currentJob[10];\nstd::string homeAddress[10];\nint birthYear[10];\nint birthMonth[10];\nint birthDay[10];\nfloat height[10];\nfloat weight[10];\n//...............</code></pre>\n\n<p>Như các bạn thấy, việc quản lý chương trình trở nên phức tạp so với những người mới học lập trình. Do đó, việc tự định nghĩa một kiểu dữ liệu mới phù hợp cho đặc thù của chương trình của mỗi người là điều cần thiết. Rất may mắn, ngôn ngữ C++ hổ trợ chúng ta tự định nghĩa kiểu dữ liệu mới từ những kiểu dữ liệu built-in. Kiểu dữ liệu mới mà chúng ta sẽ định nghĩa được tạo thành từ một hoặc một nhóm kiểu dữ liệu xây dựng sẵn để tạo ra một tập hợp các biến thuộc cùng nhóm, những biến cùng nhóm này dùng để lưu trữ các dữ liệu có liên quan với nhau trong kiểu dữ liệu mới. Chúng ta gọi kiểu dữ liệu tập hợp này là <strong>struct</strong>.</p>\n\n<h3>Struct</h3>\n\n<p>Một struct (viết tắt của structure) cho phép chúng ta nhóm nhiều biến của nhiều kiểu dữ liệu khác nhau để lưu trữ một tập hợp các dữ liệu cần thiết cho việc mô tả một đơn vị nào đó.</p>\n\n<h5>Khai báo struct</h5>\n\n<p>Để khai báo một cấu trúc mới (kiểu dữ liệu mới), chúng ta sử dụng từ khóa <strong>struct</strong>. Mặc dù một struct là một kiểu dữ liệu do lập trình viên tự định nghĩa, nó cũng cần được khai báo theo một cú pháp nhất định để compiler có thể hiểu được. Dưới đây là cú pháp để tạo ra một struct mới:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct &lt;name_of_new_type&gt;\n{\n\t&lt;variables&gt;;\n};</code></pre>\n\n<p>Trong đó:</p>\n\n<ul>\n<li>struct là từ khóa mà ngôn ngữ C++ cung cấp.</li>\n<li>\n<code>name_of_new_type</code> sẽ là tên của kiểu dữ liệu mới. Sau khi khai báo xong một struct, chúng ta có thể dùng tên struct để khai báo biến như những kiểu dữ liệu thông thường.</li>\n<li>\n<code>variables</code> là danh sách các biến dùng để lưu trữ dữ liệu phù hợp với yêu cầu lưu trữ dữ liệu của một đơn vị nào đó.</li>\n</ul>\n\n<p>Mình lấy một ví dụ để các bạn có thể dễ hình dung hơn:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct VietNamPeople\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int16 age;\n\tfloat height;\n\tfloat weight;\n\tbool isStudent;\n};</code></pre>\n\n<p>Như vậy, mình vừa định nghĩa xong một struct có tên là VietNamPeople, struct này bây giờ được coi là một kiểu dữ liệu mới là một tập hợp các biến ID, name, age, height, weight và isStudent. Những biến này được đặt vào chung một nhóm và mỗi biến sẽ lưu trữ một phần thông tin của một đơn vị là một con người Việt Nam.</p>\n\n<blockquote><p>Các bạn cần lưu ý về phạm vi sử dụng của kiểu dữ liệu tự định nghĩa cũng tương tự phạm vi sử dụng của biến trong chương trình, nhưng việc định nghĩa kiểu dữ liệu không yêu cầu hệ điều hành cấp phát bộ nhớ nên hoàn toàn không làm ảnh hưởng đến tài nguyên của hệ thống. Do đó, chúng ta nên định nghĩa kiểu dữ liệu mới cho phạm vi toàn cục (global scope) để kiểu dữ liệu mới này có thể được sử dụng trong toàn bộ file, thậm chí là sử dụng trong những file mã nguồn khác trong cùng project.</p></blockquote>\n\n<p>Khi các biến được đặt trong struct, chúng ta gọi chúng là trường dữ liệu của struct (fields). Một trường dữ liệu là một thành phần trong tập hợp các biến lưu trữ dữ liệu cần thiết cho một đơn vị. Ví dụ kiểu dữ liệu VietNamPeople có 6 trường dữ liệu là ID, name, age, height, weight và isStudent. Compiler có thể hiểu rằng khi một biến được tạo ra từ kiểu dữ liệu VietNamPeople, ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;</code></pre>\n\n<p>thì lúc này, leTranDat chỉ là một cái tên của một đơn vị được tạo thành từ tập hợp các trường dữ liệu ID, name, age, height, weight và isStudent mà mình đã định nghĩa cho kiểu dữ liệu VietNamPeople. Các bạn có thể hình dung như thế này:</p>\n\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" width=\"690\" height=\"326\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">825x390</span><span class=\"expand\"></span>\n</div></a></div></p>\n\n<p>Đây chỉ là hình ảnh minh họa cho việc tổ chức dữ liệu các trường bên trong một biến kiểu VietNamPeople sau khi được tạo ra. Trên thực tế các trường sẽ có kích thước khác so với dự đoán (khi đến phần nâng cao của struct mình sẽ trình bày về vấn đề này), nhưng đối với các bạn mới học thì chưa cần quan tâm những điều này.</p>\n\n<p>Chúng ta có thể sử dụng kiểu dữ liệu VietNamPeople mà mình định nghĩa ở trên để tạo ra nhiều biến struct khác nhau:</p>\n\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;\nVietNamPeople dayNhauHoc;\nVietNamPeople ngoDoanTuan;\n//.....................</code></pre>\n\n<p>Như những biến thông thường, các biến struct này sẽ được cấp phát bộ nhớ tùy vào cách chọn kỹ thuật cấp phát.</p>\n\n<h5>Khởi tạo cho biến struct</h5>\n\n<p>Khởi tạo giá trị cho các trường dữ liệu trong một biến struct rắc rối hơn khởi tạo giá trị cho biến thông thường một chút. Ngôn ngữ C++ đã hổ trợ cho chúng ta một cách nhanh hơn là sử dụng một <strong>initializer list</strong>. Nó cho phép các bạn khởi tạo một hoặc nhiều trường dữ liệu trong một khai báo biến struct. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};\n\n//................\n\nEmployee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };</code></pre>\n\n<p>Các trường dữ liệu được khởi tạo lần lượt từ trên xuống dưới như trong phần định nghĩa struct có tên Employee. Lúc này, biến leTranDat sẽ chứa các thông tin được khởi tạo lần lượt là: <code>ID</code> = 1, <code>name</code> = \"Le Tran Dat\", <code>age</code> = 28 và <code>year_of_exp</code> = 5.</p>\n\n<p>Nếu initializer list không cung cấp đủ dữ liệu cho các trường dữ liệu, giá trị mặc định sẽ được dùng để khởi tạo. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee newEmp = { 1, \"new employee\" }; //age = 0, year_of_exp = 0 by default</code></pre>\n\n<p>Một tập hợp các giá trị của một biến struct được gọi là một Record (bản ghi).</p>\n\n<h5>Truy cập các trường dữ liệu của biến struct</h5>\n\n<p>Xem xét về struct Employee mình đã định nghĩa ở trên:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};</code></pre>\n\n<p>Kiểu dữ liệu Employee mô tả rằng mỗi biến kiểu Employee được tạo ra sẽ bao gồm 4 trường dữ liệu là <code>ID, name, age và year_of_exp</code>. Như vậy, bất kỳ biến nào có kiểu Employee đều có đủ 4 trường dữ liệu trên.</p>\n\n<p>Muốn truy xuất đến các trường dữ liệu của một biến struct, chúng ta sử dụng <strong>member selection operator</strong> (dấu chấm). Dưới đây là một ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat;\nleTranDat.ID = 1;\nleTranDat.name = \"Le Tran Dat\";\nleTranDat.age = 28;\nleTranDat.year_of_exp = 5;</code></pre>\n\n<p>Visual studio sẽ hổ trợ chúng ta liệt kê tất cả các trường dữ liệu của một biến struct khi sử dụng <strong>member selection operator</strong>.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/1.png?raw=true\" width=\"651\" height=\"285\"></p>\n\n<p>Các trường dữ liệu của một biến struct cũng là những biến thông thường, nhưng nó được gói gọn bên trong một biến struct, nên chúng ta phải sử dụng tên của biến struct và <strong>member selection operator</strong> để truy xuất đến chúng.</p>\n\n<p>Như vậy, thông qua tên biến struct, các trường dữ liệu được nhóm lại giúp chúng ta biết được trường dữ liệu đó được dùng cho đơn vị nào, điều này giúp chúng ta dễ dàng tổ chức chương trình ở quy mô lớn hơn.</p>\n\n<p>Vì các trường dữ liệu của một biến struct cũng là những biến thông thường, chúng ta cũng có thể sử dụng chúng để tính toán, so sánh, ...</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };\nEmployee juniorEmp = { 2, \"New employee\", 25, 1 };\n\nif (leTranDat.year_of_exp &gt; juniorEmp.year_of_exp)\n{\n\tstd::cout &lt;&lt; leTranDat.name &lt;&lt; \" has more experience than \" &lt;&lt; juniorEmp.name &lt;&lt; std::endl;\n}</code></pre>\n\n<p>Các trường dữ liệu của một struct sẽ tồn tại cùng với biến struct cho đến khi biến struct ra khỏi phạm vi sử dụng và bị hủy. Do đó, khi biến struct còn tồn tại, chúng ta vẫn có thể truy xuất đến các trường dữ liệu của nó.</p>\n\n<h5>Nhập và xuất dữ liệu cho biến struct</h5>\n\n<p>Cũng tương tự như nhập xuất dữ liệu cho biến thông thường, chỉ khác là chúng ta cần sử dụng thêm tên biến struct và <strong>member selection operator</strong> để compiler biết chúng ta nhập xuất cho trường dữ liệu của đơn vị nào. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp;\n\n//Input\nstd::cout &lt;&lt; \"Enter ID: \";\nstd::cin &gt;&gt; emp.ID;\n\nstd::cout &lt;&lt; \"Enter name: \";\nstd::getline(std::cin, emp.name);\n\nstd::cout &lt;&lt; \"Enter age: \";\nstd::cin &gt;&gt; emp.age;\n\nstd::cout &lt;&lt; \"Enter year of experience: \";\nstd::cin &gt;&gt; emp.year_of_exp;\n\n//Output\nstd::cout &lt;&lt; \"===================================\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.ID &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.name &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.age &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.year_of_exp &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"===================================\" &lt;&lt; std::endl;</code></pre>\n\n<h5>Structs và function</h5>\n\n<p>Một ưu điểm khi sử dụng struct là chúng ta không cần truyền tất cả các trường dữ liệu của một đơn vị nào đó mà chỉ cần sử dụng một biến struct làm tham số cho hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n};\n\nvoid printVector2D(Vector2D vec)\n{\n\tstd::cout &lt;&lt; \"(\" &lt;&lt; vec.x &lt;&lt; \",\" &lt;&lt; vec.y &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n\tVector2D vec = { 1, 4 };\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Trong ví dụ trên, mình sử dụng kiểu truyền dữ liệu giá trị nên tham số <code>Vector2D vec</code> của hàm printVector2D không làm thay đổi giá trị gốc của đối số. Các bạn cũng có thể thử truyền đối số là biến struct theo kiểu tham chiếu hoặc con trỏ, về mặt cơ bản, biến struct cũng là một biến có địa chỉ cụ thể nên chúng ta làm hoàn toàn tương tự như biến thông thường.</p>\n\n<p></p><pre><code class=\"lang-auto\">void normalize(Vector2D &amp;vec)\n{\n\tfloat length = sqrt((vec.x * vec.x) + (vec.y * vec.y));\n\tvec.x = vec.x / length;\n\tvec.y = vec.y / length;\n}\n\nint main()\n{\n\tVector2D vec = { 1, 4 };\n\tprintVector2D(vec);\n\n\tnormalize(vec);\n\tprintVector2D(vec);\n\n\treturn 0;\n}</code></pre>\n\n<p>Kiểu struct cũng có thể được dùng làm kiểu trả về của hàm. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Vector2D addTwoVector(Vector2D vec1, Vector2D vec2)\n{\n\tVector2D result = { vec1.x + vec2.x, vec1.y + vec2.y };\n\treturn result;\n}\n\nint main()\n{\n\tVector2D vec1 = { 1, 2 };\n\tVector2D vec2 = { 2, 2 };\n\n\tVector2D result = addTwoVector(vec1, vec2);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Chúng ta có thể làm như trên vì ngôn ngữ C++ cho phép chúng ta gán biến struct cho một biến cùng kiểu struct khác. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">Vector2D vec1 = { 1, 2 };\nVector2D vec2 = vec1;</code></pre>\n\n<p>Nhưng chúng ta không nên sử dụng phép gán trực tiếp như vậy, vì có thể trong struct còn có các yếu tố phức tạp khác như con trỏ, hoặc struct khác, ... và dễ gây ra sai sót. Quay trở lại với chủ đề mình đang trình bày.</p>\n\n<p>Chúng ta còn có thể định nghĩa các hàm bên trong phần định nghĩa của struct. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n\n<p>Trong ví dụ trên, hàm normalize được định nghĩa trong cùng khối lệnh của struct Vector2D, nên nó có thể trực tiếp truy cập đến biến x và y và thao tác với chúng. Nhưng x và y của struct Vector2D vẫn đang còn ở mức khái niệm, chỉ khi nào struct Vector2D được dùng để khai báo biến, biến x và y cũng như hàm normalize mới được tạo ra. Như mình đã nói ở trên, việc định nghĩa một kiểu dữ liệu mới chỉ là định nghĩa những dữ liệu sẽ tồn tại trong biến struct nếu nó được tạo ra.</p>\n\n<p>Hàm normalize được tạo ra nhưng chỉ được sử dụng khi một biến struct cụ thể gọi đến nó bằng <strong>member selection operator</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec = { 1, 4 };\n\tvec.normalize();\n\t\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Hàm normalize trong struct Vector2D chỉ có thể được gọi thông qua một biến struct cụ thể. Như vậy, khi chúng ta muốn chuẩn hóa một Vector2D, chúng ta không cần truyền biến struct kiểu Vector2D vào hàm <code>normalize(Vector2D)</code> nữa mà chỉ cần gọi hàm <code>normalize</code> được định nghĩa trong chính nó. Đây cũng là một ưu điểm khi sử dụng struct.</p>\n\n<p>Mình lấy thêm một ví dụ nữa về hàm được định nghĩa bên trong struct để các bạn dễ hình dung:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid setPosition(float X, float Y)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t}\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n\n<p>Mình vừa thêm vào struct Vector2D hàm <code>setPosition(float, float)</code>, lúc này mình không cần sử dụng <strong>initializer list</strong> để khởi tạo cho một biến kiểu Vector2D nữa, mà mình sẽ gọi hàm <code>setPosition(float, float)</code>.</p>\n\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec;\n\tvec.setPosition(1, 4);\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Điều này cũng làm tăng thêm ý nghĩa cho mã nguồn chương trình, giúp code của các bạn dễ đọc hơn. Chúng ta sẽ còn nói đến việc định nghĩa hàm bên trong struct trong những bài học tiếp theo.</p>\n\n<h5>Nested structs</h5>\n\n<p>Struct là một tập hợp các kiểu dữ liệu dùng để tạo nên một kiểu dữ liệu mới, và một kiểu struct cũng là một kiểu dữ liệu, nên chúng ta có thể sử dụng một kiểu struct khác để làm một trường dữ liệu cho struct cần tạo ra. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">struct Birthday\n{\n\t__int32 day;\n\t__int32 month;\n\t__int32 year;\n};\n\nstruct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\tBirthday birthday;\n\t__int32 year_of_exp;\n};</code></pre>\n\n<p>Trong trường hợp này, mình thay thế trường dữ liệu age bằng một trường dữ liệu kiểu Birthday đã được định nghĩa ở trên. Chúng ta có thể khởi tạo giá trị cho nested struct trên như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };</code></pre>\n\n<p>Để truy xuất đến giá trị thực của trường dữ liệu birthday, chúng ta cần sử dụng thêm 1 lần <strong>member selection operator</strong>.</p>\n\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };\n\nstd::cout &lt;&lt; emp.ID &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.name &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.birthday.day &lt;&lt; \"/\" &lt;&lt; emp.birthday.month &lt;&lt; \"/\" &lt;&lt;emp.birthday.year &lt;&lt; std::endl;\nstd::cout &lt;&lt; emp.year_of_exp &lt;&lt; std::endl;</code></pre>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, chúng ta đã cùng nhau tìm hiểu cách để tạo ra một kiểu dữ liệu mới bằng từ khóa struct cung cấp bởi ngôn ngữ C++, một số thao tác cơ bản với biến struct.</p>\n\n<p>Struct là một khái niệm quan trọng trong ngôn ngữ C/C++, hiểu được structs là một bước quan trọng để tiếp cận hướng phát triển chương trình theo mô hình hướng đối tượng. Struct giúp chúng ta tổ chức chương trình hiệu quả hơn.</p>\n\n<h3>Bài tập cơ bản</h3>\n\n<p>1/ Các bạn hãy định nghĩa kiểu dữ liệu PhanSo đại diện cho kiểu phân số. Qua đó, viết chương trình cho phép người dùng thực hiện các phép cộng, trừ, nhân, chia 2 phân số.</p>\n\n<p>2/ Viết chương trình thực hiện phân tích thống kê cho một lớp học khoảng 20 sinh viên. Thông tin của mỗi sinh viên bao gồm ID, tên, tuổi, điểm tổng kết học kì 1, điểm tổng kết học kì 2. Những thông tin cần thống kê bao gồm:</p>\n\n<ul>\n<li>Điểm trung bình cuối năm của cả lớp.</li>\n<li>Điểm tổng kết cuối năm của sinh viên nào là cao nhất.</li>\n<li>Liệt kê danh sách những sinh viên có tiến bộ trong học tập (điểm tổng kết học kì 2 cao hơn điểm tổng kết học kì 1).</li>\n</ul>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.3a2cb4930e4325d583c56db63e3817bf.json"}