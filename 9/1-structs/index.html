<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/phenomic.browser.0bc6ec33353c29418df8.css" /><meta data-react-helmet="true" property="og:site_name" content="dnh-cpp"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="9.1 Structs"/><meta data-react-helmet="true" property="og:url" content="/9/1-structs/"/><meta data-react-helmet="true" property="og:description" content="struct VietNamPeople { 	int32 ID; 	std::string name; 	int16 age; 	float height; 	float weight; 	bool isStudent; }; //................…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="9.1 Structs"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="struct VietNamPeople { 	int32 ID; 	std::string name; 	int16 age; 	float height; 	float weight; 	bool isStudent; }; //................…"/><meta data-react-helmet="true" name="description" content="struct VietNamPeople { 	int32 ID; 	std::string name; 	int16 age; 	float height; 	float weight; 	bool isStudent; }; //................…"/><title data-react-helmet="true">9.1 Structs</title><link data-react-helmet="true" rel="icon" type="image/png" sizes="144x144" href="//daynhauhoc.s3.amazonaws.com/36ee34de6c73f268424fceaef858c5428d8fb2a976.ico"/><link data-react-helmet="true" rel="icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/><link data-react-helmet="true" rel="apple-touch-icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/></head><body><div id="phenomic"><div class="_2lE56" data-reactroot="" data-reactid="1" data-react-checksum="-1014126062"><!-- react-empty: 2 --><div class="_1Ih7a" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><div class="_1G2C6 _3fTO1" data-reactid="7"><div class="aCd9j" data-reactid="8"><a href="https://github.com/daynhauhoc/cppcoban" target="_blank" data-hint="Fork on Github" class="hint--bottom-left _2dICi" data-reactid="9"><span class="SVGInline" data-reactid="10"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span></a><a href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank" data-hint="Share on Facebook" class="hint--bottom-left _2dICi" data-reactid="11"><span class="SVGInline" data-reactid="12"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="430.113px" height="430.114px" viewBox="0 0 430.113 430.114" style="enable-background:new 0 0 430.113 430.114;"
	 xml:space="preserve">
<g>
	<path id="Facebook" d="M158.081,83.3c0,10.839,0,59.218,0,59.218h-43.385v72.412h43.385v215.183h89.122V214.936h59.805
		c0,0,5.601-34.721,8.316-72.685c-7.784,0-67.784,0-67.784,0s0-42.127,0-49.511c0-7.4,9.717-17.354,19.321-17.354
		c9.586,0,29.818,0,48.557,0c0-9.859,0-43.924,0-75.385c-25.016,0-53.476,0-66.021,0C155.878-0.004,158.081,72.48,158.081,83.3z"/>
</g>
</svg></span></a></div></div><article class="markdown-body" data-reactid="13"><h1 data-reactid="14">9.1 Structs</h1><div data-reactid="15"><div class="phenomic-BodyContainer" data-reactid="16"><h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến C++.</h4>
<p>Như các bạn đã biết, việc lập trình ứng dụng phần mềm chỉ đơn giản là tạo ra chương trình máy tính dùng để giải quyết một vấn đề nào đó trong cuộc sống. Để giải quyết được vấn đề, chúng ta cần cung cấp cho chương trình một lượng dữ liệu cần thiết, các câu lệnh sẽ xử lý các dữ liệu được đưa vào và cho ra kết quả mà người dùng mong muốn.</p>
<p>Dữ liệu chúng ta thu thập được trong cuộc sống cần được biểu diễn theo một định dạng nào đó mà máy tính có thể hiểu được, và ngôn ngữ lập trình cung cấp cho chúng ta điều này, đó chính là kiểu dữ liệu. Mỗi kiểu dữ liệu sẽ có một định dạng khác nhau, và khi tạo ra những thực thể từ những kiểu dữ liệu khác nhau, chúng sẽ có định dạng khác nhau dựa trên kiểu dữ liệu mô tả chúng. Ví dụ kiểu số thực (float, double) sẽ có định dạng phần thập phân trong khi kiểu số nguyên (int, long, ...) thì không có.</p>
<p>Việc chọn kiểu dữ liệu phù hợp để lưu trữ dữ liệu cần xử lý là rất quan trọng. Nhưng số lượng kiểu dữ liệu mà một ngôn ngữ lập trình (trong đó có C++) hổ trợ sẵn là khá hạn chế trong khi có những dữ liệu đặc tả cho vấn đề trong cuộc sống lại rất phức tạp. Ví dụ mình muốn biểu diễn một vài thông tin cá nhân của mình trên máy tính, mình có thể làm như sau:</p>
<p></p><pre><code class="lang-auto">std::string name;
std::string currentJob;
std::string homeAddress;
int birthYear;
int birthMonth;
int birthDay;
float height;
float weight;
//...............</code></pre>
<p>Nhìn vào đoạn chương trình trên, các bạn có thể thấy mình cần sử dụng đến 3 kiểu dữ liệu khác nhau để tạo ra 8 biến chỉ để lưu trữ một lượng thông tin cá nhân không đầy đủ của một cá thể nào đó. Những biến này hoàn toàn độc lập với nhau, giả sử những biến này được khai báo tại những vị trí khác nhau trong chương trình sẽ rất khó quản lý. Và sẽ rắc rối hơn nếu chúng ta muốn lưu trữ thông tin cá nhân của nhiều hơn một người, lúc này chúng ta cần khai báo thêm 8 biến tương tự như trên, hoặc sử dụng mảng một chiều như sau:</p>
<p></p><pre><code class="lang-auto">std::string name[10];
std::string currentJob[10];
std::string homeAddress[10];
int birthYear[10];
int birthMonth[10];
int birthDay[10];
float height[10];
float weight[10];
//...............</code></pre>
<p>Như các bạn thấy, việc quản lý chương trình trở nên phức tạp so với những người mới học lập trình. Do đó, việc tự định nghĩa một kiểu dữ liệu mới phù hợp cho đặc thù của chương trình của mỗi người là điều cần thiết. Rất may mắn, ngôn ngữ C++ hổ trợ chúng ta tự định nghĩa kiểu dữ liệu mới từ những kiểu dữ liệu built-in. Kiểu dữ liệu mới mà chúng ta sẽ định nghĩa được tạo thành từ một hoặc một nhóm kiểu dữ liệu xây dựng sẵn để tạo ra một tập hợp các biến thuộc cùng nhóm, những biến cùng nhóm này dùng để lưu trữ các dữ liệu có liên quan với nhau trong kiểu dữ liệu mới. Chúng ta gọi kiểu dữ liệu tập hợp này là <strong>struct</strong>.</p>
<h3>Struct</h3>
<p>Một struct (viết tắt của structure) cho phép chúng ta nhóm nhiều biến của nhiều kiểu dữ liệu khác nhau để lưu trữ một tập hợp các dữ liệu cần thiết cho việc mô tả một đơn vị nào đó.</p>
<h5>Khai báo struct</h5>
<p>Để khai báo một cấu trúc mới (kiểu dữ liệu mới), chúng ta sử dụng từ khóa <strong>struct</strong>. Mặc dù một struct là một kiểu dữ liệu do lập trình viên tự định nghĩa, nó cũng cần được khai báo theo một cú pháp nhất định để compiler có thể hiểu được. Dưới đây là cú pháp để tạo ra một struct mới:</p>
<p></p><pre><code class="lang-auto">struct &lt;name_of_new_type&gt;
{
	&lt;variables&gt;;
};</code></pre>
<p>Trong đó:</p>
<ul>
<li>struct là từ khóa mà ngôn ngữ C++ cung cấp.</li>
<li>
<code>name_of_new_type</code> sẽ là tên của kiểu dữ liệu mới. Sau khi khai báo xong một struct, chúng ta có thể dùng tên struct để khai báo biến như những kiểu dữ liệu thông thường.</li>
<li>
<code>variables</code> là danh sách các biến dùng để lưu trữ dữ liệu phù hợp với yêu cầu lưu trữ dữ liệu của một đơn vị nào đó.</li>
</ul>
<p>Mình lấy một ví dụ để các bạn có thể dễ hình dung hơn:</p>
<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;string&gt;
<p>struct VietNamPeople
{
<strong>int32 ID;
std::string name;
</strong>int16 age;
float height;
float weight;
bool isStudent;
};</code></pre></p>
<p>Như vậy, mình vừa định nghĩa xong một struct có tên là VietNamPeople, struct này bây giờ được coi là một kiểu dữ liệu mới là một tập hợp các biến ID, name, age, height, weight và isStudent. Những biến này được đặt vào chung một nhóm và mỗi biến sẽ lưu trữ một phần thông tin của một đơn vị là một con người Việt Nam.</p>
<blockquote><p>Các bạn cần lưu ý về phạm vi sử dụng của kiểu dữ liệu tự định nghĩa cũng tương tự phạm vi sử dụng của biến trong chương trình, nhưng việc định nghĩa kiểu dữ liệu không yêu cầu hệ điều hành cấp phát bộ nhớ nên hoàn toàn không làm ảnh hưởng đến tài nguyên của hệ thống. Do đó, chúng ta nên định nghĩa kiểu dữ liệu mới cho phạm vi toàn cục (global scope) để kiểu dữ liệu mới này có thể được sử dụng trong toàn bộ file, thậm chí là sử dụng trong những file mã nguồn khác trong cùng project.</p></blockquote>
<p>Khi các biến được đặt trong struct, chúng ta gọi chúng là trường dữ liệu của struct (fields). Một trường dữ liệu là một thành phần trong tập hợp các biến lưu trữ dữ liệu cần thiết cho một đơn vị. Ví dụ kiểu dữ liệu VietNamPeople có 6 trường dữ liệu là ID, name, age, height, weight và isStudent. Compiler có thể hiểu rằng khi một biến được tạo ra từ kiểu dữ liệu VietNamPeople, ví dụ:</p>
<p></p><pre><code class="lang-auto">VietNamPeople leTranDat;</code></pre>
<p>thì lúc này, leTranDat chỉ là một cái tên của một đơn vị được tạo thành từ tập hợp các trường dữ liệu ID, name, age, height, weight và isStudent mà mình đã định nghĩa cho kiểu dữ liệu VietNamPeople. Các bạn có thể hình dung như thế này:</p>
<p><div class="lightbox-wrapper"><a href="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true" class="lightbox" title="0.png?raw=true"><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true" width="690" height="326"><div class="meta">
<span class="filename">0.png?raw=true</span><span class="informations">825x390</span><span class="expand"></span>
</div></a></div></p>
<p>Đây chỉ là hình ảnh minh họa cho việc tổ chức dữ liệu các trường bên trong một biến kiểu VietNamPeople sau khi được tạo ra. Trên thực tế các trường sẽ có kích thước khác so với dự đoán (khi đến phần nâng cao của struct mình sẽ trình bày về vấn đề này), nhưng đối với các bạn mới học thì chưa cần quan tâm những điều này.</p>
<p>Chúng ta có thể sử dụng kiểu dữ liệu VietNamPeople mà mình định nghĩa ở trên để tạo ra nhiều biến struct khác nhau:</p>
<p></p><pre><code class="lang-auto">VietNamPeople leTranDat;
VietNamPeople dayNhauHoc;
VietNamPeople ngoDoanTuan;
//.....................</code></pre>
<p>Như những biến thông thường, các biến struct này sẽ được cấp phát bộ nhớ tùy vào cách chọn kỹ thuật cấp phát.</p>
<h5>Khởi tạo cho biến struct</h5>
<p>Khởi tạo giá trị cho các trường dữ liệu trong một biến struct rắc rối hơn khởi tạo giá trị cho biến thông thường một chút. Ngôn ngữ C++ đã hổ trợ cho chúng ta một cách nhanh hơn là sử dụng một <strong>initializer list</strong>. Nó cho phép các bạn khởi tạo một hoặc nhiều trường dữ liệu trong một khai báo biến struct. Ví dụ:</p>
<p></p><pre><code class="lang-auto">struct Employee
{
	__int32 ID;
	std::string name;
	__int32 age;
	__int32 year_of_exp;
};
<p>//................</p>
<p>Employee leTranDat = { 1, "Le Tran Dat", 28, 5 };</code></pre></p>
<p>Các trường dữ liệu được khởi tạo lần lượt từ trên xuống dưới như trong phần định nghĩa struct có tên Employee. Lúc này, biến leTranDat sẽ chứa các thông tin được khởi tạo lần lượt là: <code>ID</code> = 1, <code>name</code> = "Le Tran Dat", <code>age</code> = 28 và <code>year_of_exp</code> = 5.</p>
<p>Nếu initializer list không cung cấp đủ dữ liệu cho các trường dữ liệu, giá trị mặc định sẽ được dùng để khởi tạo. Ví dụ:</p>
<p></p><pre><code class="lang-auto">Employee newEmp = { 1, "new employee" }; //age = 0, year_of_exp = 0 by default</code></pre>
<p>Một tập hợp các giá trị của một biến struct được gọi là một Record (bản ghi).</p>
<h5>Truy cập các trường dữ liệu của biến struct</h5>
<p>Xem xét về struct Employee mình đã định nghĩa ở trên:</p>
<p></p><pre><code class="lang-auto">struct Employee
{
	__int32 ID;
	std::string name;
	__int32 age;
	__int32 year_of_exp;
};</code></pre>
<p>Kiểu dữ liệu Employee mô tả rằng mỗi biến kiểu Employee được tạo ra sẽ bao gồm 4 trường dữ liệu là <code>ID, name, age và year_of_exp</code>. Như vậy, bất kỳ biến nào có kiểu Employee đều có đủ 4 trường dữ liệu trên.</p>
<p>Muốn truy xuất đến các trường dữ liệu của một biến struct, chúng ta sử dụng <strong>member selection operator</strong> (dấu chấm). Dưới đây là một ví dụ:</p>
<p></p><pre><code class="lang-auto">Employee leTranDat;
leTranDat.ID = 1;
leTranDat.name = "Le Tran Dat";
leTranDat.age = 28;
leTranDat.year_of_exp = 5;</code></pre>
<p>Visual studio sẽ hổ trợ chúng ta liệt kê tất cả các trường dữ liệu của một biến struct khi sử dụng <strong>member selection operator</strong>.</p>
<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/1.png?raw=true" width="651" height="285"></p>
<p>Các trường dữ liệu của một biến struct cũng là những biến thông thường, nhưng nó được gói gọn bên trong một biến struct, nên chúng ta phải sử dụng tên của biến struct và <strong>member selection operator</strong> để truy xuất đến chúng.</p>
<p>Như vậy, thông qua tên biến struct, các trường dữ liệu được nhóm lại giúp chúng ta biết được trường dữ liệu đó được dùng cho đơn vị nào, điều này giúp chúng ta dễ dàng tổ chức chương trình ở quy mô lớn hơn.</p>
<p>Vì các trường dữ liệu của một biến struct cũng là những biến thông thường, chúng ta cũng có thể sử dụng chúng để tính toán, so sánh, ...</p>
<p></p><pre><code class="lang-auto">Employee leTranDat = { 1, "Le Tran Dat", 28, 5 };
Employee juniorEmp = { 2, "New employee", 25, 1 };
<p>if (leTranDat.year_of_exp > juniorEmp.year_of_exp)
{
std::cout &#x3C;&#x3C; leTranDat.name &#x3C;&#x3C; " has more experience than " &#x3C;&#x3C; juniorEmp.name &#x3C;&#x3C; std::endl;
}</code></pre></p>
<p>Các trường dữ liệu của một struct sẽ tồn tại cùng với biến struct cho đến khi biến struct ra khỏi phạm vi sử dụng và bị hủy. Do đó, khi biến struct còn tồn tại, chúng ta vẫn có thể truy xuất đến các trường dữ liệu của nó.</p>
<h5>Nhập và xuất dữ liệu cho biến struct</h5>
<p>Cũng tương tự như nhập xuất dữ liệu cho biến thông thường, chỉ khác là chúng ta cần sử dụng thêm tên biến struct và <strong>member selection operator</strong> để compiler biết chúng ta nhập xuất cho trường dữ liệu của đơn vị nào. Ví dụ:</p>
<p></p><pre><code class="lang-auto">Employee emp;
<p>//Input
std::cout &#x3C;&#x3C; "Enter ID: ";
std::cin >> emp.ID;</p>
<p>std::cout &#x3C;&#x3C; "Enter name: ";
std::getline(std::cin, emp.name);</p>
<p>std::cout &#x3C;&#x3C; "Enter age: ";
std::cin >> emp.age;</p>
<p>std::cout &#x3C;&#x3C; "Enter year of experience: ";
std::cin >> emp.year_of_exp;</p>
<p>//Output
std::cout &#x3C;&#x3C; "===================================" &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; emp.ID &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; emp.name &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; emp.age &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; emp.year_of_exp &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; "===================================" &#x3C;&#x3C; std::endl;</code></pre></p>
<h5>Structs và function</h5>
<p>Một ưu điểm khi sử dụng struct là chúng ta không cần truyền tất cả các trường dữ liệu của một đơn vị nào đó mà chỉ cần sử dụng một biến struct làm tham số cho hàm. Ví dụ:</p>
<p></p><pre><code class="lang-auto">struct Vector2D
{
	float x;
	float y;
};
<p>void printVector2D(Vector2D vec)
{
std::cout &#x3C;&#x3C; "(" &#x3C;&#x3C; vec.x &#x3C;&#x3C; "," &#x3C;&#x3C; vec.y &#x3C;&#x3C; ")" &#x3C;&#x3C; std::endl;
}</p>
<p>int main()
{
Vector2D vec = { 1, 4 };
printVector2D(vec);

return 0;
}</code></pre></p>
<p>Trong ví dụ trên, mình sử dụng kiểu truyền dữ liệu giá trị nên tham số <code>Vector2D vec</code> của hàm printVector2D không làm thay đổi giá trị gốc của đối số. Các bạn cũng có thể thử truyền đối số là biến struct theo kiểu tham chiếu hoặc con trỏ, về mặt cơ bản, biến struct cũng là một biến có địa chỉ cụ thể nên chúng ta làm hoàn toàn tương tự như biến thông thường.</p>
<p></p><pre><code class="lang-auto">void normalize(Vector2D &amp;vec)
{
	float length = sqrt((vec.x * vec.x) + (vec.y * vec.y));
	vec.x = vec.x / length;
	vec.y = vec.y / length;
}
<p>int main()
{
Vector2D vec = { 1, 4 };
printVector2D(vec);</p>
<pre><code>normalize(vec);
printVector2D(vec);

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Kiểu struct cũng có thể được dùng làm kiểu trả về của hàm. Ví dụ:</p>
<p></p><pre><code class="lang-auto">Vector2D addTwoVector(Vector2D vec1, Vector2D vec2)
{
	Vector2D result = { vec1.x + vec2.x, vec1.y + vec2.y };
	return result;
}
<p>int main()
{
Vector2D vec1 = { 1, 2 };
Vector2D vec2 = { 2, 2 };</p>
<pre><code>Vector2D result = addTwoVector(vec1, vec2);

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Chúng ta có thể làm như trên vì ngôn ngữ C++ cho phép chúng ta gán biến struct cho một biến cùng kiểu struct khác. Ví dụ:</p>
<p></p><pre><code class="lang-auto">Vector2D vec1 = { 1, 2 };
Vector2D vec2 = vec1;</code></pre>
<p>Nhưng chúng ta không nên sử dụng phép gán trực tiếp như vậy, vì có thể trong struct còn có các yếu tố phức tạp khác như con trỏ, hoặc struct khác, ... và dễ gây ra sai sót. Quay trở lại với chủ đề mình đang trình bày.</p>
<p>Chúng ta còn có thể định nghĩa các hàm bên trong phần định nghĩa của struct. Ví dụ:</p>
<p></p><pre><code class="lang-auto">struct Vector2D
{
	float x;
	float y;
	
	void normalize()
	{
		float length = sqrt(x * x + y * y);
		x = x / length;
		y = y / length;
	}
};</code></pre>
<p>Trong ví dụ trên, hàm normalize được định nghĩa trong cùng khối lệnh của struct Vector2D, nên nó có thể trực tiếp truy cập đến biến x và y và thao tác với chúng. Nhưng x và y của struct Vector2D vẫn đang còn ở mức khái niệm, chỉ khi nào struct Vector2D được dùng để khai báo biến, biến x và y cũng như hàm normalize mới được tạo ra. Như mình đã nói ở trên, việc định nghĩa một kiểu dữ liệu mới chỉ là định nghĩa những dữ liệu sẽ tồn tại trong biến struct nếu nó được tạo ra.</p>
<p>Hàm normalize được tạo ra nhưng chỉ được sử dụng khi một biến struct cụ thể gọi đến nó bằng <strong>member selection operator</strong>.</p>
<p></p><pre><code class="lang-auto">int main()
{
	Vector2D vec = { 1, 4 };
	vec.normalize();
	
	printVector2D(vec);
	
	return 0;
}</code></pre>
<p>Hàm normalize trong struct Vector2D chỉ có thể được gọi thông qua một biến struct cụ thể. Như vậy, khi chúng ta muốn chuẩn hóa một Vector2D, chúng ta không cần truyền biến struct kiểu Vector2D vào hàm <code>normalize(Vector2D)</code> nữa mà chỉ cần gọi hàm <code>normalize</code> được định nghĩa trong chính nó. Đây cũng là một ưu điểm khi sử dụng struct.</p>
<p>Mình lấy thêm một ví dụ nữa về hàm được định nghĩa bên trong struct để các bạn dễ hình dung:</p>
<p></p><pre><code class="lang-auto">struct Vector2D
{
	float x;
	float y;
	
	void setPosition(float X, float Y)
	{
		x = X;
		y = Y;
	}
	
	void normalize()
	{
		float length = sqrt(x * x + y * y);
		x = x / length;
		y = y / length;
	}
};</code></pre>
<p>Mình vừa thêm vào struct Vector2D hàm <code>setPosition(float, float)</code>, lúc này mình không cần sử dụng <strong>initializer list</strong> để khởi tạo cho một biến kiểu Vector2D nữa, mà mình sẽ gọi hàm <code>setPosition(float, float)</code>.</p>
<p></p><pre><code class="lang-auto">int main()
{
	Vector2D vec;
	vec.setPosition(1, 4);
	printVector2D(vec);
	
	return 0;
}</code></pre>
<p>Điều này cũng làm tăng thêm ý nghĩa cho mã nguồn chương trình, giúp code của các bạn dễ đọc hơn. Chúng ta sẽ còn nói đến việc định nghĩa hàm bên trong struct trong những bài học tiếp theo.</p>
<h5>Nested structs</h5>
<p>Struct là một tập hợp các kiểu dữ liệu dùng để tạo nên một kiểu dữ liệu mới, và một kiểu struct cũng là một kiểu dữ liệu, nên chúng ta có thể sử dụng một kiểu struct khác để làm một trường dữ liệu cho struct cần tạo ra. Ví dụ:</p>
<p></p><pre><code class="lang-auto">struct Birthday
{
	__int32 day;
	__int32 month;
	__int32 year;
};
<p>struct Employee
{
<strong>int32 ID;
std::string name;
Birthday birthday;
</strong>int32 year_of_exp;
};</code></pre></p>
<p>Trong trường hợp này, mình thay thế trường dữ liệu age bằng một trường dữ liệu kiểu Birthday đã được định nghĩa ở trên. Chúng ta có thể khởi tạo giá trị cho nested struct trên như sau:</p>
<p></p><pre><code class="lang-auto">Employee emp = { 1, "Le Tran Dat", {1, 2, 2000}, 5 };</code></pre>
<p>Để truy xuất đến giá trị thực của trường dữ liệu birthday, chúng ta cần sử dụng thêm 1 lần <strong>member selection operator</strong>.</p>
<p></p><pre><code class="lang-auto">Employee emp = { 1, "Le Tran Dat", {1, 2, 2000}, 5 };
<p>std::cout &#x3C;&#x3C; emp.ID &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; emp.name &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; emp.birthday.day &#x3C;&#x3C; "/" &#x3C;&#x3C; emp.birthday.month &#x3C;&#x3C; "/" &#x3C;&#x3C;emp.birthday.year &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; emp.year_of_exp &#x3C;&#x3C; std::endl;</code></pre></p>
<hr>
<h3>Tổng kết</h3>
<p>Trong bài học này, chúng ta đã cùng nhau tìm hiểu cách để tạo ra một kiểu dữ liệu mới bằng từ khóa struct cung cấp bởi ngôn ngữ C++, một số thao tác cơ bản với biến struct.</p>
<p>Struct là một khái niệm quan trọng trong ngôn ngữ C/C++, hiểu được structs là một bước quan trọng để tiếp cận hướng phát triển chương trình theo mô hình hướng đối tượng. Struct giúp chúng ta tổ chức chương trình hiệu quả hơn.</p>
<h3>Bài tập cơ bản</h3>
<p>1/ Các bạn hãy định nghĩa kiểu dữ liệu PhanSo đại diện cho kiểu phân số. Qua đó, viết chương trình cho phép người dùng thực hiện các phép cộng, trừ, nhân, chia 2 phân số.</p>
<p>2/ Viết chương trình thực hiện phân tích thống kê cho một lớp học khoảng 20 sinh viên. Thông tin của mỗi sinh viên bao gồm ID, tên, tuổi, điểm tổng kết học kì 1, điểm tổng kết học kì 2. Những thông tin cần thống kê bao gồm:</p>
<ul>
<li>Điểm trung bình cuối năm của cả lớp.</li>
<li>Điểm tổng kết cuối năm của sinh viên nào là cao nhất.</li>
<li>Liệt kê danh sách những sinh viên có tiến bộ trong học tập (điểm tổng kết học kì 2 cao hơn điểm tổng kết học kì 1).</li>
</ul>
<hr>
<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>
<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>
<p><a title="DayNhauHoc" class="onebox" target="_blank">www.daynhauhoc.com</a></p>
</div></div></article><div id="discourse-comments" data-reactid="17"></div></div></div></div><div class="_30zqN _1M-6l" data-reactid="18"><ul style="list-style:none;background-color:transparent;margin:0;padding:0;color:#242a31;font-family:lucida grande ,tahoma,verdana,arial,sans-serif;font-size:14px;" data-reactid="19"><li style="position:relative;" data-reactid="20"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="21"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="22"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="23"><svg height="14" width="14" data-reactid="24"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="25"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="26"><div style="line-height:24px;vertical-align:middle;font-size:1.5em;font-weight:300;font-family:Source Sans Pro,sans-serif;margin-bottom:1em;" data-reactid="27">Khóa học C++</div></div></div><span data-reactid="28"><ul style="list-style:none;padding-left:19px;" data-reactid="29"><li style="position:relative;" data-reactid="30"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="31"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="32"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="33"><svg height="14" width="14" data-reactid="34"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="35"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="36"><div style="line-height:24px;vertical-align:middle;" data-reactid="37">Giới thiệu tổng quan khóa học</div></div></div><span data-reactid="38"></span></li><li style="position:relative;" data-reactid="39"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="40"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="41"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="42"><svg height="14" width="14" data-reactid="43"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="44"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="45"><div style="line-height:24px;vertical-align:middle;" data-reactid="46">C++ cơ bản</div></div></div><span data-reactid="47"></span></li><li style="position:relative;" data-reactid="48"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="49"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="50"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="51"><svg height="14" width="14" data-reactid="52"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="53"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="54"><div style="line-height:24px;vertical-align:middle;" data-reactid="55">Cấu trúc rẽ nhánh</div></div></div><span data-reactid="56"></span></li><li style="position:relative;" data-reactid="57"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="58"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="59"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="60"><svg height="14" width="14" data-reactid="61"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="62"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="63"><div style="line-height:24px;vertical-align:middle;" data-reactid="64">Cấu trúc vòng lặp</div></div></div><span data-reactid="65"></span></li><li style="position:relative;" data-reactid="66"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="67"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="68"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="69"><svg height="14" width="14" data-reactid="70"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="71"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="72"><div style="line-height:24px;vertical-align:middle;" data-reactid="73">Nâng cao về biến, kiểu dữ liệu</div></div></div><span data-reactid="74"></span></li><li style="position:relative;" data-reactid="75"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="76"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="77"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="78"><svg height="14" width="14" data-reactid="79"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="80"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="81"><div style="line-height:24px;vertical-align:middle;" data-reactid="82">Kiểu dữ liệu mảng</div></div></div><span data-reactid="83"></span></li><li style="position:relative;" data-reactid="84"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="85"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="86"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="87"><svg height="14" width="14" data-reactid="88"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="89"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="90"><div style="line-height:24px;vertical-align:middle;" data-reactid="91">Kiểu chuỗi kí tự</div></div></div><span data-reactid="92"></span></li><li style="position:relative;" data-reactid="93"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="94"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="95"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="96"><svg height="14" width="14" data-reactid="97"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="98"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="99"><div style="line-height:24px;vertical-align:middle;" data-reactid="100">Cơ bản về Function</div></div></div><span data-reactid="101"></span></li><li style="position:relative;" data-reactid="102"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="103"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="104"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="105"><svg height="14" width="14" data-reactid="106"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="107"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="108"><div style="line-height:24px;vertical-align:middle;" data-reactid="109">Con trỏ</div></div></div><span data-reactid="110"></span></li><li style="position:relative;" data-reactid="111"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="112"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="113"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="114"><svg height="14" width="14" data-reactid="115"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="116"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="117"><div style="line-height:24px;vertical-align:middle;" data-reactid="118">Kiểu dữ liệu tự định nghĩa</div></div></div><span data-reactid="119"></span></li><li style="position:relative;" data-reactid="120"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="121"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="122"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="123"><svg height="14" width="14" data-reactid="124"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="125"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="126"><div style="line-height:24px;vertical-align:middle;" data-reactid="127">Nhập, xuất, streams (Input &amp; Output)</div></div></div><span data-reactid="128"></span></li><li style="position:relative;" data-reactid="129"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="130"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="131"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="132"><svg height="14" width="14" data-reactid="133"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="134"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="135"><div style="line-height:24px;vertical-align:middle;" data-reactid="136">Standard Template Library</div></div></div><span data-reactid="137"></span></li><li style="position:relative;" data-reactid="138"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="139"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="140"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="141"><svg height="14" width="14" data-reactid="142"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="143"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="144"><div style="line-height:24px;vertical-align:middle;" data-reactid="145">Auto pointer</div></div></div><span data-reactid="146"></span></li><li style="position:relative;" data-reactid="147"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="148"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="149"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="150"><svg height="14" width="14" data-reactid="151"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="152"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="153"><div style="line-height:24px;vertical-align:middle;" data-reactid="154">Quản lý mã nguồn</div></div></div><span data-reactid="155"></span></li><li style="position:relative;" data-reactid="156"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="157"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="158"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="159"><svg height="14" width="14" data-reactid="160"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="161"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="162"><div style="line-height:24px;vertical-align:middle;" data-reactid="163">Một số feature trong C++11, C++14</div></div></div><span data-reactid="164"></span></li></ul></span></li></ul></div><div class="_3eRtW" data-reactid="165"><span class="SVGInline" data-reactid="166"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 396.667 396.667" style="enable-background:new 0 0 396.667 396.667;" xml:space="preserve">
<g>
	<g>
		<path d="M17,87.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17C0,80.183,7.65,87.833,17,87.833z"/>
		<path d="M17,215.333h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,215.333,17,215.333z"/>
		<path d="M17,342.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,342.833,17,342.833z"/>
	</g>
</g>
</svg></span></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"title":"Cài đặt Code::blocks để lập trình C++ trên Ubuntu/Linux","route":"0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux","id":24563,"description":"int main() {   std::cout &lt;&lt; \"Hello World!\"; }","__filename":"generated/24563.md","__url":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/","__resourceUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html","__dataUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html.3ad2186767d90d121ec4cf565f5c1dd8.json"},{"title":"Cài đặt Xcode để lập trình C++ trên Mac OS X","route":"0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x","id":24606,"description":"int main() {     std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;     return 0; }","__filename":"generated/24606.md","__url":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/","__resourceUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html","__dataUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html.8c393057c45fd132c8e63270c6b51de9.json"},{"title":"Cài đặt Visual Studio 2015 để lập trình C++ trên Windows","route":"0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows","id":24768,"description":"","__filename":"generated/24768.md","__url":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/","__resourceUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html","__dataUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html.ee5116c3f1d988558f587037fbca2366.json"},{"title":"0.0 Giới thiệu về series tutorial","route":"0/0-gioi-thieu-ve-series-tutorial","id":29402,"description":"Tóm tắt về bản thân  Minh tên Lê Trần Đạt, 28 tuổi, là lập trình viên lập trình nhúng, ngoài làm việc mình thích dạy học online và viết. Tự…","__filename":"generated/29402.md","__url":"/0/0-gioi-thieu-ve-series-tutorial/","__resourceUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html","__dataUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html.078c42a7bcb638e7a6288e3b5eca8db0.json"},{"title":"0.1 Giới thiệu về ngôn ngữ lập trình","route":"0/1-gioi-thieu-ve-ngon-ngu-lap-trinh","id":29425,"description":"","__filename":"generated/29425.md","__url":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/","__resourceUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html","__dataUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html.9809f133b2b8d62313a69257668cb67b.json"},{"title":"0.2 Giới thiệu về ngôn ngữ lập trình C++","route":"0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c","id":29448,"description":"","__filename":"generated/29448.md","__url":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/","__resourceUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html","__dataUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html.c812ae7d3909d89717f7e886ac243ab3.json"},{"title":"0.3 Các công đoạn phát triển của một chương trình C++","route":"0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c","id":29449,"description":"","__filename":"generated/29449.md","__url":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/","__resourceUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html.f0b19108e622a8c6734cb0d5743e5745.json"},{"title":"0.4 Giới thiệu môi trường phát triển ứng dụng C++","route":"0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c","id":29503,"description":"","__filename":"generated/29503.md","__url":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/","__resourceUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html","__dataUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html.2c25af91e3aa61d907d4da959782452c.json"},{"title":"1.0 Viết chương trình đầu tiên","route":"1/0-viet-chuong-trinh-dau-tien","id":29504,"description":"Các bạn sẽ thấy nhiều hàm main có cách khai báo khác nhau. Nhưng với việc bạn là người mới bắt đầu học C++, mình khuyến nghị các bạn nên sử…","__filename":"generated/29504.md","__url":"/1/0-viet-chuong-trinh-dau-tien/","__resourceUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html","__dataUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html.a512d65564a3c061c7f754360a019b46.json"},{"title":"1.1 Cấu trúc cơ bản của một chương trình C++","route":"1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c","id":29527,"description":"\\#include &lt;iostream> using namespace std; int main()\t{ \t// We write some code inside main function. } } / We can put comment everywhere…","__filename":"generated/29527.md","__url":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/","__resourceUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html.8df49c7894cffb0fcf8925108166f28e.json"},{"title":"1.10 Độ ưu tiên của các toán tử","route":"1/10-do-uu-tien-cua-cac-toan-tu","id":29574,"description":"","__filename":"generated/29574.md","__url":"/1/10-do-uu-tien-cua-cac-toan-tu/","__resourceUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html","__dataUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html.7a47c8f2c1a6101a3700bbc2c0ee315e.json"},{"title":"1.2 Lệnh, khối lệnh, từ khóa","route":"1/2-lenh-khoi-lenh-tu-khoa","id":29575,"description":"Những dòng lệnh bên trong thân hàm main. (Có thể có hoặc không) Những dòng comment. (Có thể có hoặc không) Tích hợp thư viện và không gian…","__filename":"generated/29575.md","__url":"/1/2-lenh-khoi-lenh-tu-khoa/","__resourceUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html","__dataUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html.7475fb0565b3dc36b5f6c2b16530378c.json"},{"title":"1.3 Sử dụng các lệnh liên quan đến xuất dữ liệu","route":"1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu","id":29796,"description":"","__filename":"generated/29796.md","__url":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/","__resourceUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html","__dataUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html.736841fb7471e11813ab50bf85285809.json"},{"title":"1.4 Biến và các kiểu dữ liệu trong C++","route":"1/4-bien-va-cac-kieu-du-lieu-trong-c","id":29935,"description":"float valueFloat = 5.394; // (2) Xin hệ điều hành thêm một vùng nhớ để chứa 1 số thực string myName = \"Minh Vu\"; // (3) Biến này chứa được…","__filename":"generated/29935.md","__url":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/","__resourceUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html","__dataUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html.13c577638c6f91eda9b5863c77255544.json"},{"title":"1.5 Nhập và xuất dữ liệu","route":"1/5-nhap-va-xuat-du-lieu","id":29936,"description":"","__filename":"generated/29936.md","__url":"/1/5-nhap-va-xuat-du-lieu/","__resourceUrl":"/1/5-nhap-va-xuat-du-lieu/index.html","__dataUrl":"/1/5-nhap-va-xuat-du-lieu/index.html.ef6e11684dfcb7f6b992aba2c8e21426.json"},{"title":"1.6 Hằng số","route":"1/6-hang-so","id":29938,"description":"","__filename":"generated/29938.md","__url":"/1/6-hang-so/","__resourceUrl":"/1/6-hang-so/index.html","__dataUrl":"/1/6-hang-so/index.html.f3ddc6bdde6d54a411e4b79e348d0572.json"},{"title":"1.7 Phạm vi của biến","route":"1/7-pham-vi-cua-bien","id":29939,"description":"int value = 1; int main()\t{ }","__filename":"generated/29939.md","__url":"/1/7-pham-vi-cua-bien/","__resourceUrl":"/1/7-pham-vi-cua-bien/index.html","__dataUrl":"/1/7-pham-vi-cua-bien/index.html.7b8e3af7da9532eb3642eb19b7367ed9.json"},{"title":"1.8 Các phép toán cơ bản","route":"1/8-cac-phep-toan-co-ban","id":29944,"description":"int another_variable = 3; variable = another_variable \\* 2; variable = variable + 1; //tăng giá trị biến variable lên 1. variable =…","__filename":"generated/29944.md","__url":"/1/8-cac-phep-toan-co-ban/","__resourceUrl":"/1/8-cac-phep-toan-co-ban/index.html","__dataUrl":"/1/8-cac-phep-toan-co-ban/index.html.e7174a44027feba3c434a4373886310e.json"},{"title":"1.9 Toán tử tăng giảm","route":"1/9-toan-tu-tang-giam","id":29945,"description":"","__filename":"generated/29945.md","__url":"/1/9-toan-tu-tang-giam/","__resourceUrl":"/1/9-toan-tu-tang-giam/index.html","__dataUrl":"/1/9-toan-tu-tang-giam/index.html.17809ba92bb7526bb6d72300ea06de47.json"},{"title":"2.0 Boolean","route":"2/0-boolean","id":29992,"description":"int a = 2, b = 4; a \\* 3 != b; //đúng int main() { \tcout &lt;&lt; true &lt;&lt; endl; \tcout &lt;&lt; false &lt;&lt; endl; } int main() {…","__filename":"generated/29992.md","__url":"/2/0-boolean/","__resourceUrl":"/2/0-boolean/index.html","__dataUrl":"/2/0-boolean/index.html.62f9a66039eff1016579fc6484f79273.json"},{"title":"2.1 Giới thiệu một số cấu trúc điều khiển","route":"2/1-gioi-thieu-mot-so-cau-truc-dieu-khien","id":30007,"description":"int main() { \tcout &lt;&lt; \"This line is printed out.\" &lt;&lt; endl; \texit(-1); //Terminate and return -1 to operating system.  \tcout…","__filename":"generated/30007.md","__url":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/","__resourceUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html","__dataUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html.1d4fd6576fff1c9f6ebbde9296cb7ccf.json"},{"title":"2.2 if statements","route":"2/2-if-statements","id":30008,"description":"} } if(value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; } if (value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; }…","__filename":"generated/30008.md","__url":"/2/2-if-statements/","__resourceUrl":"/2/2-if-statements/index.html","__dataUrl":"/2/2-if-statements/index.html.5fc7b6ae8899008a02ec037a2bf0194c.json"},{"title":"2.3 switch case statements","route":"2/3-switch-case-statements","id":30009,"description":"} }","__filename":"generated/30009.md","__url":"/2/3-switch-case-statements/","__resourceUrl":"/2/3-switch-case-statements/index.html","__dataUrl":"/2/3-switch-case-statements/index.html.51348d4d78f70d37586bb9c11de9341f.json"},{"title":"3.0 Vòng lặp while","route":"3/0-vong-lap-while","id":30011,"description":"} while (score &lt; 4) { \tcount++; \tcout &lt;&lt; \"Learn C++ programming language...\" &lt;&lt; endl; \tcout &lt;&lt; \"Enter your final…","__filename":"generated/30011.md","__url":"/3/0-vong-lap-while/","__resourceUrl":"/3/0-vong-lap-while/index.html","__dataUrl":"/3/0-vong-lap-while/index.html.ca3b73cc92989d89c9963bb13aeaa718.json"},{"title":"3.1 Vòng lặp do-while","route":"3/1-vong-lap-do-while","id":30012,"description":"} const int ID = 123; const int password = 123456; int main() { \t//................. }","__filename":"generated/30012.md","__url":"/3/1-vong-lap-do-while/","__resourceUrl":"/3/1-vong-lap-do-while/index.html","__dataUrl":"/3/1-vong-lap-do-while/index.html.9652947ce2cac76fc244291dfe0e7da9.json"},{"title":"3.2 Vòng lặp for","route":"3/2-vong-lap-for","id":30013,"description":"}","__filename":"generated/30013.md","__url":"/3/2-vong-lap-for/","__resourceUrl":"/3/2-vong-lap-for/index.html","__dataUrl":"/3/2-vong-lap-for/index.html.91200558d1e346b99f3bfe6615546b0d.json"},{"title":"3.3 từ khóa break và continue","route":"3/3-tu-khoa-break-va-continue","id":30014,"description":"} } }","__filename":"generated/30014.md","__url":"/3/3-tu-khoa-break-va-continue/","__resourceUrl":"/3/3-tu-khoa-break-va-continue/index.html","__dataUrl":"/3/3-tu-khoa-break-va-continue/index.html.ce5d9d1bafbf829b21faafe2d437e44f.json"},{"title":"4.0 Sử dụng thư viện cstdint","route":"4/0-su-dung-thu-vien-cstdint","id":30016,"description":"int main()\t{ } //in ra kết quả là giá trị lớn nhất của 5 số vừa nhập //in ra kết quả là giá trị nhỏ nhất của 5 số vừa nhập int main()\t {…","__filename":"generated/30016.md","__url":"/4/0-su-dung-thu-vien-cstdint/","__resourceUrl":"/4/0-su-dung-thu-vien-cstdint/index.html","__dataUrl":"/4/0-su-dung-thu-vien-cstdint/index.html.a2801fa4ada10c23f504f07e4ee78b63.json"},{"title":"4.1 Kiểu kí tự","route":"4/1-kieu-ki-tu","id":30018,"description":"//check if there is any character exist in stdin file object if (!cin.eof())\t{ \tcout &lt;&lt; \"There are some character more in stdin file…","__filename":"generated/30018.md","__url":"/4/1-kieu-ki-tu/","__resourceUrl":"/4/1-kieu-ki-tu/index.html","__dataUrl":"/4/1-kieu-ki-tu/index.html.3d3eff45a05d59492b7b40b7e7817293.json"},{"title":"4.2 Ép kiểu dữ liệu","route":"4/2-ep-kieu-du-lieu","id":30019,"description":"","__filename":"generated/30019.md","__url":"/4/2-ep-kieu-du-lieu/","__resourceUrl":"/4/2-ep-kieu-du-lieu/index.html","__dataUrl":"/4/2-ep-kieu-du-lieu/index.html.2ce390588cf4f5b31eb1090272f305c3.json"},{"title":"4.3 auto và decltype","route":"4/3-auto-va-decltype","id":30020,"description":"// compare the type of n with type int32_t if (typeid(int32_t) == typeid(n)) \tcout &lt;&lt; \"n is an object of type int32_t\" &lt;&lt; endl;…","__filename":"generated/30020.md","__url":"/4/3-auto-va-decltype/","__resourceUrl":"/4/3-auto-va-decltype/index.html","__dataUrl":"/4/3-auto-va-decltype/index.html.0d8f1c6d9c4f8f1eff25628a38272254.json"},{"title":"4.4 Địa chỉ của biến","route":"4/4-dia-chi-cua-bien","id":30022,"description":"cout &lt;&lt; \"Value of var: \" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; \"Value of var_reference: \" &lt;&lt; var_reference &lt;&lt; endl;…","__filename":"generated/30022.md","__url":"/4/4-dia-chi-cua-bien/","__resourceUrl":"/4/4-dia-chi-cua-bien/index.html","__dataUrl":"/4/4-dia-chi-cua-bien/index.html.7700a863d95ebd2c72f590db3ae556c8.json"},{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","id":30080,"description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements…","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.2bdadf3c58a38e337057a0de9d3374f6.json"},{"title":"5.1 Các thao tác cơ bản với mảng một chiều","route":"5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu","id":30082,"description":"int32_t arr[ARRAY_SIZE];\t int32_t arr_clone[ARRAY_SIZE]; } } int main() { \tchar ch_array\\[] = { 'L', 'e', 'T', 'r', 'a', 'n', 'D', 'a',…","__filename":"generated/30082.md","__url":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/","__resourceUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html","__dataUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html.c358cb5702d7e0848c1d0fcafea76326.json"},{"title":"5.2 Thư viện array trong STL","route":"5/2-thu-vien-array-trong-stl","id":30083,"description":"//Access to all of elements of arr object for (int32_t index = 0; index &lt;= arr.size() - 1; index++) { \tcout &lt;&lt; arr[index] &lt;&lt;…","__filename":"generated/30083.md","__url":"/5/2-thu-vien-array-trong-stl/","__resourceUrl":"/5/2-thu-vien-array-trong-stl/index.html","__dataUrl":"/5/2-thu-vien-array-trong-stl/index.html.f6855e3cf847058a20cddbfbd1924e9a.json"},{"title":"5.3 Mảng hai chiều","route":"5/3-mang-hai-chieu","id":30085,"description":"for(int row = 0; row &lt; 3; row++) { \tfor(int col = 0; col &lt; 4; col++) \t{ \t\tcout &lt;&lt; board[row][col] &lt;&lt; \" \"; \t} \tcout…","__filename":"generated/30085.md","__url":"/5/3-mang-hai-chieu/","__resourceUrl":"/5/3-mang-hai-chieu/index.html","__dataUrl":"/5/3-mang-hai-chieu/index.html.20eabc78d6c5ccd506f5e0a0d9bc1987.json"},{"title":"5.4 Các thao tác cơ bản với mảng hai chiều","route":"5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu","id":30086,"description":"} }","__filename":"generated/30086.md","__url":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/","__resourceUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html","__dataUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html.d255b4de5fe60dec619e7ce656009b5a.json"},{"title":"6.0 Mảng kí tự","route":"6/0-mang-ki-tu","id":30090,"description":"cout &lt;&lt; \"Enter your full name: \"; cin >> full_name; cout &lt;&lt; \"Your full name is \" &lt;&lt; full_name &lt;&lt; endl; cout…","__filename":"generated/30090.md","__url":"/6/0-mang-ki-tu/","__resourceUrl":"/6/0-mang-ki-tu/index.html","__dataUrl":"/6/0-mang-ki-tu/index.html.c07e54b9b2919b7ae2f406f37d0fbed3.json"},{"title":"6.1 Các thao tác cơ bản với mảng kí tự","route":"6/1-cac-thao-tac-co-ban-voi-mang-ki-tu","id":30091,"description":"memset(foo, '-', 7); cout &lt;&lt; foo &lt;&lt; endl; \\-------every programmer should know memset! strcpy(str_destination, str_source);…","__filename":"generated/30091.md","__url":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/","__resourceUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html","__dataUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html.f0846f159064ae244ee4452151734f0f.json"},{"title":"6.2 Thư viện string trong C++","route":"6/2-thu-vien-string-trong-c","id":30092,"description":"//......... string my_string; string temp_string(\"What the hell is going on?\"); string one_more = temp_string; string…","__filename":"generated/30092.md","__url":"/6/2-thu-vien-string-trong-c/","__resourceUrl":"/6/2-thu-vien-string-trong-c/index.html","__dataUrl":"/6/2-thu-vien-string-trong-c/index.html.c5528a05ca23fbe3ff253526b42ee2f6.json"},{"title":"7.0 Làm quen với khái niệm function","route":"7/0-lam-quen-voi-khai-niem-function","id":30132,"description":"if(strlen(str1) == strlen(str2))\t{ \t//do something } void introduce() { \tcout &lt;&lt; \"Hello!\" &lt;&lt; endl; \tcout &lt;&lt; \"I'm a…","__filename":"generated/30132.md","__url":"/7/0-lam-quen-voi-khai-niem-function/","__resourceUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html","__dataUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html.6701f9806c1a33418b356bcbfebc4392.json"},{"title":"7.1 Thiết kế chương trình dựa trên khái niệm function","route":"7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function","id":30133,"description":"} } float subtraction(float value1, float value2) { \treturn value1 - value2; } float multiplication(float value1, float value2) { \treturn…","__filename":"generated/30133.md","__url":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/","__resourceUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html","__dataUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html.0dd052d16304cb05be843573b6ec0e45.json"},{"title":"7.2 Truyền đối số cho hàm là giá trị hoặc tham chiếu","route":"7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu","id":30319,"description":"} } int main() { \tint argument; \tcout &lt;&lt; \"Address of argument: \" &lt;&lt; &argument &lt;&lt; endl;…","__filename":"generated/30319.md","__url":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html.3219ee44dcef6a14dae07111a5c0abf3.json"},{"title":"7.3 Hàm trả về giá trị hoặc tham chiếu","route":"7/3-ham-tra-ve-gia-tri-hoac-tham-chieu","id":30381,"description":"// .............. // function call int result = doubleValue(10); // ................ // function call int & myRef = returnReference(); for…","__filename":"generated/30381.md","__url":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html.4288591cda8969c5c9199b250877f786.json"},{"title":"7.4 Tham số mặc định, tham số hằng","route":"7/4-tham-so-mac-dinh-tham-so-hang","id":30382,"description":"int main() { \tstring non_const_msg = \"This is non-const message\"; \tconst string const_msg = \"This is const message\"; } int main() { }","__filename":"generated/30382.md","__url":"/7/4-tham-so-mac-dinh-tham-so-hang/","__resourceUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html","__dataUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html.b234bc219b3b3db4f46f8d654d7af624.json"},{"title":"7.5 Function overloading","route":"7/5-function-overloading","id":30477,"description":"float addFloat(float f1, float f2) { \treturn f1 + f2; } float add(float f1, float f2) { \treturn f1 + f2; } print(0); print('a'); print('a');","__filename":"generated/30477.md","__url":"/7/5-function-overloading/","__resourceUrl":"/7/5-function-overloading/index.html","__dataUrl":"/7/5-function-overloading/index.html.5657ec584a875acb4601350f19853ed3.json"},{"title":"8.0 Con trỏ","route":"8/0-con-tr","id":30541,"description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt;…","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.a46c66f365403503c34cafdc9863cfa3.json"},{"title":"8.1 Toán tử tăng, giảm dùng cho con trỏ","route":"8/1-toan-tu-tang-giam-dung-cho-con-tr","id":30699,"description":"cout &lt;&lt; \"Before decreased: \" &lt;&lt; ptr &lt;&lt; endl; ptr--; cout &lt;&lt; \" After decreased: \" &lt;&lt; ptr &lt;&lt; endl; cout…","__filename":"generated/30699.md","__url":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/","__resourceUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html","__dataUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html.cce9500249671524aec88406806baa9e.json"},{"title":"8.2 Con trỏ và mảng một chiều","route":"8/2-con-tr-va-mang-mot-chieu","id":30788,"description":"//show address of the first element of arr cout &lt;&lt; &arr[0] &lt;&lt; endl; //show address of the first element of arr cout &lt;&lt;…","__filename":"generated/30788.md","__url":"/8/2-con-tr-va-mang-mot-chieu/","__resourceUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html","__dataUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html.3c8778e4780dd872224eef1cc8f11097.json"},{"title":"8.3 Con trỏ và mảng kí tự","route":"8/3-con-tr-va-mang-ki-tu","id":30876,"description":"p_name[1] = 'E'; cout &lt;&lt; my_name &lt;&lt; endl; cout &lt;&lt; p_name &lt;&lt; endl; } \"Le Tran Dat\"[1] = 'E'; //this line will make…","__filename":"generated/30876.md","__url":"/8/3-con-tr-va-mang-ki-tu/","__resourceUrl":"/8/3-con-tr-va-mang-ki-tu/index.html","__dataUrl":"/8/3-con-tr-va-mang-ki-tu/index.html.dc406539fbe2db6bafb4f3a63ad20fbc.json"},{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","id":31145,"description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt;…","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.e0fca4aed8a1bfd6079218b8f9cd5649.json"},{"title":"8.5 Con trỏ và hằng","route":"8/5-con-tr-va-hang","id":31355,"description":"int value1 = 5; ptr = &value1; int value2 = 10; ptr = &value2; &ptr = 10; //compile error int otherValue = 10; ptr = &otherValue; //compile…","__filename":"generated/31355.md","__url":"/8/5-con-tr-va-hang/","__resourceUrl":"/8/5-con-tr-va-hang/index.html","__dataUrl":"/8/5-con-tr-va-hang/index.html.9717e378d7312e77dd0af404f3ce878a.json"},{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","id":31625,"description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int iPtr…","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.95810b485beb7091df5fbe0cdad166a6.json"},{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","id":31810,"description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl; }…","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.807439d811fbe3c25a6fe7de6f440dcd.json"},{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","id":31959,"description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue;…","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.95b3e8ea543c2c88ac5aed6fae7dd5bc.json"},{"title":"8.10 Phân loại các vùng nhớ (stack & heap ...)","route":"8/10-phan-loai-cac-vung-nho-stack-va-heap","id":32101,"description":"","__filename":"generated/32101.md","__url":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/","__resourceUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html","__dataUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html.f3d953ab58d5d6d7caa9a6825ab85eff.json"},{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","id":32133,"description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int \\*pTemp = ptr; ptr…","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.9b5398e8d66b8730b73fe13cf4859166.json"},{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","id":32159,"description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i++) {…","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/8/7-con-tr-tr-den-con-tr/index.html.9e711455792370d4585f9b6422ec5c75.json"},{"title":"9.0 Kiểu liệt kê (enum)","route":"9/0-kieu-liet-ke-enum","id":32760,"description":"enum Color { \tRED, \tGREEN, \tBLUE, \tWHITE }; enum Animal { \tCAT, \tDOG, \tHORSE, \tMONKEY, \tCHICKEN }; } int iValue = LETTER_A; cout &lt;&lt;…","__filename":"generated/32760.md","__url":"/9/0-kieu-liet-ke-enum/","__resourceUrl":"/9/0-kieu-liet-ke-enum/index.html","__dataUrl":"/9/0-kieu-liet-ke-enum/index.html.5bcab9708527435f7e4986ca2293f162.json"},{"title":"9.1 Structs","route":"9/1-structs","id":33291,"description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent; }; //................…","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.218b89a947ee10e7345fd63f614e71bf.json"},{"title":"9.2 Structs and pointer","route":"9/2-structs-and-pointer","id":33521,"description":"int main() { \tBankAccount myAccount = { 123456789, 50 }; // $50 \tBankAccount \\*pAccount = &myAccount;  } int main() { \tBankAccount…","__filename":"generated/33521.md","__url":"/9/2-structs-and-pointer/","__resourceUrl":"/9/2-structs-and-pointer/index.html","__dataUrl":"/9/2-structs-and-pointer/index.html.3dac4346cb7783e552949ccfe8b270fd.json"},{"title":"11.0 Giới thiệu về STL","route":"11/0-gioi-thieu-ve-stl","id":34001,"description":"","__filename":"generated/34001.md","__url":"/11/0-gioi-thieu-ve-stl/","__resourceUrl":"/11/0-gioi-thieu-ve-stl/index.html","__dataUrl":"/11/0-gioi-thieu-ve-stl/index.html.d381e349b21471222160fc598695cb22.json"},{"title":"11.1 STL containers","route":"11/1-stl-containers","id":34210,"description":"std::vector&lt;\\_\\_int32> vecInt32; std::vector&lt;int32> vec2(5); //gọi phương thức khởi tạo std::vector(size_t \\_Count) với giá trị…","__filename":"generated/34210.md","__url":"/11/1-stl-containers/","__resourceUrl":"/11/1-stl-containers/index.html","__dataUrl":"/11/1-stl-containers/index.html.801d3937ec25c5210d7a3d9a39a6cc9b.json"},{"title":"Khóa học C++","description":"Cạnh tranh với Udemy luôn. Các bạn vào nhập mã REHON_UDEMY Hoặc bấm vào link này http&#x3A;//bit.ly/rehon_udemy Vào đăng ký học rẻ hơn mã…","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.b5876e909f5a87e4ec2b20bf919bf9fa.json"}];window.__INITIAL_STATE__ = {"pages":{"/9/1-structs/":{"head":{"title":"9.1 Structs","route":"9/1-structs","id":33291,"description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent; }; //................…"},"body":"<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến C++.</h4>\n<p>Như các bạn đã biết, việc lập trình ứng dụng phần mềm chỉ đơn giản là tạo ra chương trình máy tính dùng để giải quyết một vấn đề nào đó trong cuộc sống. Để giải quyết được vấn đề, chúng ta cần cung cấp cho chương trình một lượng dữ liệu cần thiết, các câu lệnh sẽ xử lý các dữ liệu được đưa vào và cho ra kết quả mà người dùng mong muốn.</p>\n<p>Dữ liệu chúng ta thu thập được trong cuộc sống cần được biểu diễn theo một định dạng nào đó mà máy tính có thể hiểu được, và ngôn ngữ lập trình cung cấp cho chúng ta điều này, đó chính là kiểu dữ liệu. Mỗi kiểu dữ liệu sẽ có một định dạng khác nhau, và khi tạo ra những thực thể từ những kiểu dữ liệu khác nhau, chúng sẽ có định dạng khác nhau dựa trên kiểu dữ liệu mô tả chúng. Ví dụ kiểu số thực (float, double) sẽ có định dạng phần thập phân trong khi kiểu số nguyên (int, long, ...) thì không có.</p>\n<p>Việc chọn kiểu dữ liệu phù hợp để lưu trữ dữ liệu cần xử lý là rất quan trọng. Nhưng số lượng kiểu dữ liệu mà một ngôn ngữ lập trình (trong đó có C++) hổ trợ sẵn là khá hạn chế trong khi có những dữ liệu đặc tả cho vấn đề trong cuộc sống lại rất phức tạp. Ví dụ mình muốn biểu diễn một vài thông tin cá nhân của mình trên máy tính, mình có thể làm như sau:</p>\n<p></p><pre><code class=\"lang-auto\">std::string name;\nstd::string currentJob;\nstd::string homeAddress;\nint birthYear;\nint birthMonth;\nint birthDay;\nfloat height;\nfloat weight;\n//...............</code></pre>\n<p>Nhìn vào đoạn chương trình trên, các bạn có thể thấy mình cần sử dụng đến 3 kiểu dữ liệu khác nhau để tạo ra 8 biến chỉ để lưu trữ một lượng thông tin cá nhân không đầy đủ của một cá thể nào đó. Những biến này hoàn toàn độc lập với nhau, giả sử những biến này được khai báo tại những vị trí khác nhau trong chương trình sẽ rất khó quản lý. Và sẽ rắc rối hơn nếu chúng ta muốn lưu trữ thông tin cá nhân của nhiều hơn một người, lúc này chúng ta cần khai báo thêm 8 biến tương tự như trên, hoặc sử dụng mảng một chiều như sau:</p>\n<p></p><pre><code class=\"lang-auto\">std::string name[10];\nstd::string currentJob[10];\nstd::string homeAddress[10];\nint birthYear[10];\nint birthMonth[10];\nint birthDay[10];\nfloat height[10];\nfloat weight[10];\n//...............</code></pre>\n<p>Như các bạn thấy, việc quản lý chương trình trở nên phức tạp so với những người mới học lập trình. Do đó, việc tự định nghĩa một kiểu dữ liệu mới phù hợp cho đặc thù của chương trình của mỗi người là điều cần thiết. Rất may mắn, ngôn ngữ C++ hổ trợ chúng ta tự định nghĩa kiểu dữ liệu mới từ những kiểu dữ liệu built-in. Kiểu dữ liệu mới mà chúng ta sẽ định nghĩa được tạo thành từ một hoặc một nhóm kiểu dữ liệu xây dựng sẵn để tạo ra một tập hợp các biến thuộc cùng nhóm, những biến cùng nhóm này dùng để lưu trữ các dữ liệu có liên quan với nhau trong kiểu dữ liệu mới. Chúng ta gọi kiểu dữ liệu tập hợp này là <strong>struct</strong>.</p>\n<h3>Struct</h3>\n<p>Một struct (viết tắt của structure) cho phép chúng ta nhóm nhiều biến của nhiều kiểu dữ liệu khác nhau để lưu trữ một tập hợp các dữ liệu cần thiết cho việc mô tả một đơn vị nào đó.</p>\n<h5>Khai báo struct</h5>\n<p>Để khai báo một cấu trúc mới (kiểu dữ liệu mới), chúng ta sử dụng từ khóa <strong>struct</strong>. Mặc dù một struct là một kiểu dữ liệu do lập trình viên tự định nghĩa, nó cũng cần được khai báo theo một cú pháp nhất định để compiler có thể hiểu được. Dưới đây là cú pháp để tạo ra một struct mới:</p>\n<p></p><pre><code class=\"lang-auto\">struct &lt;name_of_new_type&gt;\n{\n\t&lt;variables&gt;;\n};</code></pre>\n<p>Trong đó:</p>\n<ul>\n<li>struct là từ khóa mà ngôn ngữ C++ cung cấp.</li>\n<li>\n<code>name_of_new_type</code> sẽ là tên của kiểu dữ liệu mới. Sau khi khai báo xong một struct, chúng ta có thể dùng tên struct để khai báo biến như những kiểu dữ liệu thông thường.</li>\n<li>\n<code>variables</code> là danh sách các biến dùng để lưu trữ dữ liệu phù hợp với yêu cầu lưu trữ dữ liệu của một đơn vị nào đó.</li>\n</ul>\n<p>Mình lấy một ví dụ để các bạn có thể dễ hình dung hơn:</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n<p>struct VietNamPeople\n{\n<strong>int32 ID;\nstd::string name;\n</strong>int16 age;\nfloat height;\nfloat weight;\nbool isStudent;\n};</code></pre></p>\n<p>Như vậy, mình vừa định nghĩa xong một struct có tên là VietNamPeople, struct này bây giờ được coi là một kiểu dữ liệu mới là một tập hợp các biến ID, name, age, height, weight và isStudent. Những biến này được đặt vào chung một nhóm và mỗi biến sẽ lưu trữ một phần thông tin của một đơn vị là một con người Việt Nam.</p>\n<blockquote><p>Các bạn cần lưu ý về phạm vi sử dụng của kiểu dữ liệu tự định nghĩa cũng tương tự phạm vi sử dụng của biến trong chương trình, nhưng việc định nghĩa kiểu dữ liệu không yêu cầu hệ điều hành cấp phát bộ nhớ nên hoàn toàn không làm ảnh hưởng đến tài nguyên của hệ thống. Do đó, chúng ta nên định nghĩa kiểu dữ liệu mới cho phạm vi toàn cục (global scope) để kiểu dữ liệu mới này có thể được sử dụng trong toàn bộ file, thậm chí là sử dụng trong những file mã nguồn khác trong cùng project.</p></blockquote>\n<p>Khi các biến được đặt trong struct, chúng ta gọi chúng là trường dữ liệu của struct (fields). Một trường dữ liệu là một thành phần trong tập hợp các biến lưu trữ dữ liệu cần thiết cho một đơn vị. Ví dụ kiểu dữ liệu VietNamPeople có 6 trường dữ liệu là ID, name, age, height, weight và isStudent. Compiler có thể hiểu rằng khi một biến được tạo ra từ kiểu dữ liệu VietNamPeople, ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;</code></pre>\n<p>thì lúc này, leTranDat chỉ là một cái tên của một đơn vị được tạo thành từ tập hợp các trường dữ liệu ID, name, age, height, weight và isStudent mà mình đã định nghĩa cho kiểu dữ liệu VietNamPeople. Các bạn có thể hình dung như thế này:</p>\n<p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/0.png?raw=true\" width=\"690\" height=\"326\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">825x390</span><span class=\"expand\"></span>\n</div></a></div></p>\n<p>Đây chỉ là hình ảnh minh họa cho việc tổ chức dữ liệu các trường bên trong một biến kiểu VietNamPeople sau khi được tạo ra. Trên thực tế các trường sẽ có kích thước khác so với dự đoán (khi đến phần nâng cao của struct mình sẽ trình bày về vấn đề này), nhưng đối với các bạn mới học thì chưa cần quan tâm những điều này.</p>\n<p>Chúng ta có thể sử dụng kiểu dữ liệu VietNamPeople mà mình định nghĩa ở trên để tạo ra nhiều biến struct khác nhau:</p>\n<p></p><pre><code class=\"lang-auto\">VietNamPeople leTranDat;\nVietNamPeople dayNhauHoc;\nVietNamPeople ngoDoanTuan;\n//.....................</code></pre>\n<p>Như những biến thông thường, các biến struct này sẽ được cấp phát bộ nhớ tùy vào cách chọn kỹ thuật cấp phát.</p>\n<h5>Khởi tạo cho biến struct</h5>\n<p>Khởi tạo giá trị cho các trường dữ liệu trong một biến struct rắc rối hơn khởi tạo giá trị cho biến thông thường một chút. Ngôn ngữ C++ đã hổ trợ cho chúng ta một cách nhanh hơn là sử dụng một <strong>initializer list</strong>. Nó cho phép các bạn khởi tạo một hoặc nhiều trường dữ liệu trong một khai báo biến struct. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};\n<p>//................</p>\n<p>Employee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };</code></pre></p>\n<p>Các trường dữ liệu được khởi tạo lần lượt từ trên xuống dưới như trong phần định nghĩa struct có tên Employee. Lúc này, biến leTranDat sẽ chứa các thông tin được khởi tạo lần lượt là: <code>ID</code> = 1, <code>name</code> = \"Le Tran Dat\", <code>age</code> = 28 và <code>year_of_exp</code> = 5.</p>\n<p>Nếu initializer list không cung cấp đủ dữ liệu cho các trường dữ liệu, giá trị mặc định sẽ được dùng để khởi tạo. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">Employee newEmp = { 1, \"new employee\" }; //age = 0, year_of_exp = 0 by default</code></pre>\n<p>Một tập hợp các giá trị của một biến struct được gọi là một Record (bản ghi).</p>\n<h5>Truy cập các trường dữ liệu của biến struct</h5>\n<p>Xem xét về struct Employee mình đã định nghĩa ở trên:</p>\n<p></p><pre><code class=\"lang-auto\">struct Employee\n{\n\t__int32 ID;\n\tstd::string name;\n\t__int32 age;\n\t__int32 year_of_exp;\n};</code></pre>\n<p>Kiểu dữ liệu Employee mô tả rằng mỗi biến kiểu Employee được tạo ra sẽ bao gồm 4 trường dữ liệu là <code>ID, name, age và year_of_exp</code>. Như vậy, bất kỳ biến nào có kiểu Employee đều có đủ 4 trường dữ liệu trên.</p>\n<p>Muốn truy xuất đến các trường dữ liệu của một biến struct, chúng ta sử dụng <strong>member selection operator</strong> (dấu chấm). Dưới đây là một ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat;\nleTranDat.ID = 1;\nleTranDat.name = \"Le Tran Dat\";\nleTranDat.age = 28;\nleTranDat.year_of_exp = 5;</code></pre>\n<p>Visual studio sẽ hổ trợ chúng ta liệt kê tất cả các trường dữ liệu của một biến struct khi sử dụng <strong>member selection operator</strong>.</p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/9-kieu-du-lieu-tu-dinh-nghia/9-1-structs/1.png?raw=true\" width=\"651\" height=\"285\"></p>\n<p>Các trường dữ liệu của một biến struct cũng là những biến thông thường, nhưng nó được gói gọn bên trong một biến struct, nên chúng ta phải sử dụng tên của biến struct và <strong>member selection operator</strong> để truy xuất đến chúng.</p>\n<p>Như vậy, thông qua tên biến struct, các trường dữ liệu được nhóm lại giúp chúng ta biết được trường dữ liệu đó được dùng cho đơn vị nào, điều này giúp chúng ta dễ dàng tổ chức chương trình ở quy mô lớn hơn.</p>\n<p>Vì các trường dữ liệu của một biến struct cũng là những biến thông thường, chúng ta cũng có thể sử dụng chúng để tính toán, so sánh, ...</p>\n<p></p><pre><code class=\"lang-auto\">Employee leTranDat = { 1, \"Le Tran Dat\", 28, 5 };\nEmployee juniorEmp = { 2, \"New employee\", 25, 1 };\n<p>if (leTranDat.year_of_exp > juniorEmp.year_of_exp)\n{\nstd::cout &#x3C;&#x3C; leTranDat.name &#x3C;&#x3C; \" has more experience than \" &#x3C;&#x3C; juniorEmp.name &#x3C;&#x3C; std::endl;\n}</code></pre></p>\n<p>Các trường dữ liệu của một struct sẽ tồn tại cùng với biến struct cho đến khi biến struct ra khỏi phạm vi sử dụng và bị hủy. Do đó, khi biến struct còn tồn tại, chúng ta vẫn có thể truy xuất đến các trường dữ liệu của nó.</p>\n<h5>Nhập và xuất dữ liệu cho biến struct</h5>\n<p>Cũng tương tự như nhập xuất dữ liệu cho biến thông thường, chỉ khác là chúng ta cần sử dụng thêm tên biến struct và <strong>member selection operator</strong> để compiler biết chúng ta nhập xuất cho trường dữ liệu của đơn vị nào. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">Employee emp;\n<p>//Input\nstd::cout &#x3C;&#x3C; \"Enter ID: \";\nstd::cin >> emp.ID;</p>\n<p>std::cout &#x3C;&#x3C; \"Enter name: \";\nstd::getline(std::cin, emp.name);</p>\n<p>std::cout &#x3C;&#x3C; \"Enter age: \";\nstd::cin >> emp.age;</p>\n<p>std::cout &#x3C;&#x3C; \"Enter year of experience: \";\nstd::cin >> emp.year_of_exp;</p>\n<p>//Output\nstd::cout &#x3C;&#x3C; \"===================================\" &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; emp.ID &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; emp.name &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; emp.age &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; emp.year_of_exp &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; \"===================================\" &#x3C;&#x3C; std::endl;</code></pre></p>\n<h5>Structs và function</h5>\n<p>Một ưu điểm khi sử dụng struct là chúng ta không cần truyền tất cả các trường dữ liệu của một đơn vị nào đó mà chỉ cần sử dụng một biến struct làm tham số cho hàm. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n};\n<p>void printVector2D(Vector2D vec)\n{\nstd::cout &#x3C;&#x3C; \"(\" &#x3C;&#x3C; vec.x &#x3C;&#x3C; \",\" &#x3C;&#x3C; vec.y &#x3C;&#x3C; \")\" &#x3C;&#x3C; std::endl;\n}</p>\n<p>int main()\n{\nVector2D vec = { 1, 4 };\nprintVector2D(vec);\n\nreturn 0;\n}</code></pre></p>\n<p>Trong ví dụ trên, mình sử dụng kiểu truyền dữ liệu giá trị nên tham số <code>Vector2D vec</code> của hàm printVector2D không làm thay đổi giá trị gốc của đối số. Các bạn cũng có thể thử truyền đối số là biến struct theo kiểu tham chiếu hoặc con trỏ, về mặt cơ bản, biến struct cũng là một biến có địa chỉ cụ thể nên chúng ta làm hoàn toàn tương tự như biến thông thường.</p>\n<p></p><pre><code class=\"lang-auto\">void normalize(Vector2D &amp;vec)\n{\n\tfloat length = sqrt((vec.x * vec.x) + (vec.y * vec.y));\n\tvec.x = vec.x / length;\n\tvec.y = vec.y / length;\n}\n<p>int main()\n{\nVector2D vec = { 1, 4 };\nprintVector2D(vec);</p>\n<pre><code>normalize(vec);\nprintVector2D(vec);\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Kiểu struct cũng có thể được dùng làm kiểu trả về của hàm. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">Vector2D addTwoVector(Vector2D vec1, Vector2D vec2)\n{\n\tVector2D result = { vec1.x + vec2.x, vec1.y + vec2.y };\n\treturn result;\n}\n<p>int main()\n{\nVector2D vec1 = { 1, 2 };\nVector2D vec2 = { 2, 2 };</p>\n<pre><code>Vector2D result = addTwoVector(vec1, vec2);\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Chúng ta có thể làm như trên vì ngôn ngữ C++ cho phép chúng ta gán biến struct cho một biến cùng kiểu struct khác. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">Vector2D vec1 = { 1, 2 };\nVector2D vec2 = vec1;</code></pre>\n<p>Nhưng chúng ta không nên sử dụng phép gán trực tiếp như vậy, vì có thể trong struct còn có các yếu tố phức tạp khác như con trỏ, hoặc struct khác, ... và dễ gây ra sai sót. Quay trở lại với chủ đề mình đang trình bày.</p>\n<p>Chúng ta còn có thể định nghĩa các hàm bên trong phần định nghĩa của struct. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n<p>Trong ví dụ trên, hàm normalize được định nghĩa trong cùng khối lệnh của struct Vector2D, nên nó có thể trực tiếp truy cập đến biến x và y và thao tác với chúng. Nhưng x và y của struct Vector2D vẫn đang còn ở mức khái niệm, chỉ khi nào struct Vector2D được dùng để khai báo biến, biến x và y cũng như hàm normalize mới được tạo ra. Như mình đã nói ở trên, việc định nghĩa một kiểu dữ liệu mới chỉ là định nghĩa những dữ liệu sẽ tồn tại trong biến struct nếu nó được tạo ra.</p>\n<p>Hàm normalize được tạo ra nhưng chỉ được sử dụng khi một biến struct cụ thể gọi đến nó bằng <strong>member selection operator</strong>.</p>\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec = { 1, 4 };\n\tvec.normalize();\n\t\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n<p>Hàm normalize trong struct Vector2D chỉ có thể được gọi thông qua một biến struct cụ thể. Như vậy, khi chúng ta muốn chuẩn hóa một Vector2D, chúng ta không cần truyền biến struct kiểu Vector2D vào hàm <code>normalize(Vector2D)</code> nữa mà chỉ cần gọi hàm <code>normalize</code> được định nghĩa trong chính nó. Đây cũng là một ưu điểm khi sử dụng struct.</p>\n<p>Mình lấy thêm một ví dụ nữa về hàm được định nghĩa bên trong struct để các bạn dễ hình dung:</p>\n<p></p><pre><code class=\"lang-auto\">struct Vector2D\n{\n\tfloat x;\n\tfloat y;\n\t\n\tvoid setPosition(float X, float Y)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t}\n\t\n\tvoid normalize()\n\t{\n\t\tfloat length = sqrt(x * x + y * y);\n\t\tx = x / length;\n\t\ty = y / length;\n\t}\n};</code></pre>\n<p>Mình vừa thêm vào struct Vector2D hàm <code>setPosition(float, float)</code>, lúc này mình không cần sử dụng <strong>initializer list</strong> để khởi tạo cho một biến kiểu Vector2D nữa, mà mình sẽ gọi hàm <code>setPosition(float, float)</code>.</p>\n<p></p><pre><code class=\"lang-auto\">int main()\n{\n\tVector2D vec;\n\tvec.setPosition(1, 4);\n\tprintVector2D(vec);\n\t\n\treturn 0;\n}</code></pre>\n<p>Điều này cũng làm tăng thêm ý nghĩa cho mã nguồn chương trình, giúp code của các bạn dễ đọc hơn. Chúng ta sẽ còn nói đến việc định nghĩa hàm bên trong struct trong những bài học tiếp theo.</p>\n<h5>Nested structs</h5>\n<p>Struct là một tập hợp các kiểu dữ liệu dùng để tạo nên một kiểu dữ liệu mới, và một kiểu struct cũng là một kiểu dữ liệu, nên chúng ta có thể sử dụng một kiểu struct khác để làm một trường dữ liệu cho struct cần tạo ra. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">struct Birthday\n{\n\t__int32 day;\n\t__int32 month;\n\t__int32 year;\n};\n<p>struct Employee\n{\n<strong>int32 ID;\nstd::string name;\nBirthday birthday;\n</strong>int32 year_of_exp;\n};</code></pre></p>\n<p>Trong trường hợp này, mình thay thế trường dữ liệu age bằng một trường dữ liệu kiểu Birthday đã được định nghĩa ở trên. Chúng ta có thể khởi tạo giá trị cho nested struct trên như sau:</p>\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };</code></pre>\n<p>Để truy xuất đến giá trị thực của trường dữ liệu birthday, chúng ta cần sử dụng thêm 1 lần <strong>member selection operator</strong>.</p>\n<p></p><pre><code class=\"lang-auto\">Employee emp = { 1, \"Le Tran Dat\", {1, 2, 2000}, 5 };\n<p>std::cout &#x3C;&#x3C; emp.ID &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; emp.name &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; emp.birthday.day &#x3C;&#x3C; \"/\" &#x3C;&#x3C; emp.birthday.month &#x3C;&#x3C; \"/\" &#x3C;&#x3C;emp.birthday.year &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; emp.year_of_exp &#x3C;&#x3C; std::endl;</code></pre></p>\n<hr>\n<h3>Tổng kết</h3>\n<p>Trong bài học này, chúng ta đã cùng nhau tìm hiểu cách để tạo ra một kiểu dữ liệu mới bằng từ khóa struct cung cấp bởi ngôn ngữ C++, một số thao tác cơ bản với biến struct.</p>\n<p>Struct là một khái niệm quan trọng trong ngôn ngữ C/C++, hiểu được structs là một bước quan trọng để tiếp cận hướng phát triển chương trình theo mô hình hướng đối tượng. Struct giúp chúng ta tổ chức chương trình hiệu quả hơn.</p>\n<h3>Bài tập cơ bản</h3>\n<p>1/ Các bạn hãy định nghĩa kiểu dữ liệu PhanSo đại diện cho kiểu phân số. Qua đó, viết chương trình cho phép người dùng thực hiện các phép cộng, trừ, nhân, chia 2 phân số.</p>\n<p>2/ Viết chương trình thực hiện phân tích thống kê cho một lớp học khoảng 20 sinh viên. Thông tin của mỗi sinh viên bao gồm ID, tên, tuổi, điểm tổng kết học kì 1, điểm tổng kết học kì 2. Những thông tin cần thống kê bao gồm:</p>\n<ul>\n<li>Điểm trung bình cuối năm của cả lớp.</li>\n<li>Điểm tổng kết cuối năm của sinh viên nào là cao nhất.</li>\n<li>Liệt kê danh sách những sinh viên có tiến bộ trong học tập (điểm tổng kết học kì 2 cao hơn điểm tổng kết học kì 1).</li>\n</ul>\n<hr>\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn.</p>\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.218b89a947ee10e7345fd63f614e71bf.json"}}}</script><script src="/phenomic.browser.64d39095e770f0256120.js"></script></body></html>