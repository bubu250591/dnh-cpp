{"head":{"title":"11.3 STL algorithms","route":"11/3-stl-algorithms","id":34695,"description":"int main() { \tstd::vector&lt;\\_\\_int32> container; } int main() { \tstd::vector&lt;\\_\\_int32> container; } bool isFive(\\_\\_int32 value) {…"},"body":"<html><head></head><body><h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong bài học này, chúng ta cùng tìm hiểu thành phần cuối cùng trong STL, đó là STL algorithm. </p>\n\n<h3>STL Algorithm</h3>\n\n<p>STL Algorithm cung cấp cho chúng ta một số thuật toán cơ bản để thao tác với các container class. Những thuật toán thường được sử dụng như search, sort, insert, reoder, remove, copy... tất cả đều được sử dụng để thao tác trên các container.</p>\n\n<p>Lưu ý: Các thuật toán này được cài đặt như những hàm có phạm vi global sử dụng các Iterator. Điều này có nghĩa các thuật toán này chỉ cần cài đặt một lần và nó được sử dụng cho các container chứa một tập hợp các iterator.</p>\n\n<p>Khi chúng ta sử dụng các thuật toán này, có thể chúng sẽ giúp chương trình của chúng ta hoạt động nhanh hơn, nhưng cũng có thể có trường hợp làm cho chương trình không hoạt động, lặp vô hạn hoặc có hiệu suất thấp.</p>\n\n<p>Để sử dụng STL algorithm, các bạn chỉ cần include thư viện <code>algorithm</code> vào file chương trình là được.</p>\n\n<h4>Search</h4>\n\n<h5>std::min_element and std::max_element</h5>\n\n<p>min_element và max_element được sử dụng để tìm ra phần tử có giá trị nhỏ nhất hoặc lớn nhất trong một STL container. Chức năng của 2 hàm này khá dễ hiểu, nên các bạn có thể xem ví dụ cụ thể bên dưới:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;algorithm></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;vector></span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32> container;\n\t\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++)\n\t\tcontainer.push_back(i + <span class=\"hljs-number\">1</span>);\n\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator iterMax = <span class=\"hljs-built_in\">std</span>::max_element(container.begin(), container.end());\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator iterMin = <span class=\"hljs-built_in\">std</span>::min_element(container.begin(), container.end());\n\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Max = \"</span> &#x3C;&#x3C; *iterMax &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Min = \"</span> &#x3C;&#x3C; *iterMin &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<p>Hai hàm này đều nhận vào 2 đối số là 2 Iterator đại diện cho đoạn container mà bạn muốn tìm kiếm và trả về một Iterator trỏ đến vị trí có phần tử lớn nhất hoặc nhỏ nhất. Ví dụ các bạn muốn chỉ search một nữa sau của container:</p>\n\n<p></p><pre><code class=\"hljs language-elixir\"><span class=\"hljs-symbol\">std:</span><span class=\"hljs-symbol\">:vector&#x3C;__int32></span><span class=\"hljs-symbol\">:</span><span class=\"hljs-symbol\">:iterator</span> iterMax = <span class=\"hljs-symbol\">std:</span><span class=\"hljs-symbol\">:max_element</span>(container.<span class=\"hljs-keyword\">begin</span>() + container.size() / <span class=\"hljs-number\">2</span>, container.<span class=\"hljs-keyword\">end</span>());</code></pre>\n\n<h5>std::find</h5>\n\n<p>Hàm này được sử dụng để tìm kiếm một giá trị đưa ra có tồn tại trong container hay không, nếu có thì trả về một Iterator trỏ đến vị trí xuất hiện phần tử đó, ngược lại thì trả về Iterator trỏ đến end() của container. Ví dụ:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;algorithm></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;vector></span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32> container;\n\t\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++)\n\t\tcontainer.push_back(i + <span class=\"hljs-number\">1</span>);\n\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator iter = <span class=\"hljs-built_in\">std</span>::find(container.begin(), container.end(), <span class=\"hljs-number\">11</span>);\n\t<span class=\"hljs-keyword\">if</span> (iter == container.end())\n\t{\n\t\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Can not find your given value!\"</span> &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\t}\n\t<span class=\"hljs-keyword\">else</span>\n\t{\n\t\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Found at index: \"</span> &#x3C;&#x3C; iter - container.begin() &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<h5>std::find_if</h5>\n\n<p>Hàm này được định nghĩa như sau:</p>\n\n<p></p><pre><code class=\"hljs language-applescript\">template &#x3C;<span class=\"hljs-built_in\">class</span> InputIterator, <span class=\"hljs-built_in\">class</span> UnaryPredicate>\nInputIterator find_if (InputIterator <span class=\"hljs-keyword\">first</span>, InputIterator <span class=\"hljs-keyword\">last</span>, UnaryPredicate pred);</code></pre>\n\n<p>Hàm này nhận vào 2 đối số đầu tiên là 2 Iterator chỉ vị trí đầu và cuối (giới hạn đoạn container) mà các bạn muốn tìm kiếm. Khác với hàm std::find, hàm này không tìm kiếm sự xuất hiện của một giá trị cụ thể, mà các bạn cần cung cấp cho hàm một điều kiện nào đó, điều kiện này được biểu diễn thông qua một hàm có dạng:</p>\n\n<p></p><pre><code class=\"hljs language-cs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isSatisfyYourCondition</span>(<span class=\"hljs-params\">container_type <span class=\"hljs-keyword\">value</span></span>)</span>;</code></pre>\n\n<p>Tham số thứ 3 của hàm std::find_if là một con trỏ hàm có dạng:</p>\n\n<p></p><pre><code class=\"hljs language-lisp\">bool (<span class=\"hljs-name\">*ptr</span>)(<span class=\"hljs-name\">container_type</span>)<span class=\"hljs-comment\">;</span></code></pre>\n\n<p>Do đó, chúng ta có thể truyền đối số thứ 3 cho hàm std::find_if là tên của hàm isSatisfyYourCondition mình đã khai báo ở trên (chỉ là ví dụ minh họa).</p>\n\n<p>Với mỗi lần duyệt qua một phần tử trong đoạn container từ <code>first</code> đến <code>last</code>, mỗi phần tử sẽ được kiểm tra bên trong hàm được gán cho tham số thứ 3 của <code>std::find_if</code>. Nếu phần tử được kiểm tra thõa mãn điều kiện bạn đặt ra (hàm isSatisfyYourCondition trả về true), một Iterator trỏ đến phần tử vừa kiểm tra sẽ được trả về. Iterator last mà bạn truyền vào sẽ được trả về nếu không có phần tử nào thõa mãn điều kiện.</p>\n\n<p>Mình lấy một ví dụ như sau:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;algorithm></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;vector></span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isFive</span><span class=\"hljs-params\">(<span class=\"hljs-number\">__</span>int32 value)</span>\n</span>{\n\t<span class=\"hljs-keyword\">return</span> value == <span class=\"hljs-number\">5</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32> container;\n\t\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++)\n\t\tcontainer.push_back(i + <span class=\"hljs-number\">1</span>);\n\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator iter = <span class=\"hljs-built_in\">std</span>::find_if(container.begin(), container.end(), isFive);\n\t\n\t<span class=\"hljs-keyword\">if</span> (iter != container.end())\n\t{\n\t\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Found at index: \"</span> &#x3C;&#x3C; iter - container.begin() &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\t}\n\t<span class=\"hljs-keyword\">else</span>\n\t{\n\t\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Can not found this value!\"</span> &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<p>Hàm isFive sẽ chịu trách nhiệm kiểm tra giá trị của một phần tử trong container có bằng 5 hay không. Do mình kiểm tra từ đầu đến cuối container, nên chắc chắn sẽ hàm <code>std::find_if</code> sẽ tìm được phần tử phù hợp.</p>\n\n<p>Các bạn thử thay đổi lại một chút như sau:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator iter = <span class=\"hljs-built_in\">std</span>::find_if(container.begin(), container.end() - <span class=\"hljs-number\">8</span>, isFive);\n\t\n<span class=\"hljs-keyword\">if</span> (iter != container.end())\n{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Found at index: \"</span> &#x3C;&#x3C; iter - container.begin() &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n}\n<span class=\"hljs-keyword\">else</span>\n{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-string\">\"Can not found this value!\"</span> &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n}</code></pre>\n\n<p>và xem thử kết quả có gì khác biệt.</p>\n\n<h4>Sort</h4>\n\n<p>Sắp xếp cũng là một trong những thuật toán thường xuyên được áp dụng trong thực tế.</p>\n\n<h5>std::sort</h5>\n\n<p>Có 2 định nghĩa được overload cho hàm <code>std::sort</code>, một phiên bản được sử dụng để sắp xếp đoạn container từ Iterator first đến Iterator last theo thứ tự giá trị tăng dần từ bé đến lớn. Ví dụ:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;ctime></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;cstdlib></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;algorithm></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;vector></span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32> container;\n\t\n\tsrand(time(<span class=\"hljs-literal\">NULL</span>));\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++)\n\t\tcontainer.push_back(rand() % <span class=\"hljs-number\">100</span>);\n\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; container.size(); i++)\n\t\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; container.at(i) &#x3C;&#x3C; <span class=\"hljs-string\">\" \"</span>;\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\n\t<span class=\"hljs-built_in\">std</span>::sort(container.begin(), container.end());\n\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; container.size(); i++)\n\t\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; container.at(i) &#x3C;&#x3C; <span class=\"hljs-string\">\" \"</span>;\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<p>Một phiên bản khác của <code>std::sort</code> là hàm có 3 tham số, trong đó, tham số thứ 3 là một con trỏ hàm có dạng:</p>\n\n<p></p><pre><code class=\"hljs language-lisp\">bool (<span class=\"hljs-name\">*ptr</span>)(<span class=\"hljs-name\">container_type</span>, container_type)<span class=\"hljs-comment\">;</span></code></pre>\n\n<p>Hàm được trỏ đến bởi tham số này sẽ định nghĩa mối quan hệ giữa 2 phần tử được đem ra so sánh (để sắp xếp). Các bạn có thể tham khảo thêm tại đường dẫn bên dưới:</p>\n\n<p><a href=\"http://www.cplusplus.com/reference/algorithm/sort/\">std::sort</a></p>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Qua bài học này, các bạn đã cùng mình tìm hiểu một số STL algorithm phổ biến được định nghĩa bên trong thư viện algorithm. Để xem chi tiết về các algorithm khác của STL, các bạn có thể tham khảo tại đây: <a href=\"http://www.cplusplus.com/reference/algorithm/\">http://www.cplusplus.com/reference/algorithm/</a></p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n</body></html>","__filename":"generated/34695.md","__url":"/11/3-stl-algorithms/","__resourceUrl":"/11/3-stl-algorithms/index.html","__dataUrl":"/11/3-stl-algorithms/index.html.c65846cea782398aef11f85328128365.json"}