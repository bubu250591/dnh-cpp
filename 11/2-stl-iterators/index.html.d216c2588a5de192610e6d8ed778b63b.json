{"head":{"title":"11.2 STL iterators","route":"11/2-stl-iterators","id":34567,"description":"int main() { \tstd::vector&lt;int> vec; } } for (int i = 0; i &lt; 10; i++) \tvec.push_back(i); std::vector&lt;\\_\\_int32>::iterator iter =…"},"body":"<html><head></head><body><h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong bài học về STL containers, mình đã giới thiệu với các bạn một số class được sử dụng để tạo ra các container với những cách tổ chức dữ liệu khác nhau. Tuy nhiên, tập hợp các phần tử được chứa bên trong container vẫn có một trật tự nhất định (tùy vào thuật toán sắp xếp được chọn), và để duyệt qua các phần tử trong các container chúng ta sẽ sử dụng các STL Iterator tương ứng.</p>\n\n<h3>STL Iterator</h3>\n\n<p>Một Iterator là một đối tượng có thể đi qua (iterate over) một container class mà không cần biết trật tự các phần tử bên trong mảng. Iterator còn là một cách để truy cập dữ liệu bên trong các container.</p>\n\n<p>Các bạn có thể hình dùng Iterator giống như một con trỏ trỏ đến một phần tử nào đó bên trong container với một số toán tử đã được định nghĩa:</p>\n\n<ul>\n<li>Operator* cereference và trả về giá trị bên trong container tại vị trí mà iterator được đặt.</li>\n<li>Operator++ di chuyển iterator đến phần tử tiếp theo trong container.</li>\n<li>Operator-- ngược lại so với operator++.</li>\n<li>Operator== và operator!= dùng để so sánh vị trí tương đối của 2 phần tử đang được trỏ đến bởi 2 iterator.</li>\n<li>Operator= dùng để gán vị trí mà iterator trỏ đến.</li>\n</ul>\n\n<h4>Khai báo một Iterator</h4>\n\n<p>Với mỗi container class chúng ta sẽ có một kiểu iterator tương ứng. Mình sẽ lấy ví dụ về iterator của class std::vector như sau:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;vector></span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;<span class=\"hljs-keyword\">int</span>> vec;\n\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;<span class=\"hljs-keyword\">int</span>>::iterator iter;\n\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<p>Như vậy, chúng ta có <code>iter</code> là một đối tượng của class <code>std::vector&#x3C;int>::iterator</code>. Với cách khai báo này, chúng ta có thể là có một class tên là iterator được định nghĩa bên trong khối lệnh của class <code>std::vector&#x3C;generic_type></code>.</p>\n\n<p><strong><em>Lưu ý: kiểu dữ liệu của các phần tử trong container class sẽ là kiểu dữ liệu được dùng cho <code>generic_type</code> của iterator.</em></strong></p>\n\n<p>Ví dụ khi chúng ta muốn có một Iterator dùng cho một <code>std::list&#x3C;Employee></code> thì Iterator sẽ được khai báo như sau:</p>\n\n<p></p><pre><code class=\"hljs language-elixir\"><span class=\"hljs-symbol\">std:</span><span class=\"hljs-symbol\">:list&#x3C;Employee></span><span class=\"hljs-symbol\">:</span><span class=\"hljs-symbol\">:iterator</span> iter;</code></pre>\n\n<h4>Các phương thức trả về kiểu Iterator của các container class</h4>\n\n<p>Như các bạn đã biết, một giá trị muốn được gán cho một biến (hoặc một đối tượng nào đó) thì giá trị và biến đó phải cùng kiểu dữ liệu với nhau. Như vậy, muốn gán địa chỉ (vị trí) của một phần tử trong container cho một iterator thì chúng ta cũng cần có những phương thức trả về giá trị kiểu iterator tương ứng.</p>\n\n<p>Mỗi container class trong STL (ngoại trừ các container đặc biệt như <code>std::stack và std::queue</code>) đều chứa định nghĩa của một iterator bên trong.</p>\n\n<p></p><div class=\"lightbox-wrapper\"><a href=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-2-STL-iterators/0.png?raw=true\" class=\"lightbox\" title=\"0.png?raw=true\"><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-2-STL-iterators/0.png?raw=true\" width=\"690\" height=\"435\"><div class=\"meta\">\n<span class=\"filename\">0.png?raw=true</span><span class=\"informations\">900x568</span><span class=\"expand\"></span>\n</div></a></div><p></p>\n\n<p>Và những container có chứa định nghĩa class iterator sẽ có những phương thức trả về giá trị kiểu iterator tương ứng:</p>\n\n<ul>\n<li>begin() trả về một iterator đại diện cho vị trí của phần tử đầu tiên trong container.</li>\n<li>end() trả về một iterator đại diện cho vị trí đứng ngay sau phần tử cuối cùng trong container.</li>\n<li>cbegin() trả về một hằng (read-only) iterator đại diện cho vị trí của phần tử đầu tiên trong container.</li>\n<li>cend() trả về một hằng (read-only) iterator đại diện cho vị trí đứng ngay sau phần tử cuối cùng trong container.</li>\n</ul>\n\n<p>Ví dụ:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32> vec;\n\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++)\n\t\tvec.push_back(i);\n\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator the_beginning = vec.begin();\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator the_end = vec.end();\n\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; *(the_beginning<span class=\"hljs-number\">._</span>Ptr) &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; *(the_end<span class=\"hljs-number\">._</span>Ptr) &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>; <span class=\"hljs-comment\">//print a garbage value</span>\n\t\n\tthe_end--;\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; *(the_end<span class=\"hljs-number\">._</span>Ptr) &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<p>Lần in giá trị thứ 2 trong đoạn chương trình trên sẽ in ra một giá trị rác, vì iterator the_end lúc này đang trỏ đến vị trí nằm ngoài giới hạn vùng nhớ tương ứng với <code>vec[vec.size()]</code>, trong khi chỉ số của phần tử cuối cùng trong container là <code>(vec.size() - 1)</code>.</p>\n\n<p>Tại sao end() lại trả về vị trí đứng sau phần tử cuối cùng trong container?</p>\n\n<p>Đó là vì chúng ta sẽ sử dụng iterator này để kiểm tra xem thử chúng ta đã duyệt hết phần tử trong mảng hay chưa. Ví dụ:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32> vec;\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++)\n\tvec.push_back(i);\n\n<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&#x3C;__int32>::iterator iter = vec.begin();\n<span class=\"hljs-keyword\">while</span> (iter != vec.end())\n{\n\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; *iter &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n\titer++;\n}</code></pre>\n\n<p>Khi vòng lặp while kiểm tra đc iter đã lặp đến vị trí end(), nó sẽ hiểu rằng iter đã trỏ ra ngoài giới hạn của container và kết thúc vòng lặp.</p>\n\n<p>Mình lấy thêm một ví dụ khác sử dụng iterator để duyệt qua tất cả phần tử bên trong một <code>std::map</code>:</p>\n\n<p></p><pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;map></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&#x3C;string></span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">map</span>&#x3C;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>> mymap;\n    mymap.insert(<span class=\"hljs-built_in\">std</span>::make_pair(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">\"apple\"</span>));\n    mymap.insert(<span class=\"hljs-built_in\">std</span>::make_pair(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">\"orange\"</span>));\n    mymap.insert(<span class=\"hljs-built_in\">std</span>::make_pair(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"banana\"</span>));\n    mymap.insert(<span class=\"hljs-built_in\">std</span>::make_pair(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">\"grapes\"</span>));\n    mymap.insert(<span class=\"hljs-built_in\">std</span>::make_pair(<span class=\"hljs-number\">6</span>, <span class=\"hljs-string\">\"mango\"</span>));\n    mymap.insert(<span class=\"hljs-built_in\">std</span>::make_pair(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">\"peach\"</span>));\n \n    <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">map</span>&#x3C;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">string</span>>::const_iterator it; <span class=\"hljs-comment\">// declare an iterator</span>\n    it = mymap.begin(); <span class=\"hljs-comment\">// assign it to the start of the vector</span>\n    <span class=\"hljs-keyword\">while</span> (it != mymap.end()) <span class=\"hljs-comment\">// while it hasn't reach the end</span>\n    {\n        <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; it->first &#x3C;&#x3C; <span class=\"hljs-string\">\"=\"</span> &#x3C;&#x3C; it->second &#x3C;&#x3C; <span class=\"hljs-string\">\" \"</span>; <span class=\"hljs-comment\">// print the value of the element it points to</span>\n        ++it; <span class=\"hljs-comment\">// and iterate to the next element</span>\n    }\n \n    <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &#x3C;&#x3C; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;\n}</code></pre>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>STL Iterator cũng tương tự như một dạng con trỏ chỉ sử dụng cho các STL Container class tương ứng. Sử dụng các STL Iterator có thể giảm thiểu mối nguy hiểm cho chương trình thay vì phải sử dụng con trỏ cho các mảng dữ liệu. Khi sử dụng STL Iterator, chúng ta không cần quan tâm dữ liệu bên trong container được tổ chức như thế nào, mà chỉ biết kết quả khi sử dụng iterator để duyệt qua container.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n</body></html>","__filename":"generated/34567.md","__url":"/11/2-stl-iterators/","__resourceUrl":"/11/2-stl-iterators/index.html","__dataUrl":"/11/2-stl-iterators/index.html.d216c2588a5de192610e6d8ed778b63b.json"}