{"head":{"title":"11.1 STL containers","route":"11/1-stl-containers","id":34210,"description":"std::vector&lt;\\_\\_int32> vecInt32; std::vector&lt;int32> vec2(5); //gọi phương thức khởi tạo std::vector(size_t \\_Count) với giá trị…"},"body":"\n<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n\n<p>Trong bài học này, mình sẽ hướng dẫn các bạn cách sử dụng một số container class của STL. Trước các bài học trước đây, mình đã từng giới thiệu đến các bạn một class thuộc STL, đó là <a href=\"//daynhauhoc.com/t/thu-vien-array-trong-stl-c/30083\">std::array</a> (trong chương mảng một chiều) hay là <a href=\"//daynhauhoc.com/t/thu-vien-string-trong-c/30092\">std::string</a> trong chương mảng kí tự. <code>std::array</code> thư viện khá đơn giản có thể dùng để thay thế cho mảng một chiều.</p>\n\n<p>Tuy nhiên, nhược điểm của std::array (cũng là nhược điểm của mảng một chiều) là kích thước bộ nhớ được cấp phát là cố định. Do đó, khả năng khai báo thiếu số lượng phần tử hoặc dư thừa quá mức cần thiết thường xuyên xảy ra. Để khắc phục nhược điểm này, STL đã hổ trợ cho chúng ta các container class khác dùng để lưu trữ, xử lý các phần tử với kích thước vùng nhớ tự động thay đổi để phù hợp với yêu cầu người dùng.</p>\n\n<p>Trước khi đi vào tìm hiểu các container class của STL, chúng ta nên phân chúng ra thành 3 loại container khác nhau:</p>\n\n<ul>\n<li>\n<p>Sequence container</p>\n<p>Sequence container là tập hợp các container class nó duy trì trật tự của các phần tử bên trong container. Một đặc tính của Sequence container là các bạn có thể chọn ví trí muốn chèn thêm phần tử vào container. Một ví dụ điển hình là khi các bạn thêm một phần tử vào mảng một chiều, các phần tử còn lại vẫn giữ nguyên thứ tự của chúng như trước khi chèn. </p>\n<p>Ngôn ngữ C++11 cung cấp cho chúng ta 6 sequence containers: <strong>std::vector, std::deque, std::array, std::list, std::forward_list, std::basic_string</strong>.</p>\n</li>\n<li>\n<p>Associative container</p>\n<p>Associative container là các container được thiết kế kèm theo cơ chế tự động sắp xếp dữ liệu đầu vào khi chúng được đưa vào container. Cơ chế tổ chức dữ liệu của các container này sẽ quyết định vị trí của các phần tử trong container. Thông thường, associative container thực hiện phép so sánh sử dụng toán tử &lt;.</p>\n<p>Một số associative container được sử dụng phổ biến là: <strong>std::set, std::map...</strong></p>\n</li>\n<li>\n<p>Container adapter</p>\n<p>Container adapter là các container được sử dụng cho các cấu trúc lưu trữ đặc biệt: <strong>std::stack, std::queue, ...</strong></p>\n</li>\n</ul>\n\n<h1>Sequence container</h1>\n\n<h2>std::vector</h2>\n\n<p>Cũng giống như std::array, vectors lưu trữ các phần tử liên tiếp nhau trên bộ nhớ ảo. Điều này có nghĩa những phần tử trong std::vector có thể truy cập thông qua các con trỏ có cùng kiểu dữ liệu với kiểu của std::vector. Đặc điểm khiến std::vector khác với std::array là nó có thể thay đổi kích thước container tự động khi các phương thức, các toán tử được định nghĩa bên trong class std::vector được sử dụng.</p>\n\n<h3>Khai báo một std::vector</h3>\n\n<p>Để sử dụng std::vector, chúng ta cần include thư viện vector vào file chương trình. Dưới đây là cú pháp khai báo cơ bản để tạo ra một đối tượng từ lớp std::vector:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt; &lt;data_type&gt; &gt; &lt;vector_name&gt;;</code></pre>\n\n<p><strong>data_type</strong> của vector là một kiểu dữ liệu tổng quát, các bạn có thể chọn tùy ý dựa vào mục đích lưu trữ của chương trình, nó có thể là một kiểu dữ liệu built-in, cũng có thể là kiểu dữ liệu struct do các bạn tự định nghĩa ra. Mình lấy một ví dụ như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;vector&gt;\n\nstd::vector&lt;__int32&gt; vecInt32;</code></pre>\n\n<p>Như vậy là chúng ta đã có một đối tượng của lớp std::vector có thể lưu trữ các phần tử kiểu <code>__int32</code> trong container. Lúc này, container của vecInt32 vẫn chưa có phần tử nào cả, chúng ta có thể kiểm chứng bằng cách sử dụng phương thức std::vector::size() để kiểm tra kích thước của container.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::cout &lt;&lt; \"Size of vecInt32: \" &lt;&lt; vecInt32.size() &lt;&lt; std::endl;</code></pre>\n\n<p>Kết quả cho ra màn hình là 0 (tương ứng với 0 phần tử hiện tại có trong container của vecInt32).</p>\n\n<h3>Một số phương thức khởi tạo cho đối tượng của lớp std::vector</h3>\n\n<p>Sau này khi học đến phần C++ Object oriented programming, các bạn sẽ biết rằng một class có thể có một hoặc nhiều phương thức khởi tạo giá trị cho các thành phần dữ liệu bên trong class đó. Class std::vector có đến hơn 10 phương thức khởi tạo khác nhau:</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/0.png?raw=true\" width=\"653\" height=\"209\"></p>\n\n<p>Tuy nhiên, mình chỉ hướng dẫn các bạn sử dụng một số phương thức khởi tạo đơn giản. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vec1(); //gọi phương thức khởi tạo mặc định, khởi tạo kích thước container là 0.\n\nstd::vector&lt;__int32&gt; vec2(5); //gọi phương thức khởi tạo std::vector(size_t _Count) với giá trị truyền vào là 5, khởi tạo kích thước container là 5 phần tử kiểu __int32.\n\nstd::vector&lt;__int32&gt; vec3(vec2); //gọi phương thức khởi tạo std::vector(const std::vector &amp;other), khởi tạo một container giống với container của vector other.</code></pre>\n\n<p>Những phương thức khởi tạo còn lại thường ít được sử dụng.</p>\n\n<h3>Sử dụng các phương thức trong class std::vector</h3>\n\n<p>Sau khi các bạn khai báo (có thể có khởi tạo hoặc không) một đối tượng của lớp std::vector, lúc này chúng ta có thể sử dụng các phương thức (các hàm bên trong lớp) trong lớp std::vector để thao tác với container của đối tượng đó.</p>\n\n<h4>Modifiers</h4>\n\n<h5>std::vector::push_back(const vector_type &amp;value)</h5>\n\n<blockquote><p>Khi mình viết std::vector::push_back, các bạn có thể hiểu phương thức push_back được định nghĩa bên trong khối lệnh có tên vector, và vector được định nghĩa bên trong khối lệnh của std.</p></blockquote>\n\n<p>Phương thức này cho phép thêm một phần tử vào sau phần tử có vị trí cuối cùng trong container, phần tử mới được thêm vào sẽ trở thành phần tử có chỉ số cao nhất trong container. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vecInt32;\nfor (int i = 1; i &lt;= 10; i++)\n{\n    vecInt32.push_back(i);\n}</code></pre>\n\n<p>Mỗi lần sử dụng phương thức push_back, kích thước của container sẽ tăng lên 1. Nếu số phần tử vượt quá kích thước của container, vector sẽ tự động cấp phát lại vùng nhớ đủ để chứa tất cả các phần tử.</p>\n\n<h5>std::vector::pop_back()</h5>\n\n<p>Gọi phương thức này sẽ xóa đi một phần tử tại chỉ số cuối cùng trong container. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vecInt32;\n\nfor (int i = 1; i &lt;= 10; i++)\n{\n\tvecInt32.push_back(i);\n}\n//container = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }\n\nvecInt32.pop_back();\n//container = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }</code></pre>\n\n<p>Nếu các bạn sử dụng phương thức này khi container của vector rỗng, Visual studio (trong chế độ Debug) sẽ thông báo chương trình vi phạm điều kiện của assertion trong phương thức <code>pop_back</code>.</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/1.png?raw=true\" width=\"427\" height=\"328\"></p>\n\n<h5>std::vector::insert</h5>\n\n<p>Để sử dụng phương này, chúng ta cần sử dụng thêm STL Iterator, đến bài học về STL Iterator mình sẽ trình bày rõ hơn về phương thức này. Các bạn có thể hiểu đơn giản là một iterator cũng là một con trỏ, nó trỏ vào container của std::vector giúp phương thức insert xác định được vị trí cần chèn phần tử.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vecInt32;\nstd::vector&lt;__int32&gt;::iterator iter;\n\n//iter point to the begin of vecInt32\niter = vecInt32.begin();\n\n//insert new element into vecInt32's container\nvecInt32.insert(iter, 10);\n\n//container = { 10 }\n\niter = vecInt32.end();\nvecInt32.insert(iter, 20);\n\n//container = { 10, 20 }\n\niter = vecInt32.begin() + 1;\nvecInt32.insert(iter, 15);\n\n//container = { 10, 15, 20 }</code></pre>\n\n<p>Kích thước của container sẽ tự động thay đổi đủ để chứa tất cả các phần tử sau khi insert.</p>\n\n<h5>std::vector::erase(const_iterator position)</h5>\n\n<p>Phương thức này cho phép xóa một phần tử tại vị trí được trỏ đến bởi iterator position. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector;\n\n// set some values (from 1 to 10)\nfor (int i=1; i&lt;=10; i++) \n\tmyvector.push_back(i);\n\n// erase the 6th element\nmyvector.erase (myvector.begin()+5);\n\n//container = { 1, 2, 3, 4, 5, 7, 8, 9, 10 }</code></pre>\n\n<h4>Element access</h4>\n\n<h5>operator[size_type index]</h5>\n\n<p>Sử dụng toán tử [] cho vector sẽ trả về giá trị tại chỉ số index được truyền vào (Tương tự mảng một chiều).</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector(10); //10 zero-initialized elements\n\nfor (int i = 0; i &lt; myvector.size(); i++)\n\tmyvector[i] = i;\n\t\nstd::cout &lt;&lt; myvector[4] &lt;&lt; std::endl;</code></pre>\n\n<p>Các bạn lưu ý chỉ số bắt đầu của container cũng là 0 giống với mảng một chiều.</p>\n\n<h5>std::vector::at(size_type index)</h5>\n\n<p>Tương tự operator[].</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector(10); //10 zero-initialized elements\n\nfor (int i = 0; i &lt; myvector.size(); i++)\n\tmyvector[i] = i;\n\t\nstd::cout &lt;&lt; myvector.at(4) &lt;&lt; std::endl;</code></pre>\n\n<h4>Capacity</h4>\n\n<h5>std::vector::size()</h5>\n\n<p>Phương thức size trả về số lượng phần tử chứa trong container của vector.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myints;\nstd::cout &lt;&lt; \"0. size: \" &lt;&lt; myints.size() &lt;&lt; std::endl;\n\nfor (int i=0; i&lt;10; i++) \n\tmyints.push_back(i);\n\t\nstd::cout &lt;&lt; \"1. size: \" &lt;&lt; myints.size() &lt;&lt; std::endl;</code></pre>\n\n<h5>std::vector::max_size()</h5>\n\n<p>Trả về số lượng phần tử tối đa mà vector có thể chứa, đồng nghĩa với kích thước vùng nhớ tối đa có thể cấp phát cho container của vector.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector;\n\n// set some content in the vector\nfor (int i = 0; i&lt;100; i++) \n\tmyvector.push_back(i);\n\nstd::cout &lt;&lt; \"size: \" &lt;&lt; myvector.size() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"max_size: \" &lt;&lt; myvector.max_size() &lt;&lt; std::endl;</code></pre>\n\n<h5>std::vector::capacity()</h5>\n\n<p>Trả về kích thước bộ nhớ đã cấp phát cho container của vector.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector;\n\n// set some content in the vector\nfor (int i = 0; i&lt;100; i++) \n\tmyvector.push_back(i);\n\nstd::cout &lt;&lt; \"size: \" &lt;&lt; myvector.size() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"capacity: \" &lt;&lt; (int)myvector.capacity() &lt;&lt; std::endl;</code></pre>\n\n<p>Kích thước vùng nhớ được cấp phát cho container thường sẽ lớn hơn số lượng phần tử mà container đang chứa. Điều này đảm bảo khi người dùng thêm phần tử vào container, vector sẽ chưa cần tốn chi phí cấp phát lại vùng nhớ mới.</p>\n\n<p>Mình vừa trình bày một số phương thức đơn giản thường được sử dụng của class std::vector. Các bạn có thể tự mình tìm hiểu các phương thức khác của class std::vector qua đường dẫn sau: </p>\n\n<p><a href=\"http://www.cplusplus.com/reference/vector/vector/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/vector/vector/</a></p>\n\n<h2>std::list</h2>\n\n<p>std::list containers mô phỏng lại cấu trúc dữ liệu doubly-linked lists; Doubly-linked list có thể lưu trữ các phần tử không liên tiếp nhau trên vùng nhớ nhưng vẫn đảm bảo được thứ tự của các phần tử khi truy xuất. Trật tự của các phần tử được giữ bởi những sự kết nối giữa các cặp phần tử. </p>\n\n<p>Cấu trúc dữ liệu doubly-linked list cho phép người dùng thêm và xóa phần tử tại vị trí bất kỳ trong container, nhưng không hổ trợ truy cập ngẫu nhiên.</p>\n\n<h3>Khai báo một std::list</h3>\n\n<p>Để sử dụng std::list, chúng ta cần include thư viện list vào file chương trình. Dưới đây là cú pháp khai báo một đối tượng của lớp std::list:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt; &lt;data_type&gt; &gt; list_name;</code></pre>\n\n<p>Trong ví dụ dưới đây mình tạo ra một std::list dùng để lưu trữ các phần tử số nguyên:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;list&gt;\n\nstd::list&lt;__int32&gt; my_list;</code></pre>\n\n<h3>Khởi tạo đối tượng của lớp std::list</h3>\n\n<p>Cũng tương tự như class std::vector, std::list cũng có một số phương thức khởi tạo riêng. Một số phương thức khởi tạo thường dùng như:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; list1(); //gọi default constructor\n\nstd::list&lt;__int32&gt; list2(5); //gọi phương thức khởi tạo list(size_t _Count), khởi tạo danh sách có _Count phần tử\n\nstd::list&lt;__int32&gt; list3(list2); //gọi phương thức khởi tạo list(const list_type &amp;other), khởi tạo danh sách có container giống với other</code></pre>\n\n<h3>Sử dụng các phương thức của lớp std::list</h3>\n\n<h4>Capacity</h4>\n\n<p>(Tương tự std::vector)</p>\n\n<h4>Element access</h4>\n\n<p>Đối với cấu trúc dữ liệu doubly-linked list, chúng ta chỉ có thể truy xuất giá trị ở vị trí đầu tiên và cuối cùng trong container, std::list hỗ trợ cho chúng ta 2 phương thức truy xuất.</p>\n\n<h5>std::list::front()</h5>\n\n<p>Phương thức trả về giá trị của phần tử đầu tiên trong list container.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; my_list(5);\nstd::cout &lt;&lt; my_list.front() &lt;&lt; std::endl;</code></pre>\n\n<h5>std::list::back()</h5>\n\n<p>Ngược lại với phương thức ở trên, phương thức back trả về giá trị của phần tử cuối cùng trong list container.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; my_list(5);\nstd::cout &lt;&lt; my_list.back() &lt;&lt; std::endl;</code></pre>\n\n<h4>Modifiers</h4>\n\n<h5>std::list::push_back(const list_type &amp;value)</h5>\n\n<p>Phương thức này cho phép thêm một phần tử vào sau phần tử có vị trí cuối cùng trong container, phần tử mới được thêm vào sẽ trở thành phần tử có chỉ số cao nhất trong container. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nint myint;\n\nstd::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\" &lt;&lt; std::endl;\n\ndo \n{\n\tstd::cin &gt;&gt; myint;\n\tmylist.push_back (myint);\n} while (myint);\n\nstd::cout &lt;&lt; \"mylist stores \" &lt;&lt; mylist.size() &lt;&lt; \" numbers.\" &lt;&lt; std::endl;</code></pre>\n\n<h5>std::list::pop_back()</h5>\n\n<p>Xóa một phần tử cuối cùng trong list container. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nint sum (0);\nmylist.push_back (100);\nmylist.push_back (200);\nmylist.push_back (300);\n\nwhile (!mylist.empty())\n{\n\tsum+=mylist.back();\n\tmylist.pop_back();\n}\n\nstd::cout &lt;&lt; \"The elements of mylist summed \" &lt;&lt; sum &lt;&lt; std::endl;</code></pre>\n\n<p>Phương thức std::list::empty() dùng để kiểm tra container của list có rỗng hay không, nếu số phần tử của list khác 0 thì trả về false, ngược lại trả về true. (Các class containers của STL đều có phương thức này).</p>\n\n<h5>std::list::push_front(const list_type &amp;value)</h5>\n\n<p>Ngược lại với phương thức std::list::push_back, phương thức này dùng để thêm một phần tử có cùng kiểu với list vào vị trí đầu tiên trong container.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nmylist.push_front (200);\nmylist.push_front (300);\n\n//container = { 300, 200 }</code></pre>\n\n<h5>std::list::pop_front()</h5>\n\n<p>Xóa một phần tử trong list container tại vị trí đầu tiên.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nmylist.push_back (100);\nmylist.push_back (200);\nmylist.push_back (300);\n\nstd::cout &lt;&lt; \"Popping out the elements in mylist: \";\nwhile (!mylist.empty())\n{\nstd::cout &lt;&lt; ' ' &lt;&lt; mylist.front();\nmylist.pop_front();\n}\n\nstd::cout &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Final size of mylist is \" &lt;&lt; mylist.size() &lt;&lt; std::endl;</code></pre>\n\n<h4>Operations</h4>\n\n<h5>std::list::sort()</h5>\n\n<p>Phương thức này sẽ sắp xếp lại dữ liệu bên trong container theo thứ tự tăng dần (mặc định là vậy).</p>\n\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; my_list;\nstd::list&lt;__int32&gt;::iterator iter;\nmy_list.push_back(4);\nmy_list.push_back(6);\nmy_list.push_back(-2);\nmy_list.push_back(-1);\nmy_list.push_back(7);\n\n//container = { 4, 6, -2, -1, 7 }\n\nmy_list.sort();\n\n//container = { -2, -1, 4, 6, 7 }</code></pre>\n\n<p>Các bạn cũng có thể thay đổi điều kiện so sánh của phương thức sort bằng cách tự tạo một hàm so sánh 2 phần tử cùng kiểu dữ liệu với list. Ví dụ:</p>\n\n<p></p><pre><code class=\"lang-auto\">bool my_comparison(__int32 n1, __int32 n2)\n{\n\treturn n2 &lt; n1;\n}\n\nint main()\n{\n\tstd::list&lt;__int32&gt; my_list;\n\tstd::list&lt;__int32&gt;::iterator iter;\n\tmy_list.push_back(4);\n\tmy_list.push_back(6);\n\tmy_list.push_back(-2);\n\tmy_list.push_back(-1);\n\tmy_list.push_back(7);\n\t\n\t//container = { 4, 6, -2, -1, 7 }\n\n\tmy_list.sort(my_comparison);\n\n\t//container = { 7, 6, 4, -1, -2 }\n\t\n\treturn 0;\n}</code></pre>\n\n<p>Mình vừa liệt kê ra một vài phương thức thường dùng khi sử dụng std::list. Các bạn có thể tìm hiểu thêm một số phương thức khác của std::list tại đường dẫn</p>\n\n<p><a href=\"http://www.cplusplus.com/reference/list/list/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/list/list/</a></p>\n\n<p>Vậy là mình đã cùng các bạn tìm hiểu 2 sequence container trong bộ thư viện STL của ngôn ngữ C++. Do giới hạn thời gian và để đảm bảo hiệu suất của khóa học, các container tiếp theo mình sẽ đưa đường dẫn để các bạn tự tìm hiểu các phương thức trong từng class container. Cách tự tìm hiểu cũng giống như mình làm cùng các bạn ở trên.</p>\n\n<h1>Associative container</h1>\n\n<h2>std::set</h2>\n\n<p>std::set là class định nghĩa của một dạng container chỉ cho phép lưu trữ các phần tử có giá trị là duy nhất, phần tử có giá trị trùng lặp là không được cho phép. Những phần tử được thêm vào container sẽ được tự động sắp xếp dựa trên giá trị của chúng.</p>\n\n<p>[](http://www.cplusplus.com/reference/set/set/)</p>\n\n<p>Dưới đây là một đoạn chương trình mẫu sử dụng std::set</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nint main ()\n{\n\tstd::set&lt;int&gt; myset;\n\tstd::set&lt;int&gt;::iterator it;\n\n\t// set some initial values:\n\tfor (int i=1; i&lt;=5; i++) \n\t\tmyset.insert(i*10);    // set: 10 20 30 40 50\n\n\tit = myset.find(20);\n\tmyset.erase (it);\n\tmyset.erase (myset.find(40));\n\n\tstd::cout &lt;&lt; \"myset contains:\";\n\tfor (it=myset.begin(); it!=myset.end(); ++it)\n\t\tstd::cout &lt;&lt; ' ' &lt;&lt; *it;\n\tstd::cout &lt;&lt; std::endl;\n\n\treturn 0;\n}</code></pre>\n\n<h2>std::map</h2>\n\n<p>std::map là class định nghĩa một loại container dùng để lưu trữ các phần tử theo cấu trúc kết hợp (key_value, mapped_value). Dữ liệu trong container được sắp xếp dựa trên key_value, do đó key_value không được trùng lặp. Với mỗi key_value sẽ ánh xạ đến một mapped_value duy nhất.</p>\n\n<p><a href=\"http://www.cplusplus.com/reference/map/map/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/map/map/</a></p>\n\n<p>Các bạn lưu ý khi sử dụng std::map, mỗi khi thêm phần tử vào container thì phải thêm đủ một cặp giá trị . Ngôn ngữ C++ cung cấp cho chúng ta class std::pair giúp chúng ta nhóm 2 đối tượng có cùng (hoặc khác) kiểu dữ liệu thành một cặp tương ứng với cặp  của std::map.</p>\n\n<p></p><pre><code class=\"lang-auto\">std::pair&lt; data_type, data_type &gt; pair_name;</code></pre>\n\n<p>Một ví dụ về sử dung std::map để quản lý thông tin nhân viên:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n\nstruct Employee\n{\n\tstd::string name;\n\t__int32 year_of_experience;\n};\n\nint main()\n{\n\tstd::map&lt;__int32, Employee&gt; listEmployee;\n\n\tlistEmployee.insert(std::pair&lt;__int32, Employee&gt;(1, { \"Le Tran Dat\", 5 }));\n\tlistEmployee.insert(std::pair&lt;__int32, Employee&gt;(2, { \"Someone\", 0 }));\n\n\tlistEmployee[4] = { \"new employee\", 1 }; //operator[&lt;key&gt;] = &lt;value&gt;\n\n\tstd::map&lt;__int32, Employee&gt;::iterator iter = listEmployee.find(3);\n\tif (iter != listEmployee.end())\n\t{\n\t\tstd::cout &lt;&lt; \"Employee ID:        \" &lt;&lt; iter-&gt;first &lt;&lt; std::endl;\n\t\tstd::cout &lt;&lt; \"Employee name:      \" &lt;&lt; (iter-&gt;second).name &lt;&lt; std::endl;\n\t\tstd::cout &lt;&lt; \"Year of experience: \" &lt;&lt; (iter-&gt;second).year_of_experience &lt;&lt; std::endl;\n\t}\n\telse\n\t{\n\t\tstd::cout &lt;&lt; \"ID 3 is not exist\" &lt;&lt; std::endl;\n\t}\n\n\treturn 0;\n}</code></pre>\n\n<h1>Container adapter</h1>\n\n<h2>std::stack</h2>\n\n<p>Stack (hay còn gọi là ngăn xếp) là một dạng container có cơ chế tổ chức lưu trữ dữ liệu đặc biệt: LIFO (Last In First Out).</p>\n\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/2.png?raw=true\" width=\"417\" height=\"402\"></p>\n\n<p>Phần tử được thêm vào sau cùng sẽ được lấy ra đầu tiên.</p>\n\n<p><a href=\"http://www.cplusplus.com/reference/stack/stack/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/stack/stack/</a></p>\n\n<p>Dưới đây là một ví dụ ứng dụng cách tổ chức lưu trữ của cấu trúc dữ liệu Stack để chuyển đổi một số từ hệ thập phân sang hệ nhị phân:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nint main()\n{\n\t//input\n\t__int32 decNumber;\n\tstd::cin &gt;&gt; decNumber;\n\n\t//converting\n\tstd::stack&lt;bool&gt; binary;\n\twhile (decNumber)\n\t{\n\t\tbinary.push((decNumber % 2 == 1));\n\t\tdecNumber /= 2;\n\t}\n\n\t//output\n\twhile (!binary.empty())\n\t{\n\t\tstd::cout &lt;&lt; binary.top();\n\t\tbinary.pop(); //remove an element of stack\n\t}\n\tstd::cout &lt;&lt; std::endl;\n\n\treturn 0;\n}</code></pre>\n\n<p>Cấu trúc dữ liệu Stack còn có nhiều ứng dụng thực tiễn, ví dụ tạo ra chuỗi trạng thái cho phép người dùng trở lại trạng thái trước đó (undo).</p>\n\n<h2>std::queue</h2>\n\n<p>Queue (hay còn gọi là hàng đợi) là một cấu trúc dữ liệu hoạt động ngược lại so với cấu trúc dữ liệu Stack: FIFO (First In First Out). Chúng ta gặp cấu trúc dữ liệu này khá nhiều trong thực tế, ví dụ xếp hàng chờ mua hàng, người nào đến trước sẽ được mua hàng trước và ra khỏi hàng chờ sớm nhất.</p>\n\n<p><a href=\"http://www.cplusplus.com/reference/queue/queue/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/queue/queue/</a></p>\n\n<p>Dưới đây là một ví dụ sử dụng std::queue:</p>\n\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;      \n#include &lt;queue&gt;         \n\nint main()\n{\n\tstd::queue&lt;int&gt; myqueue;\n\tint myint;\n\n\tstd::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\" &lt;&lt; std::endl;\n\n\tdo {\n\t\tstd::cin &gt;&gt; myint;\n\t\tmyqueue.push(myint);\n\t} while (myint);\n\n\tstd::cout &lt;&lt; \"myqueue contains: \";\n\twhile (!myqueue.empty())\n\t{\n\t\tstd::cout &lt;&lt; ' ' &lt;&lt; myqueue.front();\n\t\tmyqueue.pop();\n\t}\n\tstd::cout &lt;&lt; std::endl;\n\n\treturn 0;\n}</code></pre>\n\n<hr>\n\n<h3>Tổng kết</h3>\n\n<p>Trong bài học này, mình đã hướng dẫn các bạn sử dụng một số class container thuộc Standard Template Library (STL) và cách để tự tìm hiểu cách sử dụng chúng. Về mặt cơ bản, các class container chỉ là một tập các thư viện thực thi các cấu trúc dữ liệu thường sử dụng trong lập trình. Cấu trúc dữ liệu là cách thức tổ chức, định dạng dữ liệu trong bộ nhớ máy tính. Chọn đúng cấu trúc dữ liệu cho một bài toán nào đó có thể giúp lập trình viên giải quyết vấn đề dễ dàng hơn.</p>\n\n<hr>\n\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>\n\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/34210.md","__url":"/11/1-stl-containers/","__resourceUrl":"/11/1-stl-containers/index.html","__dataUrl":"/11/1-stl-containers/index.html.801d3937ec25c5210d7a3d9a39a6cc9b.json"}