<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/phenomic.browser.930998131e7c47265375.css" /><meta data-react-helmet="true" property="og:site_name" content="dnh-cpp"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="11.1 STL containers"/><meta data-react-helmet="true" property="og:url" content="/11/1-stl-containers/"/><meta data-react-helmet="true" property="og:description" content="std::vector&amp;lt;\_\_int32&gt; vecInt32; std::vector&amp;lt;int32&gt; vec2(5); //gọi phương thức khởi tạo std::vector(size_t \_Count) với giá trị…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="11.1 STL containers"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="std::vector&amp;lt;\_\_int32&gt; vecInt32; std::vector&amp;lt;int32&gt; vec2(5); //gọi phương thức khởi tạo std::vector(size_t \_Count) với giá trị…"/><meta data-react-helmet="true" name="description" content="std::vector&amp;lt;\_\_int32&gt; vecInt32; std::vector&amp;lt;int32&gt; vec2(5); //gọi phương thức khởi tạo std::vector(size_t \_Count) với giá trị…"/><title data-react-helmet="true">11.1 STL containers</title><link data-react-helmet="true" rel="icon" type="image/png" sizes="144x144" href="//daynhauhoc.s3.amazonaws.com/36ee34de6c73f268424fceaef858c5428d8fb2a976.ico"/><link data-react-helmet="true" rel="icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/><link data-react-helmet="true" rel="apple-touch-icon" type="image/png" href="//daynhauhoc.s3.amazonaws.com/352ac0c01c6e4e15be7ee46da53668513fd4e93736.png"/></head><body><div id="phenomic"><div class="_2lE56" data-reactroot="" data-reactid="1" data-react-checksum="-2097439558"><!-- react-empty: 2 --><div class="_1Ih7a" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><div class="_1G2C6 _3fTO1" data-reactid="7"><div class="aCd9j" data-reactid="8"><a href="https://github.com/daynhauhoc/cppcoban" target="_blank" data-hint="Fork on Github" class="hint--bottom-left _2dICi" data-reactid="9"><span class="SVGInline" data-reactid="10"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span></a><a href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank" data-hint="Share on Facebook" class="hint--bottom-left _2dICi" data-reactid="11"><span class="SVGInline" data-reactid="12"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="430.113px" height="430.114px" viewBox="0 0 430.113 430.114" style="enable-background:new 0 0 430.113 430.114;"
	 xml:space="preserve">
<g>
	<path id="Facebook" d="M158.081,83.3c0,10.839,0,59.218,0,59.218h-43.385v72.412h43.385v215.183h89.122V214.936h59.805
		c0,0,5.601-34.721,8.316-72.685c-7.784,0-67.784,0-67.784,0s0-42.127,0-49.511c0-7.4,9.717-17.354,19.321-17.354
		c9.586,0,29.818,0,48.557,0c0-9.859,0-43.924,0-75.385c-25.016,0-53.476,0-66.021,0C155.878-0.004,158.081,72.48,158.081,83.3z"/>
</g>
</svg></span></a></div></div><article class="markdown-body" data-reactid="13"><h1 data-reactid="14">11.1 STL containers</h1><div data-reactid="15"><div class="phenomic-BodyContainer" data-reactid="16"><h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>
<p>Trong bài học này, mình sẽ hướng dẫn các bạn cách sử dụng một số container class của STL. Trước các bài học trước đây, mình đã từng giới thiệu đến các bạn một class thuộc STL, đó là <a href="//daynhauhoc.com/t/thu-vien-array-trong-stl-c/30083">std::array</a> (trong chương mảng một chiều) hay là <a href="//daynhauhoc.com/t/thu-vien-string-trong-c/30092">std::string</a> trong chương mảng kí tự. <code>std::array</code> thư viện khá đơn giản có thể dùng để thay thế cho mảng một chiều.</p>
<p>Tuy nhiên, nhược điểm của std::array (cũng là nhược điểm của mảng một chiều) là kích thước bộ nhớ được cấp phát là cố định. Do đó, khả năng khai báo thiếu số lượng phần tử hoặc dư thừa quá mức cần thiết thường xuyên xảy ra. Để khắc phục nhược điểm này, STL đã hổ trợ cho chúng ta các container class khác dùng để lưu trữ, xử lý các phần tử với kích thước vùng nhớ tự động thay đổi để phù hợp với yêu cầu người dùng.</p>
<p>Trước khi đi vào tìm hiểu các container class của STL, chúng ta nên phân chúng ra thành 3 loại container khác nhau:</p>
<ul>
<li>
<p>Sequence container</p>
<p>Sequence container là tập hợp các container class nó duy trì trật tự của các phần tử bên trong container. Một đặc tính của Sequence container là các bạn có thể chọn ví trí muốn chèn thêm phần tử vào container. Một ví dụ điển hình là khi các bạn thêm một phần tử vào mảng một chiều, các phần tử còn lại vẫn giữ nguyên thứ tự của chúng như trước khi chèn. </p>
<p>Ngôn ngữ C++11 cung cấp cho chúng ta 6 sequence containers: <strong>std::vector, std::deque, std::array, std::list, std::forward_list, std::basic_string</strong>.</p>
</li>
<li>
<p>Associative container</p>
<p>Associative container là các container được thiết kế kèm theo cơ chế tự động sắp xếp dữ liệu đầu vào khi chúng được đưa vào container. Cơ chế tổ chức dữ liệu của các container này sẽ quyết định vị trí của các phần tử trong container. Thông thường, associative container thực hiện phép so sánh sử dụng toán tử &lt;.</p>
<p>Một số associative container được sử dụng phổ biến là: <strong>std::set, std::map...</strong></p>
</li>
<li>
<p>Container adapter</p>
<p>Container adapter là các container được sử dụng cho các cấu trúc lưu trữ đặc biệt: <strong>std::stack, std::queue, ...</strong></p>
</li>
</ul>
<h1>Sequence container</h1>
<h2>std::vector</h2>
<p>Cũng giống như std::array, vectors lưu trữ các phần tử liên tiếp nhau trên bộ nhớ ảo. Điều này có nghĩa những phần tử trong std::vector có thể truy cập thông qua các con trỏ có cùng kiểu dữ liệu với kiểu của std::vector. Đặc điểm khiến std::vector khác với std::array là nó có thể thay đổi kích thước container tự động khi các phương thức, các toán tử được định nghĩa bên trong class std::vector được sử dụng.</p>
<h3>Khai báo một std::vector</h3>
<p>Để sử dụng std::vector, chúng ta cần include thư viện vector vào file chương trình. Dưới đây là cú pháp khai báo cơ bản để tạo ra một đối tượng từ lớp std::vector:</p>
<p></p><pre><code class="lang-auto">std::vector&lt; &lt;data_type&gt; &gt; &lt;vector_name&gt;;</code></pre>
<p><strong>data_type</strong> của vector là một kiểu dữ liệu tổng quát, các bạn có thể chọn tùy ý dựa vào mục đích lưu trữ của chương trình, nó có thể là một kiểu dữ liệu built-in, cũng có thể là kiểu dữ liệu struct do các bạn tự định nghĩa ra. Mình lấy một ví dụ như sau:</p>
<p></p><pre><code class="lang-auto">#include &lt;vector&gt;
<p>std::vector&#x3C;__int32> vecInt32;</code></pre></p>
<p>Như vậy là chúng ta đã có một đối tượng của lớp std::vector có thể lưu trữ các phần tử kiểu <code>__int32</code> trong container. Lúc này, container của vecInt32 vẫn chưa có phần tử nào cả, chúng ta có thể kiểm chứng bằng cách sử dụng phương thức std::vector::size() để kiểm tra kích thước của container.</p>
<p></p><pre><code class="lang-auto">std::cout &lt;&lt; "Size of vecInt32: " &lt;&lt; vecInt32.size() &lt;&lt; std::endl;</code></pre>
<p>Kết quả cho ra màn hình là 0 (tương ứng với 0 phần tử hiện tại có trong container của vecInt32).</p>
<h3>Một số phương thức khởi tạo cho đối tượng của lớp std::vector</h3>
<p>Sau này khi học đến phần C++ Object oriented programming, các bạn sẽ biết rằng một class có thể có một hoặc nhiều phương thức khởi tạo giá trị cho các thành phần dữ liệu bên trong class đó. Class std::vector có đến hơn 10 phương thức khởi tạo khác nhau:</p>
<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/0.png?raw=true" width="653" height="209"></p>
<p>Tuy nhiên, mình chỉ hướng dẫn các bạn sử dụng một số phương thức khởi tạo đơn giản. Ví dụ:</p>
<p></p><pre><code class="lang-auto">std::vector&lt;__int32&gt; vec1(); //gọi phương thức khởi tạo mặc định, khởi tạo kích thước container là 0.
<p>std::vector&#x3C;<strong>int32> vec2(5); //gọi phương thức khởi tạo std::vector(size_t _Count) với giá trị truyền vào là 5, khởi tạo kích thước container là 5 phần tử kiểu </strong>int32.</p>
<p>std::vector&#x3C;__int32> vec3(vec2); //gọi phương thức khởi tạo std::vector(const std::vector &#x26;other), khởi tạo một container giống với container của vector other.</code></pre></p>
<p>Những phương thức khởi tạo còn lại thường ít được sử dụng.</p>
<h3>Sử dụng các phương thức trong class std::vector</h3>
<p>Sau khi các bạn khai báo (có thể có khởi tạo hoặc không) một đối tượng của lớp std::vector, lúc này chúng ta có thể sử dụng các phương thức (các hàm bên trong lớp) trong lớp std::vector để thao tác với container của đối tượng đó.</p>
<h4>Modifiers</h4>
<h5>std::vector::push_back(const vector_type &amp;value)</h5>
<blockquote><p>Khi mình viết std::vector::push_back, các bạn có thể hiểu phương thức push_back được định nghĩa bên trong khối lệnh có tên vector, và vector được định nghĩa bên trong khối lệnh của std.</p></blockquote>
<p>Phương thức này cho phép thêm một phần tử vào sau phần tử có vị trí cuối cùng trong container, phần tử mới được thêm vào sẽ trở thành phần tử có chỉ số cao nhất trong container. Ví dụ:</p>
<p></p><pre><code class="lang-auto">std::vector&lt;__int32&gt; vecInt32;
for (int i = 1; i &lt;= 10; i++)
{
    vecInt32.push_back(i);
}</code></pre>
<p>Mỗi lần sử dụng phương thức push_back, kích thước của container sẽ tăng lên 1. Nếu số phần tử vượt quá kích thước của container, vector sẽ tự động cấp phát lại vùng nhớ đủ để chứa tất cả các phần tử.</p>
<h5>std::vector::pop_back()</h5>
<p>Gọi phương thức này sẽ xóa đi một phần tử tại chỉ số cuối cùng trong container. Ví dụ:</p>
<p></p><pre><code class="lang-auto">std::vector&lt;__int32&gt; vecInt32;
<p>for (int i = 1; i &#x3C;= 10; i++)
{
vecInt32.push_back(i);
}
//container = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }</p>
<p>vecInt32.pop_back();
//container = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }</code></pre></p>
<p>Nếu các bạn sử dụng phương thức này khi container của vector rỗng, Visual studio (trong chế độ Debug) sẽ thông báo chương trình vi phạm điều kiện của assertion trong phương thức <code>pop_back</code>.</p>
<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/1.png?raw=true" width="427" height="328"></p>
<h5>std::vector::insert</h5>
<p>Để sử dụng phương này, chúng ta cần sử dụng thêm STL Iterator, đến bài học về STL Iterator mình sẽ trình bày rõ hơn về phương thức này. Các bạn có thể hiểu đơn giản là một iterator cũng là một con trỏ, nó trỏ vào container của std::vector giúp phương thức insert xác định được vị trí cần chèn phần tử.</p>
<p></p><pre><code class="lang-auto">std::vector&lt;__int32&gt; vecInt32;
std::vector&lt;__int32&gt;::iterator iter;
<p>//iter point to the begin of vecInt32
iter = vecInt32.begin();</p>
<p>//insert new element into vecInt32's container
vecInt32.insert(iter, 10);</p>
<p>//container = { 10 }</p>
<p>iter = vecInt32.end();
vecInt32.insert(iter, 20);</p>
<p>//container = { 10, 20 }</p>
<p>iter = vecInt32.begin() + 1;
vecInt32.insert(iter, 15);</p>
<p>//container = { 10, 15, 20 }</code></pre></p>
<p>Kích thước của container sẽ tự động thay đổi đủ để chứa tất cả các phần tử sau khi insert.</p>
<h5>std::vector::erase(const_iterator position)</h5>
<p>Phương thức này cho phép xóa một phần tử tại vị trí được trỏ đến bởi iterator position. Ví dụ:</p>
<p></p><pre><code class="lang-auto">std::vector&lt;int&gt; myvector;
<p>// set some values (from 1 to 10)
for (int i=1; i&#x3C;=10; i++)
myvector.push_back(i);</p>
<p>// erase the 6th element
myvector.erase (myvector.begin()+5);</p>
<p>//container = { 1, 2, 3, 4, 5, 7, 8, 9, 10 }</code></pre></p>
<h4>Element access</h4>
<h5>operator[size_type index]</h5>
<p>Sử dụng toán tử [] cho vector sẽ trả về giá trị tại chỉ số index được truyền vào (Tương tự mảng một chiều).</p>
<p></p><pre><code class="lang-auto">std::vector&lt;int&gt; myvector(10); //10 zero-initialized elements
<p>for (int i = 0; i &#x3C; myvector.size(); i++)
myvector[i] = i;

std::cout &#x3C;&#x3C; myvector[4] &#x3C;&#x3C; std::endl;</code></pre></p>
<p>Các bạn lưu ý chỉ số bắt đầu của container cũng là 0 giống với mảng một chiều.</p>
<h5>std::vector::at(size_type index)</h5>
<p>Tương tự operator[].</p>
<p></p><pre><code class="lang-auto">std::vector&lt;int&gt; myvector(10); //10 zero-initialized elements
<p>for (int i = 0; i &#x3C; myvector.size(); i++)
myvector[i] = i;

std::cout &#x3C;&#x3C; myvector.at(4) &#x3C;&#x3C; std::endl;</code></pre></p>
<h4>Capacity</h4>
<h5>std::vector::size()</h5>
<p>Phương thức size trả về số lượng phần tử chứa trong container của vector.</p>
<p></p><pre><code class="lang-auto">std::vector&lt;int&gt; myints;
std::cout &lt;&lt; "0. size: " &lt;&lt; myints.size() &lt;&lt; std::endl;
<p>for (int i=0; i&#x3C;10; i++)
myints.push_back(i);

std::cout &#x3C;&#x3C; "1. size: " &#x3C;&#x3C; myints.size() &#x3C;&#x3C; std::endl;</code></pre></p>
<h5>std::vector::max_size()</h5>
<p>Trả về số lượng phần tử tối đa mà vector có thể chứa, đồng nghĩa với kích thước vùng nhớ tối đa có thể cấp phát cho container của vector.</p>
<p></p><pre><code class="lang-auto">std::vector&lt;int&gt; myvector;
<p>// set some content in the vector
for (int i = 0; i&#x3C;100; i++)
myvector.push_back(i);</p>
<p>std::cout &#x3C;&#x3C; "size: " &#x3C;&#x3C; myvector.size() &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; "max_size: " &#x3C;&#x3C; myvector.max_size() &#x3C;&#x3C; std::endl;</code></pre></p>
<h5>std::vector::capacity()</h5>
<p>Trả về kích thước bộ nhớ đã cấp phát cho container của vector.</p>
<p></p><pre><code class="lang-auto">std::vector&lt;int&gt; myvector;
<p>// set some content in the vector
for (int i = 0; i&#x3C;100; i++)
myvector.push_back(i);</p>
<p>std::cout &#x3C;&#x3C; "size: " &#x3C;&#x3C; myvector.size() &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; "capacity: " &#x3C;&#x3C; (int)myvector.capacity() &#x3C;&#x3C; std::endl;</code></pre></p>
<p>Kích thước vùng nhớ được cấp phát cho container thường sẽ lớn hơn số lượng phần tử mà container đang chứa. Điều này đảm bảo khi người dùng thêm phần tử vào container, vector sẽ chưa cần tốn chi phí cấp phát lại vùng nhớ mới.</p>
<p>Mình vừa trình bày một số phương thức đơn giản thường được sử dụng của class std::vector. Các bạn có thể tự mình tìm hiểu các phương thức khác của class std::vector qua đường dẫn sau: </p>
<p><a href="http://www.cplusplus.com/reference/vector/vector/" class="onebox" target="_blank">http://www.cplusplus.com/reference/vector/vector/</a></p>
<h2>std::list</h2>
<p>std::list containers mô phỏng lại cấu trúc dữ liệu doubly-linked lists; Doubly-linked list có thể lưu trữ các phần tử không liên tiếp nhau trên vùng nhớ nhưng vẫn đảm bảo được thứ tự của các phần tử khi truy xuất. Trật tự của các phần tử được giữ bởi những sự kết nối giữa các cặp phần tử. </p>
<p>Cấu trúc dữ liệu doubly-linked list cho phép người dùng thêm và xóa phần tử tại vị trí bất kỳ trong container, nhưng không hổ trợ truy cập ngẫu nhiên.</p>
<h3>Khai báo một std::list</h3>
<p>Để sử dụng std::list, chúng ta cần include thư viện list vào file chương trình. Dưới đây là cú pháp khai báo một đối tượng của lớp std::list:</p>
<p></p><pre><code class="lang-auto">std::list&lt; &lt;data_type&gt; &gt; list_name;</code></pre>
<p>Trong ví dụ dưới đây mình tạo ra một std::list dùng để lưu trữ các phần tử số nguyên:</p>
<p></p><pre><code class="lang-auto">#include &lt;list&gt;
<p>std::list&#x3C;__int32> my_list;</code></pre></p>
<h3>Khởi tạo đối tượng của lớp std::list</h3>
<p>Cũng tương tự như class std::vector, std::list cũng có một số phương thức khởi tạo riêng. Một số phương thức khởi tạo thường dùng như:</p>
<p></p><pre><code class="lang-auto">std::list&lt;__int32&gt; list1(); //gọi default constructor
<p>std::list&#x3C;__int32> list2(5); //gọi phương thức khởi tạo list(size_t _Count), khởi tạo danh sách có _Count phần tử</p>
<p>std::list&#x3C;__int32> list3(list2); //gọi phương thức khởi tạo list(const list_type &#x26;other), khởi tạo danh sách có container giống với other</code></pre></p>
<h3>Sử dụng các phương thức của lớp std::list</h3>
<h4>Capacity</h4>
<p>(Tương tự std::vector)</p>
<h4>Element access</h4>
<p>Đối với cấu trúc dữ liệu doubly-linked list, chúng ta chỉ có thể truy xuất giá trị ở vị trí đầu tiên và cuối cùng trong container, std::list hỗ trợ cho chúng ta 2 phương thức truy xuất.</p>
<h5>std::list::front()</h5>
<p>Phương thức trả về giá trị của phần tử đầu tiên trong list container.</p>
<p></p><pre><code class="lang-auto">std::list&lt;__int32&gt; my_list(5);
std::cout &lt;&lt; my_list.front() &lt;&lt; std::endl;</code></pre>
<h5>std::list::back()</h5>
<p>Ngược lại với phương thức ở trên, phương thức back trả về giá trị của phần tử cuối cùng trong list container.</p>
<p></p><pre><code class="lang-auto">std::list&lt;__int32&gt; my_list(5);
std::cout &lt;&lt; my_list.back() &lt;&lt; std::endl;</code></pre>
<h4>Modifiers</h4>
<h5>std::list::push_back(const list_type &amp;value)</h5>
<p>Phương thức này cho phép thêm một phần tử vào sau phần tử có vị trí cuối cùng trong container, phần tử mới được thêm vào sẽ trở thành phần tử có chỉ số cao nhất trong container. Ví dụ:</p>
<p></p><pre><code class="lang-auto">std::list&lt;int&gt; mylist;
int myint;
<p>std::cout &#x3C;&#x3C; "Please enter some integers (enter 0 to end):" &#x3C;&#x3C; std::endl;</p>
<p>do
{
std::cin >> myint;
mylist.push_back (myint);
} while (myint);</p>
<p>std::cout &#x3C;&#x3C; "mylist stores " &#x3C;&#x3C; mylist.size() &#x3C;&#x3C; " numbers." &#x3C;&#x3C; std::endl;</code></pre></p>
<h5>std::list::pop_back()</h5>
<p>Xóa một phần tử cuối cùng trong list container. Ví dụ:</p>
<p></p><pre><code class="lang-auto">std::list&lt;int&gt; mylist;
int sum (0);
mylist.push_back (100);
mylist.push_back (200);
mylist.push_back (300);
<p>while (!mylist.empty())
{
sum+=mylist.back();
mylist.pop_back();
}</p>
<p>std::cout &#x3C;&#x3C; "The elements of mylist summed " &#x3C;&#x3C; sum &#x3C;&#x3C; std::endl;</code></pre></p>
<p>Phương thức std::list::empty() dùng để kiểm tra container của list có rỗng hay không, nếu số phần tử của list khác 0 thì trả về false, ngược lại trả về true. (Các class containers của STL đều có phương thức này).</p>
<h5>std::list::push_front(const list_type &amp;value)</h5>
<p>Ngược lại với phương thức std::list::push_back, phương thức này dùng để thêm một phần tử có cùng kiểu với list vào vị trí đầu tiên trong container.</p>
<p></p><pre><code class="lang-auto">std::list&lt;int&gt; mylist;
mylist.push_front (200);
mylist.push_front (300);
<p>//container = { 300, 200 }</code></pre></p>
<h5>std::list::pop_front()</h5>
<p>Xóa một phần tử trong list container tại vị trí đầu tiên.</p>
<p></p><pre><code class="lang-auto">std::list&lt;int&gt; mylist;
mylist.push_back (100);
mylist.push_back (200);
mylist.push_back (300);
<p>std::cout &#x3C;&#x3C; "Popping out the elements in mylist: ";
while (!mylist.empty())
{
std::cout &#x3C;&#x3C; ' ' &#x3C;&#x3C; mylist.front();
mylist.pop_front();
}</p>
<p>std::cout &#x3C;&#x3C; std::endl;
std::cout &#x3C;&#x3C; "Final size of mylist is " &#x3C;&#x3C; mylist.size() &#x3C;&#x3C; std::endl;</code></pre></p>
<h4>Operations</h4>
<h5>std::list::sort()</h5>
<p>Phương thức này sẽ sắp xếp lại dữ liệu bên trong container theo thứ tự tăng dần (mặc định là vậy).</p>
<p></p><pre><code class="lang-auto">std::list&lt;__int32&gt; my_list;
std::list&lt;__int32&gt;::iterator iter;
my_list.push_back(4);
my_list.push_back(6);
my_list.push_back(-2);
my_list.push_back(-1);
my_list.push_back(7);
<p>//container = { 4, 6, -2, -1, 7 }</p>
<p>my_list.sort();</p>
<p>//container = { -2, -1, 4, 6, 7 }</code></pre></p>
<p>Các bạn cũng có thể thay đổi điều kiện so sánh của phương thức sort bằng cách tự tạo một hàm so sánh 2 phần tử cùng kiểu dữ liệu với list. Ví dụ:</p>
<p></p><pre><code class="lang-auto">bool my_comparison(__int32 n1, __int32 n2)
{
	return n2 &lt; n1;
}
<p>int main()
{
std::list&#x3C;<strong>int32> my_list;
std::list&#x3C;</strong>int32>::iterator iter;
my_list.push_back(4);
my_list.push_back(6);
my_list.push_back(-2);
my_list.push_back(-1);
my_list.push_back(7);

//container = { 4, 6, -2, -1, 7 }</p>
<pre><code>my_list.sort(my_comparison);

//container = { 7, 6, 4, -1, -2 }

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Mình vừa liệt kê ra một vài phương thức thường dùng khi sử dụng std::list. Các bạn có thể tìm hiểu thêm một số phương thức khác của std::list tại đường dẫn</p>
<p><a href="http://www.cplusplus.com/reference/list/list/" class="onebox" target="_blank">http://www.cplusplus.com/reference/list/list/</a></p>
<p>Vậy là mình đã cùng các bạn tìm hiểu 2 sequence container trong bộ thư viện STL của ngôn ngữ C++. Do giới hạn thời gian và để đảm bảo hiệu suất của khóa học, các container tiếp theo mình sẽ đưa đường dẫn để các bạn tự tìm hiểu các phương thức trong từng class container. Cách tự tìm hiểu cũng giống như mình làm cùng các bạn ở trên.</p>
<h1>Associative container</h1>
<h2>std::set</h2>
<p>std::set là class định nghĩa của một dạng container chỉ cho phép lưu trữ các phần tử có giá trị là duy nhất, phần tử có giá trị trùng lặp là không được cho phép. Những phần tử được thêm vào container sẽ được tự động sắp xếp dựa trên giá trị của chúng.</p>
<p>[](http://www.cplusplus.com/reference/set/set/)</p>
<p>Dưới đây là một đoạn chương trình mẫu sử dụng std::set</p>
<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;set&gt;
<p>int main ()
{
std::set&#x3C;int> myset;
std::set&#x3C;int>::iterator it;</p>
<pre><code>// set some initial values:
for (int i=1; i&#x26;lt;=5; i++) 
    myset.insert(i*10);    // set: 10 20 30 40 50

it = myset.find(20);
myset.erase (it);
myset.erase (myset.find(40));

std::cout &#x26;lt;&#x26;lt; "myset contains:";
for (it=myset.begin(); it!=myset.end(); ++it)
    std::cout &#x26;lt;&#x26;lt; ' ' &#x26;lt;&#x26;lt; *it;
std::cout &#x26;lt;&#x26;lt; std::endl;

return 0;
</code></pre>
<p>}</code></pre></p>
<h2>std::map</h2>
<p>std::map là class định nghĩa một loại container dùng để lưu trữ các phần tử theo cấu trúc kết hợp (key_value, mapped_value). Dữ liệu trong container được sắp xếp dựa trên key_value, do đó key_value không được trùng lặp. Với mỗi key_value sẽ ánh xạ đến một mapped_value duy nhất.</p>
<p><a href="http://www.cplusplus.com/reference/map/map/" class="onebox" target="_blank">http://www.cplusplus.com/reference/map/map/</a></p>
<p>Các bạn lưu ý khi sử dụng std::map, mỗi khi thêm phần tử vào container thì phải thêm đủ một cặp giá trị . Ngôn ngữ C++ cung cấp cho chúng ta class std::pair giúp chúng ta nhóm 2 đối tượng có cùng (hoặc khác) kiểu dữ liệu thành một cặp tương ứng với cặp  của std::map.</p>
<p></p><pre><code class="lang-auto">std::pair&lt; data_type, data_type &gt; pair_name;</code></pre>
<p>Một ví dụ về sử dung std::map để quản lý thông tin nhân viên:</p>
<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
<p>struct Employee
{
std::string name;
__int32 year_of_experience;
};</p>
<p>int main()
{
std::map&#x3C;__int32, Employee> listEmployee;</p>
<pre><code>listEmployee.insert(std::pair&#x26;lt;__int32, Employee&#x26;gt;(1, { "Le Tran Dat", 5 }));
listEmployee.insert(std::pair&#x26;lt;__int32, Employee&#x26;gt;(2, { "Someone", 0 }));

listEmployee[4] = { "new employee", 1 }; //operator[&#x26;lt;key&#x26;gt;] = &#x26;lt;value&#x26;gt;

std::map&#x26;lt;__int32, Employee&#x26;gt;::iterator iter = listEmployee.find(3);
if (iter != listEmployee.end())
{
    std::cout &#x26;lt;&#x26;lt; "Employee ID:        " &#x26;lt;&#x26;lt; iter-&#x26;gt;first &#x26;lt;&#x26;lt; std::endl;
    std::cout &#x26;lt;&#x26;lt; "Employee name:      " &#x26;lt;&#x26;lt; (iter-&#x26;gt;second).name &#x26;lt;&#x26;lt; std::endl;
    std::cout &#x26;lt;&#x26;lt; "Year of experience: " &#x26;lt;&#x26;lt; (iter-&#x26;gt;second).year_of_experience &#x26;lt;&#x26;lt; std::endl;
}
else
{
    std::cout &#x26;lt;&#x26;lt; "ID 3 is not exist" &#x26;lt;&#x26;lt; std::endl;
}

return 0;
</code></pre>
<p>}</code></pre></p>
<h1>Container adapter</h1>
<h2>std::stack</h2>
<p>Stack (hay còn gọi là ngăn xếp) là một dạng container có cơ chế tổ chức lưu trữ dữ liệu đặc biệt: LIFO (Last In First Out).</p>
<p><img src="https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/2.png?raw=true" width="417" height="402"></p>
<p>Phần tử được thêm vào sau cùng sẽ được lấy ra đầu tiên.</p>
<p><a href="http://www.cplusplus.com/reference/stack/stack/" class="onebox" target="_blank">http://www.cplusplus.com/reference/stack/stack/</a></p>
<p>Dưới đây là một ví dụ ứng dụng cách tổ chức lưu trữ của cấu trúc dữ liệu Stack để chuyển đổi một số từ hệ thập phân sang hệ nhị phân:</p>
<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;stack&gt;
<p>int main()
{
//input
__int32 decNumber;
std::cin >> decNumber;</p>
<pre><code>//converting
std::stack&#x26;lt;bool&#x26;gt; binary;
while (decNumber)
{
    binary.push((decNumber % 2 == 1));
    decNumber /= 2;
}

//output
while (!binary.empty())
{
    std::cout &#x26;lt;&#x26;lt; binary.top();
    binary.pop(); //remove an element of stack
}
std::cout &#x26;lt;&#x26;lt; std::endl;

return 0;
</code></pre>
<p>}</code></pre></p>
<p>Cấu trúc dữ liệu Stack còn có nhiều ứng dụng thực tiễn, ví dụ tạo ra chuỗi trạng thái cho phép người dùng trở lại trạng thái trước đó (undo).</p>
<h2>std::queue</h2>
<p>Queue (hay còn gọi là hàng đợi) là một cấu trúc dữ liệu hoạt động ngược lại so với cấu trúc dữ liệu Stack: FIFO (First In First Out). Chúng ta gặp cấu trúc dữ liệu này khá nhiều trong thực tế, ví dụ xếp hàng chờ mua hàng, người nào đến trước sẽ được mua hàng trước và ra khỏi hàng chờ sớm nhất.</p>
<p><a href="http://www.cplusplus.com/reference/queue/queue/" class="onebox" target="_blank">http://www.cplusplus.com/reference/queue/queue/</a></p>
<p>Dưới đây là một ví dụ sử dụng std::queue:</p>
<p></p><pre><code class="lang-auto">#include &lt;iostream&gt;      
#include &lt;queue&gt;         
<p>int main()
{
std::queue&#x3C;int> myqueue;
int myint;</p>
<pre><code>std::cout &#x26;lt;&#x26;lt; "Please enter some integers (enter 0 to end):" &#x26;lt;&#x26;lt; std::endl;

do {
    std::cin &#x26;gt;&#x26;gt; myint;
    myqueue.push(myint);
} while (myint);

std::cout &#x26;lt;&#x26;lt; "myqueue contains: ";
while (!myqueue.empty())
{
    std::cout &#x26;lt;&#x26;lt; ' ' &#x26;lt;&#x26;lt; myqueue.front();
    myqueue.pop();
}
std::cout &#x26;lt;&#x26;lt; std::endl;

return 0;
</code></pre>
<p>}</code></pre></p>
<hr>
<h3>Tổng kết</h3>
<p>Trong bài học này, mình đã hướng dẫn các bạn sử dụng một số class container thuộc Standard Template Library (STL) và cách để tự tìm hiểu cách sử dụng chúng. Về mặt cơ bản, các class container chỉ là một tập các thư viện thực thi các cấu trúc dữ liệu thường sử dụng trong lập trình. Cấu trúc dữ liệu là cách thức tổ chức, định dạng dữ liệu trong bộ nhớ máy tính. Chọn đúng cấu trúc dữ liệu cho một bài toán nào đó có thể giúp lập trình viên giải quyết vấn đề dễ dàng hơn.</p>
<hr>
<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>
<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>
<p><a title="DayNhauHoc" class="onebox" target="_blank">www.daynhauhoc.com</a></p>
</div></div></article><div id="discourse-comments" data-reactid="17"></div></div></div></div><div class="_30zqN _1M-6l" data-reactid="18"><ul style="list-style:none;background-color:transparent;margin:0;padding:0;color:#242a31;font-family:lucida grande ,tahoma,verdana,arial,sans-serif;font-size:14px;" data-reactid="19"><li style="position:relative;" data-reactid="20"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="21"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="22"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="23"><svg height="14" width="14" data-reactid="24"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="25"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="26"><div style="line-height:24px;vertical-align:middle;font-size:1.5em;font-weight:300;font-family:Source Sans Pro,sans-serif;margin-bottom:1em;" data-reactid="27">Khóa học C++</div></div></div><span data-reactid="28"><ul style="list-style:none;padding-left:19px;" data-reactid="29"><li style="position:relative;" data-reactid="30"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="31"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="32"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="33"><svg height="14" width="14" data-reactid="34"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="35"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="36"><div style="line-height:24px;vertical-align:middle;" data-reactid="37">Giới thiệu tổng quan khóa học</div></div></div><span data-reactid="38"></span></li><li style="position:relative;" data-reactid="39"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="40"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="41"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="42"><svg height="14" width="14" data-reactid="43"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="44"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="45"><div style="line-height:24px;vertical-align:middle;" data-reactid="46">C++ cơ bản</div></div></div><span data-reactid="47"></span></li><li style="position:relative;" data-reactid="48"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="49"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="50"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="51"><svg height="14" width="14" data-reactid="52"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="53"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="54"><div style="line-height:24px;vertical-align:middle;" data-reactid="55">Cấu trúc rẽ nhánh</div></div></div><span data-reactid="56"></span></li><li style="position:relative;" data-reactid="57"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="58"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="59"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="60"><svg height="14" width="14" data-reactid="61"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="62"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="63"><div style="line-height:24px;vertical-align:middle;" data-reactid="64">Cấu trúc vòng lặp</div></div></div><span data-reactid="65"></span></li><li style="position:relative;" data-reactid="66"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="67"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="68"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="69"><svg height="14" width="14" data-reactid="70"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="71"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="72"><div style="line-height:24px;vertical-align:middle;" data-reactid="73">Nâng cao về biến, kiểu dữ liệu</div></div></div><span data-reactid="74"></span></li><li style="position:relative;" data-reactid="75"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="76"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="77"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="78"><svg height="14" width="14" data-reactid="79"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="80"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="81"><div style="line-height:24px;vertical-align:middle;" data-reactid="82">Kiểu dữ liệu mảng</div></div></div><span data-reactid="83"></span></li><li style="position:relative;" data-reactid="84"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="85"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="86"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="87"><svg height="14" width="14" data-reactid="88"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="89"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="90"><div style="line-height:24px;vertical-align:middle;" data-reactid="91">Kiểu chuỗi kí tự</div></div></div><span data-reactid="92"></span></li><li style="position:relative;" data-reactid="93"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="94"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="95"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="96"><svg height="14" width="14" data-reactid="97"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="98"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="99"><div style="line-height:24px;vertical-align:middle;" data-reactid="100">Cơ bản về Function</div></div></div><span data-reactid="101"></span></li><li style="position:relative;" data-reactid="102"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="103"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="104"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="105"><svg height="14" width="14" data-reactid="106"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="107"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="108"><div style="line-height:24px;vertical-align:middle;" data-reactid="109">Con trỏ</div></div></div><span data-reactid="110"></span></li><li style="position:relative;" data-reactid="111"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="112"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="113"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="114"><svg height="14" width="14" data-reactid="115"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="116"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="117"><div style="line-height:24px;vertical-align:middle;" data-reactid="118">Kiểu dữ liệu tự định nghĩa</div></div></div><span data-reactid="119"></span></li><li style="position:relative;" data-reactid="120"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="121"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="122"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="123"><svg height="14" width="14" data-reactid="124"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="125"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="126"><div style="line-height:24px;vertical-align:middle;" data-reactid="127">Nhập, xuất, streams (Input &amp; Output)</div></div></div><span data-reactid="128"></span></li><li style="position:relative;" data-reactid="129"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="130"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="131"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="132"><svg height="14" width="14" data-reactid="133"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="134"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="135"><div style="line-height:24px;vertical-align:middle;" data-reactid="136">Standard Template Library</div></div></div><span data-reactid="137"></span></li><li style="position:relative;" data-reactid="138"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="139"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="140"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="141"><svg height="14" width="14" data-reactid="142"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="143"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="144"><div style="line-height:24px;vertical-align:middle;" data-reactid="145">Auto pointer</div></div></div><span data-reactid="146"></span></li><li style="position:relative;" data-reactid="147"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="148"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="149"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="150"><svg height="14" width="14" data-reactid="151"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="152"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="153"><div style="line-height:24px;vertical-align:middle;" data-reactid="154">Quản lý mã nguồn</div></div></div><span data-reactid="155"></span></li><li style="position:relative;" data-reactid="156"><div style="cursor:pointer;position:relative;padding:0px 5px;display:block;" data-reactid="157"><div style="position:relative;display:inline-block;vertical-align:top;margin-left:-5px;height:24px;width:24px;" data-reactid="158"><div style="position:absolute;top:50%;left:50%;margin:-7px 0 0 -7px;height:14px;" data-reactid="159"><svg height="14" width="14" data-reactid="160"><polygon points="0,0 0,14 14,7" style="fill:rgba(26, 187, 156, 0.5);stroke-width:0;" data-reactid="161"></polygon></svg></div></div><div style="display:inline-block;vertical-align:top;color:#242a31;" data-reactid="162"><div style="line-height:24px;vertical-align:middle;" data-reactid="163">Một số feature trong C++11, C++14</div></div></div><span data-reactid="164"></span></li></ul></span></li></ul></div><div class="_3eRtW" data-reactid="165"><span class="SVGInline" data-reactid="166"><?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg class="SVGInline-svg" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 396.667 396.667" style="enable-background:new 0 0 396.667 396.667;" xml:space="preserve">
<g>
	<g>
		<path d="M17,87.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17C0,80.183,7.65,87.833,17,87.833z"/>
		<path d="M17,215.333h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,215.333,17,215.333z"/>
		<path d="M17,342.833h362.667c9.35,0,17-7.65,17-17s-7.65-17-17-17H17c-9.35,0-17,7.65-17,17S7.65,342.833,17,342.833z"/>
	</g>
</g>
</svg></span></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"title":"Cài đặt Code::blocks để lập trình C++ trên Ubuntu/Linux","route":"0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux","id":24563,"description":"int main() {   std::cout &lt;&lt; \"Hello World!\"; }","__filename":"generated/24563.md","__url":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/","__resourceUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html","__dataUrl":"/0/5-cai-dat-code-blocks-de-lap-trinh-c-tren-ubuntu-linux/index.html.3ad2186767d90d121ec4cf565f5c1dd8.json"},{"title":"Cài đặt Xcode để lập trình C++ trên Mac OS X","route":"0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x","id":24606,"description":"int main() {     std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl;     return 0; }","__filename":"generated/24606.md","__url":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/","__resourceUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html","__dataUrl":"/0/5-cai-dat-xcode-de-lap-trinh-c-tren-mac-os-x/index.html.8c393057c45fd132c8e63270c6b51de9.json"},{"title":"0.0 Giới thiệu về series tutorial","route":"0/0-gioi-thieu-ve-series-tutorial","id":29402,"description":"Tóm tắt về bản thân  Minh tên Lê Trần Đạt, 28 tuổi, là lập trình viên lập trình nhúng, ngoài làm việc mình thích dạy học online và viết. Tự…","__filename":"generated/29402.md","__url":"/0/0-gioi-thieu-ve-series-tutorial/","__resourceUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html","__dataUrl":"/0/0-gioi-thieu-ve-series-tutorial/index.html.078c42a7bcb638e7a6288e3b5eca8db0.json"},{"title":"Cài đặt Visual Studio 2015 để lập trình C++ trên Windows","route":"0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows","id":24768,"description":"","__filename":"generated/24768.md","__url":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/","__resourceUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html","__dataUrl":"/0/5-cai-dat-visual-studio-2015-de-lap-trinh-c-tren-windows/index.html.ee5116c3f1d988558f587037fbca2366.json"},{"title":"0.1 Giới thiệu về ngôn ngữ lập trình","route":"0/1-gioi-thieu-ve-ngon-ngu-lap-trinh","id":29425,"description":"","__filename":"generated/29425.md","__url":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/","__resourceUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html","__dataUrl":"/0/1-gioi-thieu-ve-ngon-ngu-lap-trinh/index.html.9809f133b2b8d62313a69257668cb67b.json"},{"title":"0.2 Giới thiệu về ngôn ngữ lập trình C++","route":"0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c","id":29448,"description":"","__filename":"generated/29448.md","__url":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/","__resourceUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html","__dataUrl":"/0/2-gioi-thieu-ve-ngon-ngu-lap-trinh-c/index.html.c812ae7d3909d89717f7e886ac243ab3.json"},{"title":"0.3 Các công đoạn phát triển của một chương trình C++","route":"0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c","id":29449,"description":"","__filename":"generated/29449.md","__url":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/","__resourceUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/0/3-cac-cong-doan-phat-trien-cua-mot-chuong-trinh-c/index.html.f0b19108e622a8c6734cb0d5743e5745.json"},{"title":"0.4 Giới thiệu môi trường phát triển ứng dụng C++","route":"0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c","id":29503,"description":"","__filename":"generated/29503.md","__url":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/","__resourceUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html","__dataUrl":"/0/4-gioi-thieu-moi-truong-phat-trien-ung-dung-c/index.html.2c25af91e3aa61d907d4da959782452c.json"},{"title":"1.0 Viết chương trình đầu tiên","route":"1/0-viet-chuong-trinh-dau-tien","id":29504,"description":"Các bạn sẽ thấy nhiều hàm main có cách khai báo khác nhau. Nhưng với việc bạn là người mới bắt đầu học C++, mình khuyến nghị các bạn nên sử…","__filename":"generated/29504.md","__url":"/1/0-viet-chuong-trinh-dau-tien/","__resourceUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html","__dataUrl":"/1/0-viet-chuong-trinh-dau-tien/index.html.a512d65564a3c061c7f754360a019b46.json"},{"title":"1.1 Cấu trúc cơ bản của một chương trình C++","route":"1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c","id":29527,"description":"\\#include &lt;iostream> using namespace std; int main()\t{ \t// We write some code inside main function. } } / We can put comment everywhere…","__filename":"generated/29527.md","__url":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/","__resourceUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html","__dataUrl":"/1/1-cau-truc-co-ban-cua-mot-chuong-trinh-c/index.html.8df49c7894cffb0fcf8925108166f28e.json"},{"title":"1.10 Độ ưu tiên của các toán tử","route":"1/10-do-uu-tien-cua-cac-toan-tu","id":29574,"description":"","__filename":"generated/29574.md","__url":"/1/10-do-uu-tien-cua-cac-toan-tu/","__resourceUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html","__dataUrl":"/1/10-do-uu-tien-cua-cac-toan-tu/index.html.7a47c8f2c1a6101a3700bbc2c0ee315e.json"},{"title":"1.2 Lệnh, khối lệnh, từ khóa","route":"1/2-lenh-khoi-lenh-tu-khoa","id":29575,"description":"Những dòng lệnh bên trong thân hàm main. (Có thể có hoặc không) Những dòng comment. (Có thể có hoặc không) Tích hợp thư viện và không gian…","__filename":"generated/29575.md","__url":"/1/2-lenh-khoi-lenh-tu-khoa/","__resourceUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html","__dataUrl":"/1/2-lenh-khoi-lenh-tu-khoa/index.html.7475fb0565b3dc36b5f6c2b16530378c.json"},{"title":"1.3 Sử dụng các lệnh liên quan đến xuất dữ liệu","route":"1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu","id":29796,"description":"","__filename":"generated/29796.md","__url":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/","__resourceUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html","__dataUrl":"/1/3-su-dung-cac-lenh-lien-quan-den-xuat-du-lieu/index.html.736841fb7471e11813ab50bf85285809.json"},{"title":"1.4 Biến và các kiểu dữ liệu trong C++","route":"1/4-bien-va-cac-kieu-du-lieu-trong-c","id":29935,"description":"float valueFloat = 5.394; // (2) Xin hệ điều hành thêm một vùng nhớ để chứa 1 số thực string myName = \"Minh Vu\"; // (3) Biến này chứa được…","__filename":"generated/29935.md","__url":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/","__resourceUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html","__dataUrl":"/1/4-bien-va-cac-kieu-du-lieu-trong-c/index.html.13c577638c6f91eda9b5863c77255544.json"},{"title":"1.5 Nhập và xuất dữ liệu","route":"1/5-nhap-va-xuat-du-lieu","id":29936,"description":"","__filename":"generated/29936.md","__url":"/1/5-nhap-va-xuat-du-lieu/","__resourceUrl":"/1/5-nhap-va-xuat-du-lieu/index.html","__dataUrl":"/1/5-nhap-va-xuat-du-lieu/index.html.ef6e11684dfcb7f6b992aba2c8e21426.json"},{"title":"1.6 Hằng số","route":"1/6-hang-so","id":29938,"description":"","__filename":"generated/29938.md","__url":"/1/6-hang-so/","__resourceUrl":"/1/6-hang-so/index.html","__dataUrl":"/1/6-hang-so/index.html.f3ddc6bdde6d54a411e4b79e348d0572.json"},{"title":"1.7 Phạm vi của biến","route":"1/7-pham-vi-cua-bien","id":29939,"description":"int value = 1; int main()\t{ }","__filename":"generated/29939.md","__url":"/1/7-pham-vi-cua-bien/","__resourceUrl":"/1/7-pham-vi-cua-bien/index.html","__dataUrl":"/1/7-pham-vi-cua-bien/index.html.7b8e3af7da9532eb3642eb19b7367ed9.json"},{"title":"1.8 Các phép toán cơ bản","route":"1/8-cac-phep-toan-co-ban","id":29944,"description":"int another_variable = 3; variable = another_variable \\* 2; variable = variable + 1; //tăng giá trị biến variable lên 1. variable =…","__filename":"generated/29944.md","__url":"/1/8-cac-phep-toan-co-ban/","__resourceUrl":"/1/8-cac-phep-toan-co-ban/index.html","__dataUrl":"/1/8-cac-phep-toan-co-ban/index.html.e7174a44027feba3c434a4373886310e.json"},{"title":"1.9 Toán tử tăng giảm","route":"1/9-toan-tu-tang-giam","id":29945,"description":"","__filename":"generated/29945.md","__url":"/1/9-toan-tu-tang-giam/","__resourceUrl":"/1/9-toan-tu-tang-giam/index.html","__dataUrl":"/1/9-toan-tu-tang-giam/index.html.17809ba92bb7526bb6d72300ea06de47.json"},{"title":"2.0 Boolean","route":"2/0-boolean","id":29992,"description":"int a = 2, b = 4; a \\* 3 != b; //đúng int main() { \tcout &lt;&lt; true &lt;&lt; endl; \tcout &lt;&lt; false &lt;&lt; endl; } int main() {…","__filename":"generated/29992.md","__url":"/2/0-boolean/","__resourceUrl":"/2/0-boolean/index.html","__dataUrl":"/2/0-boolean/index.html.62f9a66039eff1016579fc6484f79273.json"},{"title":"2.1 Giới thiệu một số cấu trúc điều khiển","route":"2/1-gioi-thieu-mot-so-cau-truc-dieu-khien","id":30007,"description":"int main() { \tcout &lt;&lt; \"This line is printed out.\" &lt;&lt; endl; \texit(-1); //Terminate and return -1 to operating system.  \tcout…","__filename":"generated/30007.md","__url":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/","__resourceUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html","__dataUrl":"/2/1-gioi-thieu-mot-so-cau-truc-dieu-khien/index.html.1d4fd6576fff1c9f6ebbde9296cb7ccf.json"},{"title":"2.2 if statements","route":"2/2-if-statements","id":30008,"description":"} } if(value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; } if (value >= 0) { \tcout &lt;&lt; \"Positive number\" &lt;&lt; endl; }…","__filename":"generated/30008.md","__url":"/2/2-if-statements/","__resourceUrl":"/2/2-if-statements/index.html","__dataUrl":"/2/2-if-statements/index.html.5fc7b6ae8899008a02ec037a2bf0194c.json"},{"title":"2.3 switch case statements","route":"2/3-switch-case-statements","id":30009,"description":"} }","__filename":"generated/30009.md","__url":"/2/3-switch-case-statements/","__resourceUrl":"/2/3-switch-case-statements/index.html","__dataUrl":"/2/3-switch-case-statements/index.html.51348d4d78f70d37586bb9c11de9341f.json"},{"title":"3.0 Vòng lặp while","route":"3/0-vong-lap-while","id":30011,"description":"} while (score &lt; 4) { \tcount++; \tcout &lt;&lt; \"Learn C++ programming language...\" &lt;&lt; endl; \tcout &lt;&lt; \"Enter your final…","__filename":"generated/30011.md","__url":"/3/0-vong-lap-while/","__resourceUrl":"/3/0-vong-lap-while/index.html","__dataUrl":"/3/0-vong-lap-while/index.html.ca3b73cc92989d89c9963bb13aeaa718.json"},{"title":"3.1 Vòng lặp do-while","route":"3/1-vong-lap-do-while","id":30012,"description":"} const int ID = 123; const int password = 123456; int main() { \t//................. }","__filename":"generated/30012.md","__url":"/3/1-vong-lap-do-while/","__resourceUrl":"/3/1-vong-lap-do-while/index.html","__dataUrl":"/3/1-vong-lap-do-while/index.html.9652947ce2cac76fc244291dfe0e7da9.json"},{"title":"3.2 Vòng lặp for","route":"3/2-vong-lap-for","id":30013,"description":"}","__filename":"generated/30013.md","__url":"/3/2-vong-lap-for/","__resourceUrl":"/3/2-vong-lap-for/index.html","__dataUrl":"/3/2-vong-lap-for/index.html.91200558d1e346b99f3bfe6615546b0d.json"},{"title":"3.3 từ khóa break và continue","route":"3/3-tu-khoa-break-va-continue","id":30014,"description":"} } }","__filename":"generated/30014.md","__url":"/3/3-tu-khoa-break-va-continue/","__resourceUrl":"/3/3-tu-khoa-break-va-continue/index.html","__dataUrl":"/3/3-tu-khoa-break-va-continue/index.html.ce5d9d1bafbf829b21faafe2d437e44f.json"},{"title":"4.0 Sử dụng thư viện cstdint","route":"4/0-su-dung-thu-vien-cstdint","id":30016,"description":"int main()\t{ } //in ra kết quả là giá trị lớn nhất của 5 số vừa nhập //in ra kết quả là giá trị nhỏ nhất của 5 số vừa nhập int main()\t {…","__filename":"generated/30016.md","__url":"/4/0-su-dung-thu-vien-cstdint/","__resourceUrl":"/4/0-su-dung-thu-vien-cstdint/index.html","__dataUrl":"/4/0-su-dung-thu-vien-cstdint/index.html.a2801fa4ada10c23f504f07e4ee78b63.json"},{"title":"4.2 Ép kiểu dữ liệu","route":"4/2-ep-kieu-du-lieu","id":30019,"description":"","__filename":"generated/30019.md","__url":"/4/2-ep-kieu-du-lieu/","__resourceUrl":"/4/2-ep-kieu-du-lieu/index.html","__dataUrl":"/4/2-ep-kieu-du-lieu/index.html.2ce390588cf4f5b31eb1090272f305c3.json"},{"title":"4.1 Kiểu kí tự","route":"4/1-kieu-ki-tu","id":30018,"description":"//check if there is any character exist in stdin file object if (!cin.eof())\t{ \tcout &lt;&lt; \"There are some character more in stdin file…","__filename":"generated/30018.md","__url":"/4/1-kieu-ki-tu/","__resourceUrl":"/4/1-kieu-ki-tu/index.html","__dataUrl":"/4/1-kieu-ki-tu/index.html.3d3eff45a05d59492b7b40b7e7817293.json"},{"title":"4.3 auto và decltype","route":"4/3-auto-va-decltype","id":30020,"description":"// compare the type of n with type int32_t if (typeid(int32_t) == typeid(n)) \tcout &lt;&lt; \"n is an object of type int32_t\" &lt;&lt; endl;…","__filename":"generated/30020.md","__url":"/4/3-auto-va-decltype/","__resourceUrl":"/4/3-auto-va-decltype/index.html","__dataUrl":"/4/3-auto-va-decltype/index.html.0d8f1c6d9c4f8f1eff25628a38272254.json"},{"title":"4.4 Địa chỉ của biến","route":"4/4-dia-chi-cua-bien","id":30022,"description":"cout &lt;&lt; \"Value of var: \" &lt;&lt; var &lt;&lt; endl; cout &lt;&lt; \"Value of var_reference: \" &lt;&lt; var_reference &lt;&lt; endl;…","__filename":"generated/30022.md","__url":"/4/4-dia-chi-cua-bien/","__resourceUrl":"/4/4-dia-chi-cua-bien/index.html","__dataUrl":"/4/4-dia-chi-cua-bien/index.html.7700a863d95ebd2c72f590db3ae556c8.json"},{"title":"5.0 Mảng một chiều","route":"5/0-mang-mot-chieu","id":30080,"description":"//another way num_of_elements = sizeof(d_values) / sizeof(d_values[0]); cout &lt;&lt; \"Number of elements = \" &lt;&lt; num_of_elements…","__filename":"generated/30080.md","__url":"/5/0-mang-mot-chieu/","__resourceUrl":"/5/0-mang-mot-chieu/index.html","__dataUrl":"/5/0-mang-mot-chieu/index.html.2bdadf3c58a38e337057a0de9d3374f6.json"},{"title":"5.1 Các thao tác cơ bản với mảng một chiều","route":"5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu","id":30082,"description":"int32_t arr[ARRAY_SIZE];\t int32_t arr_clone[ARRAY_SIZE]; } } int main() { \tchar ch_array\\[] = { 'L', 'e', 'T', 'r', 'a', 'n', 'D', 'a',…","__filename":"generated/30082.md","__url":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/","__resourceUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html","__dataUrl":"/5/1-cac-thao-tac-co-ban-voi-mang-mot-chieu/index.html.c358cb5702d7e0848c1d0fcafea76326.json"},{"title":"5.2 Thư viện array trong STL","route":"5/2-thu-vien-array-trong-stl","id":30083,"description":"//Access to all of elements of arr object for (int32_t index = 0; index &lt;= arr.size() - 1; index++) { \tcout &lt;&lt; arr[index] &lt;&lt;…","__filename":"generated/30083.md","__url":"/5/2-thu-vien-array-trong-stl/","__resourceUrl":"/5/2-thu-vien-array-trong-stl/index.html","__dataUrl":"/5/2-thu-vien-array-trong-stl/index.html.f6855e3cf847058a20cddbfbd1924e9a.json"},{"title":"5.3 Mảng hai chiều","route":"5/3-mang-hai-chieu","id":30085,"description":"for(int row = 0; row &lt; 3; row++) { \tfor(int col = 0; col &lt; 4; col++) \t{ \t\tcout &lt;&lt; board[row][col] &lt;&lt; \" \"; \t} \tcout…","__filename":"generated/30085.md","__url":"/5/3-mang-hai-chieu/","__resourceUrl":"/5/3-mang-hai-chieu/index.html","__dataUrl":"/5/3-mang-hai-chieu/index.html.20eabc78d6c5ccd506f5e0a0d9bc1987.json"},{"title":"5.4 Các thao tác cơ bản với mảng hai chiều","route":"5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu","id":30086,"description":"} }","__filename":"generated/30086.md","__url":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/","__resourceUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html","__dataUrl":"/5/4-cac-thao-tac-co-ban-voi-mang-hai-chieu/index.html.d255b4de5fe60dec619e7ce656009b5a.json"},{"title":"6.0 Mảng kí tự","route":"6/0-mang-ki-tu","id":30090,"description":"cout &lt;&lt; \"Enter your full name: \"; cin >> full_name; cout &lt;&lt; \"Your full name is \" &lt;&lt; full_name &lt;&lt; endl; cout…","__filename":"generated/30090.md","__url":"/6/0-mang-ki-tu/","__resourceUrl":"/6/0-mang-ki-tu/index.html","__dataUrl":"/6/0-mang-ki-tu/index.html.c07e54b9b2919b7ae2f406f37d0fbed3.json"},{"title":"6.1 Các thao tác cơ bản với mảng kí tự","route":"6/1-cac-thao-tac-co-ban-voi-mang-ki-tu","id":30091,"description":"memset(foo, '-', 7); cout &lt;&lt; foo &lt;&lt; endl; \\-------every programmer should know memset! strcpy(str_destination, str_source);…","__filename":"generated/30091.md","__url":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/","__resourceUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html","__dataUrl":"/6/1-cac-thao-tac-co-ban-voi-mang-ki-tu/index.html.f0846f159064ae244ee4452151734f0f.json"},{"title":"6.2 Thư viện string trong C++","route":"6/2-thu-vien-string-trong-c","id":30092,"description":"//......... string my_string; string temp_string(\"What the hell is going on?\"); string one_more = temp_string; string…","__filename":"generated/30092.md","__url":"/6/2-thu-vien-string-trong-c/","__resourceUrl":"/6/2-thu-vien-string-trong-c/index.html","__dataUrl":"/6/2-thu-vien-string-trong-c/index.html.c5528a05ca23fbe3ff253526b42ee2f6.json"},{"title":"7.0 Làm quen với khái niệm function","route":"7/0-lam-quen-voi-khai-niem-function","id":30132,"description":"if(strlen(str1) == strlen(str2))\t{ \t//do something } void introduce() { \tcout &lt;&lt; \"Hello!\" &lt;&lt; endl; \tcout &lt;&lt; \"I'm a…","__filename":"generated/30132.md","__url":"/7/0-lam-quen-voi-khai-niem-function/","__resourceUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html","__dataUrl":"/7/0-lam-quen-voi-khai-niem-function/index.html.6701f9806c1a33418b356bcbfebc4392.json"},{"title":"7.1 Thiết kế chương trình dựa trên khái niệm function","route":"7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function","id":30133,"description":"} } float subtraction(float value1, float value2) { \treturn value1 - value2; } float multiplication(float value1, float value2) { \treturn…","__filename":"generated/30133.md","__url":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/","__resourceUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html","__dataUrl":"/7/1-thiet-ke-chuong-trinh-dua-tren-khai-niem-function/index.html.0dd052d16304cb05be843573b6ec0e45.json"},{"title":"7.2 Truyền đối số cho hàm là giá trị hoặc tham chiếu","route":"7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu","id":30319,"description":"} } int main() { \tint argument; \tcout &lt;&lt; \"Address of argument: \" &lt;&lt; &argument &lt;&lt; endl;…","__filename":"generated/30319.md","__url":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/2-truyen-doi-so-cho-ham-la-gia-tri-hoac-tham-chieu/index.html.3219ee44dcef6a14dae07111a5c0abf3.json"},{"title":"7.3 Hàm trả về giá trị hoặc tham chiếu","route":"7/3-ham-tra-ve-gia-tri-hoac-tham-chieu","id":30381,"description":"// .............. // function call int result = doubleValue(10); // ................ // function call int & myRef = returnReference(); for…","__filename":"generated/30381.md","__url":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/","__resourceUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html","__dataUrl":"/7/3-ham-tra-ve-gia-tri-hoac-tham-chieu/index.html.4288591cda8969c5c9199b250877f786.json"},{"title":"7.4 Tham số mặc định, tham số hằng","route":"7/4-tham-so-mac-dinh-tham-so-hang","id":30382,"description":"int main() { \tstring non_const_msg = \"This is non-const message\"; \tconst string const_msg = \"This is const message\"; } int main() { }","__filename":"generated/30382.md","__url":"/7/4-tham-so-mac-dinh-tham-so-hang/","__resourceUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html","__dataUrl":"/7/4-tham-so-mac-dinh-tham-so-hang/index.html.b234bc219b3b3db4f46f8d654d7af624.json"},{"title":"7.5 Function overloading","route":"7/5-function-overloading","id":30477,"description":"float addFloat(float f1, float f2) { \treturn f1 + f2; } float add(float f1, float f2) { \treturn f1 + f2; } print(0); print('a'); print('a');","__filename":"generated/30477.md","__url":"/7/5-function-overloading/","__resourceUrl":"/7/5-function-overloading/index.html","__dataUrl":"/7/5-function-overloading/index.html.5657ec584a875acb4601350f19853ed3.json"},{"title":"8.0 Con trỏ","route":"8/0-con-tr","id":30541,"description":"cout &lt;&lt; &i1 &lt;&lt; endl;    //get address of i1 cout &lt;&lt; &i_ref &lt;&lt; endl; //get address of i_ref cout &lt;&lt; n &lt;&lt;…","__filename":"generated/30541.md","__url":"/8/0-con-tr/","__resourceUrl":"/8/0-con-tr/index.html","__dataUrl":"/8/0-con-tr/index.html.a46c66f365403503c34cafdc9863cfa3.json"},{"title":"8.1 Toán tử tăng, giảm dùng cho con trỏ","route":"8/1-toan-tu-tang-giam-dung-cho-con-tr","id":30699,"description":"cout &lt;&lt; \"Before decreased: \" &lt;&lt; ptr &lt;&lt; endl; ptr--; cout &lt;&lt; \" After decreased: \" &lt;&lt; ptr &lt;&lt; endl; cout…","__filename":"generated/30699.md","__url":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/","__resourceUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html","__dataUrl":"/8/1-toan-tu-tang-giam-dung-cho-con-tr/index.html.cce9500249671524aec88406806baa9e.json"},{"title":"8.2 Con trỏ và mảng một chiều","route":"8/2-con-tr-va-mang-mot-chieu","id":30788,"description":"//show address of the first element of arr cout &lt;&lt; &arr[0] &lt;&lt; endl; //show address of the first element of arr cout &lt;&lt;…","__filename":"generated/30788.md","__url":"/8/2-con-tr-va-mang-mot-chieu/","__resourceUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html","__dataUrl":"/8/2-con-tr-va-mang-mot-chieu/index.html.3c8778e4780dd872224eef1cc8f11097.json"},{"title":"8.3 Con trỏ và mảng kí tự","route":"8/3-con-tr-va-mang-ki-tu","id":30876,"description":"p_name[1] = 'E'; cout &lt;&lt; my_name &lt;&lt; endl; cout &lt;&lt; p_name &lt;&lt; endl; } \"Le Tran Dat\"[1] = 'E'; //this line will make…","__filename":"generated/30876.md","__url":"/8/3-con-tr-va-mang-ki-tu/","__resourceUrl":"/8/3-con-tr-va-mang-ki-tu/index.html","__dataUrl":"/8/3-con-tr-va-mang-ki-tu/index.html.dc406539fbe2db6bafb4f3a63ad20fbc.json"},{"title":"8.4 Cấp phát bộ nhớ động","route":"8/4-cap-phat-bo-nho-dong","id":31145,"description":"} } //using memory area at p //and then set it free delete p; delete p; //keep using that memory area \\*p = 10; cout &lt;&lt; p &lt;&lt;…","__filename":"generated/31145.md","__url":"/8/4-cap-phat-bo-nho-dong/","__resourceUrl":"/8/4-cap-phat-bo-nho-dong/index.html","__dataUrl":"/8/4-cap-phat-bo-nho-dong/index.html.e0fca4aed8a1bfd6079218b8f9cd5649.json"},{"title":"8.5 Con trỏ và hằng","route":"8/5-con-tr-va-hang","id":31355,"description":"int value1 = 5; ptr = &value1; int value2 = 10; ptr = &value2; &ptr = 10; //compile error int otherValue = 10; ptr = &otherValue; //compile…","__filename":"generated/31355.md","__url":"/8/5-con-tr-va-hang/","__resourceUrl":"/8/5-con-tr-va-hang/index.html","__dataUrl":"/8/5-con-tr-va-hang/index.html.9717e378d7312e77dd0af404f3ce878a.json"},{"title":"8.6 Con trỏ void","route":"8/6-con-tr-void","id":31625,"description":"int \\*iArr = new int[10]; ptr = iArr; delete\\[] iArr; int iPtr = static_cast&lt;int > (vPtr); cout &lt;&lt; \\*iPtr &lt;&lt; endl; int iPtr…","__filename":"generated/31625.md","__url":"/8/6-con-tr-void/","__resourceUrl":"/8/6-con-tr-void/index.html","__dataUrl":"/8/6-con-tr-void/index.html.95810b485beb7091df5fbe0cdad166a6.json"},{"title":"8.8 Con trỏ và hàm","route":"8/8-con-tr-va-ham","id":31810,"description":"int main()\t { \tint iValue = 10; \tfoo(&iValue); } int main() { \tint iValue = 5; \tcout &lt;&lt; \"Value = \" &lt;&lt; iValue &lt;&lt; endl; }…","__filename":"generated/31810.md","__url":"/8/8-con-tr-va-ham/","__resourceUrl":"/8/8-con-tr-va-ham/index.html","__dataUrl":"/8/8-con-tr-va-ham/index.html.807439d811fbe3c25a6fe7de6f440dcd.json"},{"title":"8.9 Con trỏ hàm","route":"8/9-con-tr-ham","id":31959,"description":"int main()\t { \tint n = foo(); } int main() { \tcout &lt;&lt; foo &lt;&lt; endl; } int main() { \tvoid(\\*pSwap) (int &, int &) = swapValue;…","__filename":"generated/31959.md","__url":"/8/9-con-tr-ham/","__resourceUrl":"/8/9-con-tr-ham/index.html","__dataUrl":"/8/9-con-tr-ham/index.html.95b3e8ea543c2c88ac5aed6fae7dd5bc.json"},{"title":"8.10 Phân loại các vùng nhớ (stack & heap ...)","route":"8/10-phan-loai-cac-vung-nho-stack-va-heap","id":32101,"description":"","__filename":"generated/32101.md","__url":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/","__resourceUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html","__dataUrl":"/8/10-phan-loai-cac-vung-nho-stack-va-heap/index.html.f3d953ab58d5d6d7caa9a6825ab85eff.json"},{"title":"8.11 Các vấn đề thường gặp khi sử dụng con trỏ","route":"8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr","id":32133,"description":"} } } char  getName(char fullname) { } int main()\t{ } } } } int main()\t{ } int main() { \tint \\*p = newIntValue(0); } int \\*pTemp = ptr; ptr…","__filename":"generated/32133.md","__url":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/","__resourceUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html","__dataUrl":"/8/11-cac-van-de-thuong-gap-khi-su-dung-con-tr/index.html.9b5398e8d66b8730b73fe13cf4859166.json"},{"title":"8.7 Con trỏ trỏ đến con trỏ","route":"8/7-con-tr-tr-den-con-tr","id":32159,"description":"} } } int \\*p_to_p = new int[3]; p_to_p[0] = p1; p_to_p[1] = p2; p_to_p[2] = p3; delete\\[] p_to_p; for(int i = 0; i &lt; 3; i++) {…","__filename":"generated/32159.md","__url":"/8/7-con-tr-tr-den-con-tr/","__resourceUrl":"/8/7-con-tr-tr-den-con-tr/index.html","__dataUrl":"/8/7-con-tr-tr-den-con-tr/index.html.9e711455792370d4585f9b6422ec5c75.json"},{"title":"9.0 Kiểu liệt kê (enum)","route":"9/0-kieu-liet-ke-enum","id":32760,"description":"enum Color { \tRED, \tGREEN, \tBLUE, \tWHITE }; enum Animal { \tCAT, \tDOG, \tHORSE, \tMONKEY, \tCHICKEN }; } int iValue = LETTER_A; cout &lt;&lt;…","__filename":"generated/32760.md","__url":"/9/0-kieu-liet-ke-enum/","__resourceUrl":"/9/0-kieu-liet-ke-enum/index.html","__dataUrl":"/9/0-kieu-liet-ke-enum/index.html.5bcab9708527435f7e4986ca2293f162.json"},{"title":"9.1 Structs","route":"9/1-structs","id":33291,"description":"struct VietNamPeople { \tint32 ID; \tstd::string name; \tint16 age; \tfloat height; \tfloat weight; \tbool isStudent; }; //................…","__filename":"generated/33291.md","__url":"/9/1-structs/","__resourceUrl":"/9/1-structs/index.html","__dataUrl":"/9/1-structs/index.html.218b89a947ee10e7345fd63f614e71bf.json"},{"title":"9.2 Structs and pointer","route":"9/2-structs-and-pointer","id":33521,"description":"int main() { \tBankAccount myAccount = { 123456789, 50 }; // $50 \tBankAccount \\*pAccount = &myAccount;  } int main() { \tBankAccount…","__filename":"generated/33521.md","__url":"/9/2-structs-and-pointer/","__resourceUrl":"/9/2-structs-and-pointer/index.html","__dataUrl":"/9/2-structs-and-pointer/index.html.3dac4346cb7783e552949ccfe8b270fd.json"},{"title":"11.0 Giới thiệu về STL","route":"11/0-gioi-thieu-ve-stl","id":34001,"description":"","__filename":"generated/34001.md","__url":"/11/0-gioi-thieu-ve-stl/","__resourceUrl":"/11/0-gioi-thieu-ve-stl/index.html","__dataUrl":"/11/0-gioi-thieu-ve-stl/index.html.d381e349b21471222160fc598695cb22.json"},{"title":"11.1 STL containers","route":"11/1-stl-containers","id":34210,"description":"std::vector&lt;\\_\\_int32> vecInt32; std::vector&lt;int32> vec2(5); //gọi phương thức khởi tạo std::vector(size_t \\_Count) với giá trị…","__filename":"generated/34210.md","__url":"/11/1-stl-containers/","__resourceUrl":"/11/1-stl-containers/index.html","__dataUrl":"/11/1-stl-containers/index.html.801d3937ec25c5210d7a3d9a39a6cc9b.json"},{"title":"Khóa học C++","description":"Cạnh tranh với Udemy luôn. Các bạn vào nhập mã REHON_UDEMY Hoặc bấm vào link này http&#x3A;//bit.ly/rehon_udemy Vào đăng ký học rẻ hơn mã…","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.b5876e909f5a87e4ec2b20bf919bf9fa.json"}];window.__INITIAL_STATE__ = {"pages":{"/11/1-stl-containers/":{"head":{"title":"11.1 STL containers","route":"11/1-stl-containers","id":34210,"description":"std::vector&lt;\\_\\_int32> vecInt32; std::vector&lt;int32> vec2(5); //gọi phương thức khởi tạo std::vector(size_t \\_Count) với giá trị…"},"body":"<h4>Chào các bạn đang theo dõi khóa học lập trình trực tuyến ngôn ngữ C++.</h4>\n<p>Trong bài học này, mình sẽ hướng dẫn các bạn cách sử dụng một số container class của STL. Trước các bài học trước đây, mình đã từng giới thiệu đến các bạn một class thuộc STL, đó là <a href=\"//daynhauhoc.com/t/thu-vien-array-trong-stl-c/30083\">std::array</a> (trong chương mảng một chiều) hay là <a href=\"//daynhauhoc.com/t/thu-vien-string-trong-c/30092\">std::string</a> trong chương mảng kí tự. <code>std::array</code> thư viện khá đơn giản có thể dùng để thay thế cho mảng một chiều.</p>\n<p>Tuy nhiên, nhược điểm của std::array (cũng là nhược điểm của mảng một chiều) là kích thước bộ nhớ được cấp phát là cố định. Do đó, khả năng khai báo thiếu số lượng phần tử hoặc dư thừa quá mức cần thiết thường xuyên xảy ra. Để khắc phục nhược điểm này, STL đã hổ trợ cho chúng ta các container class khác dùng để lưu trữ, xử lý các phần tử với kích thước vùng nhớ tự động thay đổi để phù hợp với yêu cầu người dùng.</p>\n<p>Trước khi đi vào tìm hiểu các container class của STL, chúng ta nên phân chúng ra thành 3 loại container khác nhau:</p>\n<ul>\n<li>\n<p>Sequence container</p>\n<p>Sequence container là tập hợp các container class nó duy trì trật tự của các phần tử bên trong container. Một đặc tính của Sequence container là các bạn có thể chọn ví trí muốn chèn thêm phần tử vào container. Một ví dụ điển hình là khi các bạn thêm một phần tử vào mảng một chiều, các phần tử còn lại vẫn giữ nguyên thứ tự của chúng như trước khi chèn. </p>\n<p>Ngôn ngữ C++11 cung cấp cho chúng ta 6 sequence containers: <strong>std::vector, std::deque, std::array, std::list, std::forward_list, std::basic_string</strong>.</p>\n</li>\n<li>\n<p>Associative container</p>\n<p>Associative container là các container được thiết kế kèm theo cơ chế tự động sắp xếp dữ liệu đầu vào khi chúng được đưa vào container. Cơ chế tổ chức dữ liệu của các container này sẽ quyết định vị trí của các phần tử trong container. Thông thường, associative container thực hiện phép so sánh sử dụng toán tử &lt;.</p>\n<p>Một số associative container được sử dụng phổ biến là: <strong>std::set, std::map...</strong></p>\n</li>\n<li>\n<p>Container adapter</p>\n<p>Container adapter là các container được sử dụng cho các cấu trúc lưu trữ đặc biệt: <strong>std::stack, std::queue, ...</strong></p>\n</li>\n</ul>\n<h1>Sequence container</h1>\n<h2>std::vector</h2>\n<p>Cũng giống như std::array, vectors lưu trữ các phần tử liên tiếp nhau trên bộ nhớ ảo. Điều này có nghĩa những phần tử trong std::vector có thể truy cập thông qua các con trỏ có cùng kiểu dữ liệu với kiểu của std::vector. Đặc điểm khiến std::vector khác với std::array là nó có thể thay đổi kích thước container tự động khi các phương thức, các toán tử được định nghĩa bên trong class std::vector được sử dụng.</p>\n<h3>Khai báo một std::vector</h3>\n<p>Để sử dụng std::vector, chúng ta cần include thư viện vector vào file chương trình. Dưới đây là cú pháp khai báo cơ bản để tạo ra một đối tượng từ lớp std::vector:</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt; &lt;data_type&gt; &gt; &lt;vector_name&gt;;</code></pre>\n<p><strong>data_type</strong> của vector là một kiểu dữ liệu tổng quát, các bạn có thể chọn tùy ý dựa vào mục đích lưu trữ của chương trình, nó có thể là một kiểu dữ liệu built-in, cũng có thể là kiểu dữ liệu struct do các bạn tự định nghĩa ra. Mình lấy một ví dụ như sau:</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;vector&gt;\n<p>std::vector&#x3C;__int32> vecInt32;</code></pre></p>\n<p>Như vậy là chúng ta đã có một đối tượng của lớp std::vector có thể lưu trữ các phần tử kiểu <code>__int32</code> trong container. Lúc này, container của vecInt32 vẫn chưa có phần tử nào cả, chúng ta có thể kiểm chứng bằng cách sử dụng phương thức std::vector::size() để kiểm tra kích thước của container.</p>\n<p></p><pre><code class=\"lang-auto\">std::cout &lt;&lt; \"Size of vecInt32: \" &lt;&lt; vecInt32.size() &lt;&lt; std::endl;</code></pre>\n<p>Kết quả cho ra màn hình là 0 (tương ứng với 0 phần tử hiện tại có trong container của vecInt32).</p>\n<h3>Một số phương thức khởi tạo cho đối tượng của lớp std::vector</h3>\n<p>Sau này khi học đến phần C++ Object oriented programming, các bạn sẽ biết rằng một class có thể có một hoặc nhiều phương thức khởi tạo giá trị cho các thành phần dữ liệu bên trong class đó. Class std::vector có đến hơn 10 phương thức khởi tạo khác nhau:</p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/0.png?raw=true\" width=\"653\" height=\"209\"></p>\n<p>Tuy nhiên, mình chỉ hướng dẫn các bạn sử dụng một số phương thức khởi tạo đơn giản. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vec1(); //gọi phương thức khởi tạo mặc định, khởi tạo kích thước container là 0.\n<p>std::vector&#x3C;<strong>int32> vec2(5); //gọi phương thức khởi tạo std::vector(size_t _Count) với giá trị truyền vào là 5, khởi tạo kích thước container là 5 phần tử kiểu </strong>int32.</p>\n<p>std::vector&#x3C;__int32> vec3(vec2); //gọi phương thức khởi tạo std::vector(const std::vector &#x26;other), khởi tạo một container giống với container của vector other.</code></pre></p>\n<p>Những phương thức khởi tạo còn lại thường ít được sử dụng.</p>\n<h3>Sử dụng các phương thức trong class std::vector</h3>\n<p>Sau khi các bạn khai báo (có thể có khởi tạo hoặc không) một đối tượng của lớp std::vector, lúc này chúng ta có thể sử dụng các phương thức (các hàm bên trong lớp) trong lớp std::vector để thao tác với container của đối tượng đó.</p>\n<h4>Modifiers</h4>\n<h5>std::vector::push_back(const vector_type &amp;value)</h5>\n<blockquote><p>Khi mình viết std::vector::push_back, các bạn có thể hiểu phương thức push_back được định nghĩa bên trong khối lệnh có tên vector, và vector được định nghĩa bên trong khối lệnh của std.</p></blockquote>\n<p>Phương thức này cho phép thêm một phần tử vào sau phần tử có vị trí cuối cùng trong container, phần tử mới được thêm vào sẽ trở thành phần tử có chỉ số cao nhất trong container. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vecInt32;\nfor (int i = 1; i &lt;= 10; i++)\n{\n    vecInt32.push_back(i);\n}</code></pre>\n<p>Mỗi lần sử dụng phương thức push_back, kích thước của container sẽ tăng lên 1. Nếu số phần tử vượt quá kích thước của container, vector sẽ tự động cấp phát lại vùng nhớ đủ để chứa tất cả các phần tử.</p>\n<h5>std::vector::pop_back()</h5>\n<p>Gọi phương thức này sẽ xóa đi một phần tử tại chỉ số cuối cùng trong container. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vecInt32;\n<p>for (int i = 1; i &#x3C;= 10; i++)\n{\nvecInt32.push_back(i);\n}\n//container = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }</p>\n<p>vecInt32.pop_back();\n//container = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }</code></pre></p>\n<p>Nếu các bạn sử dụng phương thức này khi container của vector rỗng, Visual studio (trong chế độ Debug) sẽ thông báo chương trình vi phạm điều kiện của assertion trong phương thức <code>pop_back</code>.</p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/1.png?raw=true\" width=\"427\" height=\"328\"></p>\n<h5>std::vector::insert</h5>\n<p>Để sử dụng phương này, chúng ta cần sử dụng thêm STL Iterator, đến bài học về STL Iterator mình sẽ trình bày rõ hơn về phương thức này. Các bạn có thể hiểu đơn giản là một iterator cũng là một con trỏ, nó trỏ vào container của std::vector giúp phương thức insert xác định được vị trí cần chèn phần tử.</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;__int32&gt; vecInt32;\nstd::vector&lt;__int32&gt;::iterator iter;\n<p>//iter point to the begin of vecInt32\niter = vecInt32.begin();</p>\n<p>//insert new element into vecInt32's container\nvecInt32.insert(iter, 10);</p>\n<p>//container = { 10 }</p>\n<p>iter = vecInt32.end();\nvecInt32.insert(iter, 20);</p>\n<p>//container = { 10, 20 }</p>\n<p>iter = vecInt32.begin() + 1;\nvecInt32.insert(iter, 15);</p>\n<p>//container = { 10, 15, 20 }</code></pre></p>\n<p>Kích thước của container sẽ tự động thay đổi đủ để chứa tất cả các phần tử sau khi insert.</p>\n<h5>std::vector::erase(const_iterator position)</h5>\n<p>Phương thức này cho phép xóa một phần tử tại vị trí được trỏ đến bởi iterator position. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector;\n<p>// set some values (from 1 to 10)\nfor (int i=1; i&#x3C;=10; i++)\nmyvector.push_back(i);</p>\n<p>// erase the 6th element\nmyvector.erase (myvector.begin()+5);</p>\n<p>//container = { 1, 2, 3, 4, 5, 7, 8, 9, 10 }</code></pre></p>\n<h4>Element access</h4>\n<h5>operator[size_type index]</h5>\n<p>Sử dụng toán tử [] cho vector sẽ trả về giá trị tại chỉ số index được truyền vào (Tương tự mảng một chiều).</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector(10); //10 zero-initialized elements\n<p>for (int i = 0; i &#x3C; myvector.size(); i++)\nmyvector[i] = i;\n\nstd::cout &#x3C;&#x3C; myvector[4] &#x3C;&#x3C; std::endl;</code></pre></p>\n<p>Các bạn lưu ý chỉ số bắt đầu của container cũng là 0 giống với mảng một chiều.</p>\n<h5>std::vector::at(size_type index)</h5>\n<p>Tương tự operator[].</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector(10); //10 zero-initialized elements\n<p>for (int i = 0; i &#x3C; myvector.size(); i++)\nmyvector[i] = i;\n\nstd::cout &#x3C;&#x3C; myvector.at(4) &#x3C;&#x3C; std::endl;</code></pre></p>\n<h4>Capacity</h4>\n<h5>std::vector::size()</h5>\n<p>Phương thức size trả về số lượng phần tử chứa trong container của vector.</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myints;\nstd::cout &lt;&lt; \"0. size: \" &lt;&lt; myints.size() &lt;&lt; std::endl;\n<p>for (int i=0; i&#x3C;10; i++)\nmyints.push_back(i);\n\nstd::cout &#x3C;&#x3C; \"1. size: \" &#x3C;&#x3C; myints.size() &#x3C;&#x3C; std::endl;</code></pre></p>\n<h5>std::vector::max_size()</h5>\n<p>Trả về số lượng phần tử tối đa mà vector có thể chứa, đồng nghĩa với kích thước vùng nhớ tối đa có thể cấp phát cho container của vector.</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector;\n<p>// set some content in the vector\nfor (int i = 0; i&#x3C;100; i++)\nmyvector.push_back(i);</p>\n<p>std::cout &#x3C;&#x3C; \"size: \" &#x3C;&#x3C; myvector.size() &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; \"max_size: \" &#x3C;&#x3C; myvector.max_size() &#x3C;&#x3C; std::endl;</code></pre></p>\n<h5>std::vector::capacity()</h5>\n<p>Trả về kích thước bộ nhớ đã cấp phát cho container của vector.</p>\n<p></p><pre><code class=\"lang-auto\">std::vector&lt;int&gt; myvector;\n<p>// set some content in the vector\nfor (int i = 0; i&#x3C;100; i++)\nmyvector.push_back(i);</p>\n<p>std::cout &#x3C;&#x3C; \"size: \" &#x3C;&#x3C; myvector.size() &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; \"capacity: \" &#x3C;&#x3C; (int)myvector.capacity() &#x3C;&#x3C; std::endl;</code></pre></p>\n<p>Kích thước vùng nhớ được cấp phát cho container thường sẽ lớn hơn số lượng phần tử mà container đang chứa. Điều này đảm bảo khi người dùng thêm phần tử vào container, vector sẽ chưa cần tốn chi phí cấp phát lại vùng nhớ mới.</p>\n<p>Mình vừa trình bày một số phương thức đơn giản thường được sử dụng của class std::vector. Các bạn có thể tự mình tìm hiểu các phương thức khác của class std::vector qua đường dẫn sau: </p>\n<p><a href=\"http://www.cplusplus.com/reference/vector/vector/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/vector/vector/</a></p>\n<h2>std::list</h2>\n<p>std::list containers mô phỏng lại cấu trúc dữ liệu doubly-linked lists; Doubly-linked list có thể lưu trữ các phần tử không liên tiếp nhau trên vùng nhớ nhưng vẫn đảm bảo được thứ tự của các phần tử khi truy xuất. Trật tự của các phần tử được giữ bởi những sự kết nối giữa các cặp phần tử. </p>\n<p>Cấu trúc dữ liệu doubly-linked list cho phép người dùng thêm và xóa phần tử tại vị trí bất kỳ trong container, nhưng không hổ trợ truy cập ngẫu nhiên.</p>\n<h3>Khai báo một std::list</h3>\n<p>Để sử dụng std::list, chúng ta cần include thư viện list vào file chương trình. Dưới đây là cú pháp khai báo một đối tượng của lớp std::list:</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt; &lt;data_type&gt; &gt; list_name;</code></pre>\n<p>Trong ví dụ dưới đây mình tạo ra một std::list dùng để lưu trữ các phần tử số nguyên:</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;list&gt;\n<p>std::list&#x3C;__int32> my_list;</code></pre></p>\n<h3>Khởi tạo đối tượng của lớp std::list</h3>\n<p>Cũng tương tự như class std::vector, std::list cũng có một số phương thức khởi tạo riêng. Một số phương thức khởi tạo thường dùng như:</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; list1(); //gọi default constructor\n<p>std::list&#x3C;__int32> list2(5); //gọi phương thức khởi tạo list(size_t _Count), khởi tạo danh sách có _Count phần tử</p>\n<p>std::list&#x3C;__int32> list3(list2); //gọi phương thức khởi tạo list(const list_type &#x26;other), khởi tạo danh sách có container giống với other</code></pre></p>\n<h3>Sử dụng các phương thức của lớp std::list</h3>\n<h4>Capacity</h4>\n<p>(Tương tự std::vector)</p>\n<h4>Element access</h4>\n<p>Đối với cấu trúc dữ liệu doubly-linked list, chúng ta chỉ có thể truy xuất giá trị ở vị trí đầu tiên và cuối cùng trong container, std::list hỗ trợ cho chúng ta 2 phương thức truy xuất.</p>\n<h5>std::list::front()</h5>\n<p>Phương thức trả về giá trị của phần tử đầu tiên trong list container.</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; my_list(5);\nstd::cout &lt;&lt; my_list.front() &lt;&lt; std::endl;</code></pre>\n<h5>std::list::back()</h5>\n<p>Ngược lại với phương thức ở trên, phương thức back trả về giá trị của phần tử cuối cùng trong list container.</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; my_list(5);\nstd::cout &lt;&lt; my_list.back() &lt;&lt; std::endl;</code></pre>\n<h4>Modifiers</h4>\n<h5>std::list::push_back(const list_type &amp;value)</h5>\n<p>Phương thức này cho phép thêm một phần tử vào sau phần tử có vị trí cuối cùng trong container, phần tử mới được thêm vào sẽ trở thành phần tử có chỉ số cao nhất trong container. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nint myint;\n<p>std::cout &#x3C;&#x3C; \"Please enter some integers (enter 0 to end):\" &#x3C;&#x3C; std::endl;</p>\n<p>do\n{\nstd::cin >> myint;\nmylist.push_back (myint);\n} while (myint);</p>\n<p>std::cout &#x3C;&#x3C; \"mylist stores \" &#x3C;&#x3C; mylist.size() &#x3C;&#x3C; \" numbers.\" &#x3C;&#x3C; std::endl;</code></pre></p>\n<h5>std::list::pop_back()</h5>\n<p>Xóa một phần tử cuối cùng trong list container. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nint sum (0);\nmylist.push_back (100);\nmylist.push_back (200);\nmylist.push_back (300);\n<p>while (!mylist.empty())\n{\nsum+=mylist.back();\nmylist.pop_back();\n}</p>\n<p>std::cout &#x3C;&#x3C; \"The elements of mylist summed \" &#x3C;&#x3C; sum &#x3C;&#x3C; std::endl;</code></pre></p>\n<p>Phương thức std::list::empty() dùng để kiểm tra container của list có rỗng hay không, nếu số phần tử của list khác 0 thì trả về false, ngược lại trả về true. (Các class containers của STL đều có phương thức này).</p>\n<h5>std::list::push_front(const list_type &amp;value)</h5>\n<p>Ngược lại với phương thức std::list::push_back, phương thức này dùng để thêm một phần tử có cùng kiểu với list vào vị trí đầu tiên trong container.</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nmylist.push_front (200);\nmylist.push_front (300);\n<p>//container = { 300, 200 }</code></pre></p>\n<h5>std::list::pop_front()</h5>\n<p>Xóa một phần tử trong list container tại vị trí đầu tiên.</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;int&gt; mylist;\nmylist.push_back (100);\nmylist.push_back (200);\nmylist.push_back (300);\n<p>std::cout &#x3C;&#x3C; \"Popping out the elements in mylist: \";\nwhile (!mylist.empty())\n{\nstd::cout &#x3C;&#x3C; ' ' &#x3C;&#x3C; mylist.front();\nmylist.pop_front();\n}</p>\n<p>std::cout &#x3C;&#x3C; std::endl;\nstd::cout &#x3C;&#x3C; \"Final size of mylist is \" &#x3C;&#x3C; mylist.size() &#x3C;&#x3C; std::endl;</code></pre></p>\n<h4>Operations</h4>\n<h5>std::list::sort()</h5>\n<p>Phương thức này sẽ sắp xếp lại dữ liệu bên trong container theo thứ tự tăng dần (mặc định là vậy).</p>\n<p></p><pre><code class=\"lang-auto\">std::list&lt;__int32&gt; my_list;\nstd::list&lt;__int32&gt;::iterator iter;\nmy_list.push_back(4);\nmy_list.push_back(6);\nmy_list.push_back(-2);\nmy_list.push_back(-1);\nmy_list.push_back(7);\n<p>//container = { 4, 6, -2, -1, 7 }</p>\n<p>my_list.sort();</p>\n<p>//container = { -2, -1, 4, 6, 7 }</code></pre></p>\n<p>Các bạn cũng có thể thay đổi điều kiện so sánh của phương thức sort bằng cách tự tạo một hàm so sánh 2 phần tử cùng kiểu dữ liệu với list. Ví dụ:</p>\n<p></p><pre><code class=\"lang-auto\">bool my_comparison(__int32 n1, __int32 n2)\n{\n\treturn n2 &lt; n1;\n}\n<p>int main()\n{\nstd::list&#x3C;<strong>int32> my_list;\nstd::list&#x3C;</strong>int32>::iterator iter;\nmy_list.push_back(4);\nmy_list.push_back(6);\nmy_list.push_back(-2);\nmy_list.push_back(-1);\nmy_list.push_back(7);\n\n//container = { 4, 6, -2, -1, 7 }</p>\n<pre><code>my_list.sort(my_comparison);\n\n//container = { 7, 6, 4, -1, -2 }\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Mình vừa liệt kê ra một vài phương thức thường dùng khi sử dụng std::list. Các bạn có thể tìm hiểu thêm một số phương thức khác của std::list tại đường dẫn</p>\n<p><a href=\"http://www.cplusplus.com/reference/list/list/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/list/list/</a></p>\n<p>Vậy là mình đã cùng các bạn tìm hiểu 2 sequence container trong bộ thư viện STL của ngôn ngữ C++. Do giới hạn thời gian và để đảm bảo hiệu suất của khóa học, các container tiếp theo mình sẽ đưa đường dẫn để các bạn tự tìm hiểu các phương thức trong từng class container. Cách tự tìm hiểu cũng giống như mình làm cùng các bạn ở trên.</p>\n<h1>Associative container</h1>\n<h2>std::set</h2>\n<p>std::set là class định nghĩa của một dạng container chỉ cho phép lưu trữ các phần tử có giá trị là duy nhất, phần tử có giá trị trùng lặp là không được cho phép. Những phần tử được thêm vào container sẽ được tự động sắp xếp dựa trên giá trị của chúng.</p>\n<p>[](http://www.cplusplus.com/reference/set/set/)</p>\n<p>Dưới đây là một đoạn chương trình mẫu sử dụng std::set</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;set&gt;\n<p>int main ()\n{\nstd::set&#x3C;int> myset;\nstd::set&#x3C;int>::iterator it;</p>\n<pre><code>// set some initial values:\nfor (int i=1; i&#x26;lt;=5; i++) \n    myset.insert(i*10);    // set: 10 20 30 40 50\n\nit = myset.find(20);\nmyset.erase (it);\nmyset.erase (myset.find(40));\n\nstd::cout &#x26;lt;&#x26;lt; \"myset contains:\";\nfor (it=myset.begin(); it!=myset.end(); ++it)\n    std::cout &#x26;lt;&#x26;lt; ' ' &#x26;lt;&#x26;lt; *it;\nstd::cout &#x26;lt;&#x26;lt; std::endl;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<h2>std::map</h2>\n<p>std::map là class định nghĩa một loại container dùng để lưu trữ các phần tử theo cấu trúc kết hợp (key_value, mapped_value). Dữ liệu trong container được sắp xếp dựa trên key_value, do đó key_value không được trùng lặp. Với mỗi key_value sẽ ánh xạ đến một mapped_value duy nhất.</p>\n<p><a href=\"http://www.cplusplus.com/reference/map/map/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/map/map/</a></p>\n<p>Các bạn lưu ý khi sử dụng std::map, mỗi khi thêm phần tử vào container thì phải thêm đủ một cặp giá trị . Ngôn ngữ C++ cung cấp cho chúng ta class std::pair giúp chúng ta nhóm 2 đối tượng có cùng (hoặc khác) kiểu dữ liệu thành một cặp tương ứng với cặp  của std::map.</p>\n<p></p><pre><code class=\"lang-auto\">std::pair&lt; data_type, data_type &gt; pair_name;</code></pre>\n<p>Một ví dụ về sử dung std::map để quản lý thông tin nhân viên:</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n<p>struct Employee\n{\nstd::string name;\n__int32 year_of_experience;\n};</p>\n<p>int main()\n{\nstd::map&#x3C;__int32, Employee> listEmployee;</p>\n<pre><code>listEmployee.insert(std::pair&#x26;lt;__int32, Employee&#x26;gt;(1, { \"Le Tran Dat\", 5 }));\nlistEmployee.insert(std::pair&#x26;lt;__int32, Employee&#x26;gt;(2, { \"Someone\", 0 }));\n\nlistEmployee[4] = { \"new employee\", 1 }; //operator[&#x26;lt;key&#x26;gt;] = &#x26;lt;value&#x26;gt;\n\nstd::map&#x26;lt;__int32, Employee&#x26;gt;::iterator iter = listEmployee.find(3);\nif (iter != listEmployee.end())\n{\n    std::cout &#x26;lt;&#x26;lt; \"Employee ID:        \" &#x26;lt;&#x26;lt; iter-&#x26;gt;first &#x26;lt;&#x26;lt; std::endl;\n    std::cout &#x26;lt;&#x26;lt; \"Employee name:      \" &#x26;lt;&#x26;lt; (iter-&#x26;gt;second).name &#x26;lt;&#x26;lt; std::endl;\n    std::cout &#x26;lt;&#x26;lt; \"Year of experience: \" &#x26;lt;&#x26;lt; (iter-&#x26;gt;second).year_of_experience &#x26;lt;&#x26;lt; std::endl;\n}\nelse\n{\n    std::cout &#x26;lt;&#x26;lt; \"ID 3 is not exist\" &#x26;lt;&#x26;lt; std::endl;\n}\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<h1>Container adapter</h1>\n<h2>std::stack</h2>\n<p>Stack (hay còn gọi là ngăn xếp) là một dạng container có cơ chế tổ chức lưu trữ dữ liệu đặc biệt: LIFO (Last In First Out).</p>\n<p><img src=\"https://github.com/nguyenchiemminhvu/CPP-Tutorial/blob/master/11-STL/11-1-STL-containers/2.png?raw=true\" width=\"417\" height=\"402\"></p>\n<p>Phần tử được thêm vào sau cùng sẽ được lấy ra đầu tiên.</p>\n<p><a href=\"http://www.cplusplus.com/reference/stack/stack/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/stack/stack/</a></p>\n<p>Dưới đây là một ví dụ ứng dụng cách tổ chức lưu trữ của cấu trúc dữ liệu Stack để chuyển đổi một số từ hệ thập phân sang hệ nhị phân:</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n<p>int main()\n{\n//input\n__int32 decNumber;\nstd::cin >> decNumber;</p>\n<pre><code>//converting\nstd::stack&#x26;lt;bool&#x26;gt; binary;\nwhile (decNumber)\n{\n    binary.push((decNumber % 2 == 1));\n    decNumber /= 2;\n}\n\n//output\nwhile (!binary.empty())\n{\n    std::cout &#x26;lt;&#x26;lt; binary.top();\n    binary.pop(); //remove an element of stack\n}\nstd::cout &#x26;lt;&#x26;lt; std::endl;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<p>Cấu trúc dữ liệu Stack còn có nhiều ứng dụng thực tiễn, ví dụ tạo ra chuỗi trạng thái cho phép người dùng trở lại trạng thái trước đó (undo).</p>\n<h2>std::queue</h2>\n<p>Queue (hay còn gọi là hàng đợi) là một cấu trúc dữ liệu hoạt động ngược lại so với cấu trúc dữ liệu Stack: FIFO (First In First Out). Chúng ta gặp cấu trúc dữ liệu này khá nhiều trong thực tế, ví dụ xếp hàng chờ mua hàng, người nào đến trước sẽ được mua hàng trước và ra khỏi hàng chờ sớm nhất.</p>\n<p><a href=\"http://www.cplusplus.com/reference/queue/queue/\" class=\"onebox\" target=\"_blank\">http://www.cplusplus.com/reference/queue/queue/</a></p>\n<p>Dưới đây là một ví dụ sử dụng std::queue:</p>\n<p></p><pre><code class=\"lang-auto\">#include &lt;iostream&gt;      \n#include &lt;queue&gt;         \n<p>int main()\n{\nstd::queue&#x3C;int> myqueue;\nint myint;</p>\n<pre><code>std::cout &#x26;lt;&#x26;lt; \"Please enter some integers (enter 0 to end):\" &#x26;lt;&#x26;lt; std::endl;\n\ndo {\n    std::cin &#x26;gt;&#x26;gt; myint;\n    myqueue.push(myint);\n} while (myint);\n\nstd::cout &#x26;lt;&#x26;lt; \"myqueue contains: \";\nwhile (!myqueue.empty())\n{\n    std::cout &#x26;lt;&#x26;lt; ' ' &#x26;lt;&#x26;lt; myqueue.front();\n    myqueue.pop();\n}\nstd::cout &#x26;lt;&#x26;lt; std::endl;\n\nreturn 0;\n</code></pre>\n<p>}</code></pre></p>\n<hr>\n<h3>Tổng kết</h3>\n<p>Trong bài học này, mình đã hướng dẫn các bạn sử dụng một số class container thuộc Standard Template Library (STL) và cách để tự tìm hiểu cách sử dụng chúng. Về mặt cơ bản, các class container chỉ là một tập các thư viện thực thi các cấu trúc dữ liệu thường sử dụng trong lập trình. Cấu trúc dữ liệu là cách thức tổ chức, định dạng dữ liệu trong bộ nhớ máy tính. Chọn đúng cấu trúc dữ liệu cho một bài toán nào đó có thể giúp lập trình viên giải quyết vấn đề dễ dàng hơn.</p>\n<hr>\n<p><strong>Hẹn gặp lại các bạn trong bài học tiếp theo trong khóa học lập trình C++ hướng thực hành.</strong></p>\n<p>Mọi ý kiến đóng góp hoặc thắc mắc có thể đặt câu hỏi trực tiếp tại diễn đàn </p>\n<p><a title=\"DayNhauHoc\" class=\"onebox\" target=\"_blank\">www.daynhauhoc.com</a></p>\n","__filename":"generated/34210.md","__url":"/11/1-stl-containers/","__resourceUrl":"/11/1-stl-containers/index.html","__dataUrl":"/11/1-stl-containers/index.html.801d3937ec25c5210d7a3d9a39a6cc9b.json"}}}</script><script src="/phenomic.browser.29012679faa1a8abbdd1.js"></script></body></html>